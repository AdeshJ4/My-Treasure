Redis (Remote Dictionary Server) is an "in-memory data store" used as a **database**, **cache**, and **message broker**. 
It is highly performant and supports various data structures like **strings, lists, sets, sorted sets, hashes, bitmaps, hyperloglogs, and streams**.


ğŸ“¨ Message Broker (in short):
A message broker is a software that helps different services or applications communicate with each other asynchronously by sending and receiving messages


What is an In-Memory Data Structure?
An in-memory data structure is a type of data storage that keeps all its data in RAM (Random Access Memory) instead of traditional disk-based storage 
(like databases on HDDs or SSDs). 
This makes data access, retrieval, and manipulation extremely fast compared to disk-based databases.



Redis stores data in the RAM of the server where Redis is running, NOT the clientâ€™s RAM.
 
ğŸ“Œ Explanation
Redis is an in-memory database, meaning all data is stored in RAM for fast access.
The Redis server runs on a machine (your local machine, a remote server, or a cloud instance).
When a client (e.g., a Node.js app) connects to Redis, it sends commands to the Redis server, which retrieves and returns the data from server RAM.
The client does NOT store Redis data in its own RAM, only temporarily holding the data received from Redis.



---

### ğŸ”¥ **Why Use Redis?**
#### 1ï¸âƒ£ **Caching for Performance Improvement**
   - Redis is often used to **cache frequently accessed data** (e.g., database query results, API responses) to **reduce latency** and **improve speed**.
   - Since Redis is in-memory, fetching data is **much faster** than querying a database.

#### 2ï¸âƒ£ **Session Management**
   - Used for storing **user session data** in web applications.
   - Faster and more scalable than storing sessions in traditional databases.

#### 3ï¸âƒ£ **Rate Limiting & Throttling**
   - Helps in implementing **API rate limiting** (e.g., allowing only X requests per minute).
   - Used in **login attempt restrictions** (e.g., blocking users after multiple failed login attempts).

#### 4ï¸âƒ£ **Real-time Analytics & Leaderboards**
   - Redis supports **sorted sets**, which are useful for creating **real-time leaderboards** (e.g., tracking top players in a game).
   - Used for **tracking active users, real-time counts**, and other analytics.

#### 5ï¸âƒ£ **Message Queues & Pub/Sub**
   - Redis can be used as a **message broker** for real-time messaging using its **Pub/Sub (Publish/Subscribe) system**.
   - Helps in **decoupling microservices** and building event-driven architectures.

#### 6ï¸âƒ£ **Distributed Locking**
   - Ensures **synchronization between processes** in distributed systems.
   - Prevents **race conditions** in applications.

#### 7ï¸âƒ£ **Full-Text Search & Auto-Complete**
   - Redis allows **fast searching** using indexing features.
   - Helps in **auto-complete suggestions** in applications.

---

### ğŸ›  **Where is Redis Used?**
âœ… **E-commerce** â€“ Caching product details, managing user sessions  
âœ… **Social Media** â€“ Storing trending topics, real-time notifications  
âœ… **Gaming** â€“ Leaderboards, multiplayer session management  
âœ… **Streaming Services** â€“ Video metadata caching, real-time recommendations  
âœ… **Finance** â€“ Real-time fraud detection, transaction tracking  

---

### ğŸš€ **Example: Using Redis as a Cache**
Letâ€™s say you have an e-commerce app, and you want to **cache product details** to reduce database queries:

1ï¸âƒ£ First, check if the product is in Redis:
```js
const product = await redis.get(`product:${productId}`);
if (product) {
  return JSON.parse(product); // Return cached product
}
```
  
2ï¸âƒ£ If not in Redis, fetch from the database and cache it:
```js
const product = await database.getProductById(productId);
await redis.set(`product:${productId}`, JSON.stringify(product), "EX", 3600); // Cache for 1 hour
return product;
```

---

### ğŸ **Conclusion**
Redis is a **powerful** tool that improves **performance, scalability, and reliability** in modern applications. Whether you need **fast caching, real-time analytics, or distributed locking**, Redis is an excellent choice! ğŸš€


=====================================================================


Redis vs Redis Stack: What's the Difference?


Redis runs as a CLI-based server (command-line interface).
Redis Stack includes RedisInsight, a "GUI tool" to visualize and manage Redis data easily.
Redis Stack also adds extra features like JSON, Search, and Graph.

Redis Stack is an enhanced version of Redis with additional features.
Redis Stack Comes with built-in modules: RedisJSON, RedisSearch, RedisGraph, RedisBloom, and RedisTimeSerie




=====================================================================






**Redis is a server**. It runs as a **Redis server process**, allowing clients (applications) to connect and interact with it over a network.  

---

### **Why is Redis a Server?**
âœ… **It Listens on a Port:**  
   - By default, Redis runs on **port 6379** and waits for client connections.  

âœ… **Handles Client Requests:**  
   - Clients (e.g., web apps, backend services) send commands like `SET`, `GET`, `LPUSH`, etc.  
   - Redis processes these commands and responds with the requested data.  

âœ… **Supports Multiple Connections:**  
   - Many clients (Node.js, Python, Java, etc.) can connect to Redis at the same time.  

âœ… **Standalone or Distributed Mode:**  
   - It can work as a single instance or as a **cluster** for scalability and high availability.  

---

### **How to Start Redis Server?**
#### **1ï¸âƒ£ Start Redis Server (Linux/macOS)**
```sh
redis-server
```
#### **2ï¸âƒ£ Start Redis Server (Windows)**
```sh
redis-server.exe
```
#### **3ï¸âƒ£ Check If Redis is Running**
```sh
redis-cli ping
```
âœ… If Redis is running, it will respond with:
```
PONG
```

---

### **Redis as a Database vs Server**
| Feature       | Redis as a Server                                     | Redis as a Database                                 |
| ------------- | ----------------------------------------------------- | --------------------------------------------------- |
| Purpose       | Listens for client connections and executes commands. | Stores and retrieves key-value data.                |
| Functionality | Handles network requests from multiple clients.       | Maintains in-memory data with optional persistence. |
| Persistence   | Runs continuously as a background process.            | Saves snapshots (RDB) or logs changes (AOF).        |

### **Final Thoughts**
Yes, **Redis is a server**, but it is also an **in-memory database, cache, and message broker**. It acts as a **centralized storage system** that clients interact with over a network. ğŸš€








============================================================================================================================================================







install redis stack with docker (redis/redis-stack): 
```
docker run -d --name redis-stack -p 6379:6379 -p 8001:8001 redis/redis-stack:latest
```

after that run this : 
```
step 1: docker exec -it <container_id> bash
step 2: root@4ee445f5d6b9:/# redis-cli  (this terminal is connected to redis server)
```

then visit : http://localhost:8001/redis-stack/browser   (this open GUI - No need in production)










============================================================================================================================================================



Data Types: 


1. String: 

naming convention:
set <entity>:<id> value
user collection:
|------------|
| Id | Name  |
|------------|
| 1  | Adesh |
| 2  | Max   |
| 3  | Mosh  |
|------------|
ex: 
set user:1 Adesh
set user:2 Max
set user:3 Mosh


Operations:
ğŸ‘‰Insert single value: (Overwrites value if key exists)
redis> set user:1 Adesh
"Adesh"

ğŸ‘‰Insert unique value: (nx)
redis> set user:3 Adesh nx
(nil) // user:3 already exists.

ğŸ‘‰Insert Multiple values: (Overwrites value if key exists)
You cannot use conditions like NX or XX with MSET.
redis> mset customer:1 Adesh user:1 Mosh msg:1 Hi
OK

ğŸ‘‰get single key-value: 
redis> get user:1
"Adesh"

ğŸ‘‰get multiple key-value at once
redis> mget user:1 user:2 customer:1 message:3
1) "Adesh"
2) "Pramod"
3) "user_1"
4) "How are you"
redis> 


ğŸ”¹ Increment & Decrement a Counter in Redis
increment count by 1:
redis> incr num

decrement count by 1:
redis> decr num

increment count by 10:
redis> incrby count 10

decrement count by 10:
redis> decrby count 10




GETRANGE: 
Returns the substring of the string value stored at key, determined by the offsets start and end (both are inclusive). 
Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.

redis> GET mykey 
"This is a string"
redis> GETRANGE mykey 0 3
"This"
redis> GETRANGE mykey -3 -1
"ing"
redis> GETRANGE mykey 0 -1
"This is a string"
redis> GETRANGE mykey 10 100
"string"
redis> 




SETRANGE:
The SETRANGE command modifies a part of an existing string at a specified offset (position), without replacing the entire value.
```
SETRANGE key offset value
```
ğŸ”¹ key â€“ The key of the string.
ğŸ”¹ offset â€“ The position where the update starts (0-based index).
ğŸ”¹ value â€“ The new string to insert starting from offset.



redis> SET msg "Hello World"
OK
redis> SETRANGE msg 6 "Redis"   // Replaces "World" with "Redis" starting at index 6.
(integer) 11
redis> GET msg
"Hello Redis"


redis> SET msg "Hello"
OK
redis> SETRANGE msg 3 "p!"   // Tries to insert "!" at index 5, but "Hi" is only 2 characters long. Redis pads the missing spaces with \0 (null bytes).
(integer) 5
redis> get msg
"Help!"
redis> 


redis> SET msg "Hi"
OK
redis> SETRANGE msg 5 "!"
(integer) 6
redis> GET msg
"Hi\x00\x00\x00!"
redis> 




expire key after specified time: 
await client.expire("rental:1", 10)  // delete key after 10 sec






============================================================================================================================================================






If Redis is displaying **old data**, it means the cache is not updating properly. Users will get **stale data** instead of fresh data from the database.  

### **ğŸ”¹ Why Does Redis Show Old Data?**
Redis is commonly used as a **cache** to store frequently accessed data. If the cache is not refreshed, users will see outdated information.  

---

### **ğŸ”¹ How Can Users Get New Data?**  

#### âœ… **1. Set an Expiry Time (TTL)**
- Use `EX` (seconds) or `PX` (milliseconds) when setting data.
- Example: Store user data for **10 minutes** (600 seconds).
  ```sh
  SET user:1 "John Doe" EX 600
  ```
- After 600 seconds, Redis automatically removes the old data, and the next request will fetch fresh data from the database.

---

#### âœ… **2. Use Cache Invalidation**
- When new data is updated in the database, **delete the old cache**.
- Example in Node.js (with `ioredis`):
  ```js
  const Redis = require("ioredis");
  const redis = new Redis();

  async function updateUser(userId, newData) {
      // Update in database (MongoDB, SQL, etc.)
      await db.updateUser(userId, newData);

      // Remove old cache
      await redis.del(`user:${userId}`);
  }
  ```

- The next time the user requests data, the app will **fetch fresh data** from the database and store it in Redis again.

---

#### âœ… **3. Use a Write-Through Cache Strategy**
- When updating the database, **update Redis at the same time**.
- Example:
  ```js
  await db.updateUser(userId, newData);
  await redis.set(`user:${userId}`, JSON.stringify(newData), "EX", 600);
  ```
- This ensures Redis always has the latest data.

---

#### âœ… **4. Bypass Redis and Fetch Fresh Data**
- If users need real-time data, you can **skip Redis** for some requests.
- Example: If `?nocache=true` is passed in the request, fetch data directly from the database.
  ```js
  app.get("/user/:id", async (req, res) => {
      const userId = req.params.id;
      const noCache = req.query.nocache === "true";

      if (!noCache) {
          const cachedUser = await redis.get(`user:${userId}`);
          if (cachedUser) return res.json(JSON.parse(cachedUser));
      }

      const freshUser = await db.getUser(userId);
      await redis.set(`user:${userId}`, JSON.stringify(freshUser), "EX", 600);
      res.json(freshUser);
  });
  ```
- This allows users to get fresh data **when needed**.

---

### **ğŸ”¹ Key Takeaways**
âœ… **If Redis is showing old data**, the cache is not updating properly.  
âœ… **Solutions:** Use TTL, cache invalidation, write-through caching, or bypass Redis for fresh data.  
âœ… **The best approach depends on how often your data changes** (e.g., user profiles, real-time stock prices, etc.).  

Do you need help implementing this in your project? ğŸš€





============================================================================================================================================================





### **ğŸ”¹ What is Rate Limiting?**  
=========================================
**Rate limiting** is a technique used to **control the number of requests** a user can make to a server **within a specific time period**.  

It helps to:  
âœ… **Prevent API abuse** (e.g., bots, DDoS attacks).  
âœ… **Protect server resources** (avoid overload).  
âœ… **Ensure fair usage** (limit per user/IP).  

---

### **ğŸ”¹ Example: How Rate Limiting Works?**  
Imagine a movie rental app where users can **search for movies**.  
ğŸ”¹ **Rule:** Each user can send **only 10 requests per minute** to the API.  
ğŸ”¹ If they exceed the limit, they get an **HTTP 429 Too Many Requests** error.  

---

### **ğŸ”¹ How to Implement Rate Limiting in Node.js using express-rate-limit package?**  

#### âœ… **Using `express-rate-limit` (for Express.js apps)**
However, this doesn't work well in distributed systems where multiple servers handle requests.

```js
const express = require("express");
const rateLimit = require("express-rate-limit");

const app = express();

// Create a rate limit rule (e.g., 5 requests per minute)
const limiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 5, // Limit each IP to 5 requests per `windowMs`
  message: "Too many requests, please try again later.",
});

// Apply rate limiting to all routes
app.use(limiter);

app.get("/", (req, res) => {
  res.send("Welcome to the API!");
});

app.listen(3000, () => console.log("Server running on port 3000"));
```
ğŸ“Œ **If a user makes more than 5 requests in a minute, they will get a `429 Too Many Requests` error.**

---

ğŸ”¹ Where is Rate Limiting Used?
âœ… Login attempts: Prevent brute-force attacks.  
âœ… API requests: Protect backend servers from overload.  
âœ… Search queries: Avoid excessive requests from bots.  
âœ… File uploads: Control how many files a user can upload in a short time.

Would you like to add rate limiting to your project? ğŸš€




### **ğŸ”¹ How to Implement Rate Limiting in Node.js using redis?**  
ğŸ’¡ Redis is the best choice for rate limiting because it is:
âœ… Fast (stores data in RAM).
âœ… Persistent across multiple servers (unlike in-memory solutions).
âœ… Efficient for counters and TTL-based expiration (perfect for rate limiting).




============================================================================================================================================================


ğŸ”¥ Redis List - Explained ğŸ”¥

A Redis List is an ordered collection of strings. if you insert number then its going to store it as a string.
It is similar to an array in other programming languages 

Redis lists are linked lists of string values. 
Redis lists are frequently used to:
1. Implement stacks and queues.
2. Build queue management for background worker systems.


âœ… Key Features of List
Ordered â€“ Elements in a list maintain the order they were added.
Allows Duplicates â€“ The same value can appear multiple times.
Efficient Operations â€“ Operations like adding/removing from the front or back are O(1) in time complexity.
Can Store up to 4 Billion Elements â€“ A single list can hold a vast amount of data.

Drabacks: 
you can't directly insert or remove elements in the middle like an array


ğŸ”¥ Use Cases of Redis Lists ğŸ”¥

3ï¸âƒ£ Recent Items (Cache)
Use Case: Storing the most recently accessed items like recent searches, viewed products, or last logins.
Example: A movie rental app tracks the last 10 movies a user viewed.
ğŸ”¹ Example Commands
```
LPUSH recent_movies "Inception" "Avatar" "Interstellar"
LTRIM recent_movies 0 9  # Keep only the last 10 movies
```


6ï¸âƒ£ Notifications & Alerts
Use Case: Storing real-time notifications for users.
Example: A notification system where users receive alerts when they get new messages, likes, or comments.
ğŸ”¹ Example Commands
```
LPUSH user_notifications "New message from Alice" "John liked your post"
LTRIM user_notifications 0 9  # Keep only the last 10 notifications
```


2ï¸âƒ£ Activity Feeds / Timelines
Use Case: Social media feeds, news feeds, or chat messages can be stored as Lists.
ğŸ”¹ Example Commands
Each user has a List storing their timeline posts.
New posts are added to the left (LPUSH), and older posts are fetched using LRANGE.
LPUSH user_feed "Post 1" "Post 2" "Post 3"
LRANGE user_feed 0 4  # Fetch the latest 5 posts

5ï¸âƒ£ Chat Applications
Use Case: Storing messages in a chat application where messages are ordered and fetched in sequence.
Example: A WhatsApp-like chat where messages are stored per chat room.
ğŸ”¹ Example Commands
```
LPUSH chat_room1 "Hello!" "How are you?" "Good morning!"
LRANGE chat_room1 0 9  # Get the last 10 messages
```


4ï¸âƒ£ Log Storage & Processing
Use Case: Storing real-time logs or event data for analytics, debugging, or monitoring.
Example: A web server logs requests into a Redis List.
ğŸ”¹ Example Commands
```
LPUSH server_logs "User 1 accessed /home"
LPUSH server_logs "User 2 accessed /profile"
LRANGE server_logs 0 4  # Fetch the last 5 logs
```


9ï¸âƒ£ Message Queues (Task Queues)
Use Case: Redis Lists are commonly used to implement queues for task processing.
Example:
Producers add tasks to the list using LPUSH or RPUSH.
Consumers process tasks using LPOP or RPOP.
ğŸ”¹ Example Commands
```
RPUSH task_queue "Task 1" "Task 2" "Task 3"  # Add tasks
LPOP task_queue  # Process (remove) the first task
```





ğŸ¯ Basic Commands:

0. To see all keys:
redis> keys *        or       // If you have a large dataset, KEYS * can slow down your Redis server
redis> scan 0                 // this will not block redis server.
redis> KEYS user:*            // all users will displayed


0.1 Check type of key
redis> TYPE myKey 
> string

0.2 Retrieve Data Based on Type

ğŸ“Œ For Strings:  
redis> GET mystring
> "Adesh"

ğŸ“Œ For Lists:
redis> LRANGE fruits 0 -1

ğŸ“Œ For Hashes:
redis> HGETALL myhash

ğŸ“Œ For Sets:
redis> SMEMBERS myset

ğŸ“Œ For Sorted Sets:
redis> ZRANGE myzset 0 -1 WITHSCORES

4ï¸âƒ£ Check Key Expiry:
redis> TTL myKey
âœ… Returns the remaining time before the key expires.
(-1 means no expiration, -2 means the key doesnâ€™t exist.)


ğŸ’€ delete all data in Redis:
redis> FLUSHALL
âš ï¸ This will delete all data in Redis, so use with caution! ğŸ˜±


1. Display all items of List:
redis> LRANGE fruits 0 -1

2. LPUSH adds a new element to the head of a list; 
redis>LPUSH fruits Apple

add more than two items at once:
redis> LPUSH nums 10, 20, 30

3. RPUSH adds to the tail.
redis>RPUSH fruits Banana

4. LPOP removes and returns an element from the head of a list
redis> LPOP fruits

5. RPOP does the same but from the tails of a list.
redis> RPOP fruits

6. length of list: 
redis> LLEN fruits
> 3

7. delete a whole list
redis> DEL nums

8. LTRIM â€“ Keep a Specific Range of Elements (Remove Others)
redis> LPUSH nums 10 20 30 40 40   // remove 10 and 40
redis> LTRIM nums 1 3
redis> LRANGE nums 0 -1
> 20 30 40
âœ… Keeps only the elements in the specified range and removes the rest.







============================================================================================================================================================




ğŸ”¥ Redis Sets - Explained ğŸ”¥


A Set in Redis is an unordered collection of unique elements. Unlike Lists, Sets do not allow duplicate values.


âœ… Key Features of Sets
1ï¸âƒ£ Unordered â€“ Elements in a Set have no specific order.
2ï¸âƒ£ Unique Elements â€“ No duplicates allowed.
3ï¸âƒ£ Fast Operations â€“ O(1) time complexity for adding, removing, and checking membership.
4ï¸âƒ£ Set Operations â€“ Supports mathematical set operations like union, intersection, and difference.
5ï¸âƒ£ Efficient Membership Checking â€“ Use SISMEMBER to check if an element exists.


ğŸ¯ Use Cases of Redis Sets
Unique User Tracking (e.g., unique visitors on a website)
Tagging System (e.g., associating tags with items)
Social Networks (e.g., mutual friends using SINTER)
Real-Time Leaderboards (e.g., storing unique player IDs)


ğŸ¯ Basic Commands:

1. Add Elements to a Set
-> 
redis> SADD ip 1
redis> SADD ip 2
redis> SADD ip 3
redis> SMEMBERS  ip
1) "1"
2) "2"
3) "3"

-> 
redis> SADD fruits "apple" "banana" "cherry"


2. View All Elements in a Set
redis> SMEMBERS fruits
âœ… Retrieves all elements in myset.


3. Check if an Element Exists
redis> SISMEMBER myset "apple"
âœ… Returns 1 if "apple" exists, otherwise 0.


4. Remove an Element from a Set
redis> SREM myset "banana"
âœ… Removes "banana" from myset.


5. Get the Number of Elements in a Set
redis> SCARD fruits
âœ… Returns the total count of elements in fruits.


6. Get a Random Element
redis> SRANDMEMBER myset
âœ… Returns a random element from myset without removing it.


7. Remove and Return a Random Element
redis> SPOP fruits
âœ… Removes and returns a random element.


8. Find Common Elements (Intersection)
redis> SADD set1 10 20 30
redis> SADD set2 10 20 40
redis> SINTER set1 set2
> 10 20
âœ… Returns elements that exist in both set1 and set2.


9. Find All Unique Elements (Union)
redis> SADD set1 10 20 30
redis> SADD set2 10 20 40
redis> SUNION set1 set2   
> 10 20 30 40
âœ… Returns all unique elements from set1 and set2.


10. Find Elements in set1 but Not in set2
redis> SADD set1 10 20 30
redis> SADD set2 10 20 40
redis> SDIFF set1 set2 
> 30
âœ… Returns elements only in set1, but not in set2.


11. ğŸ—‘ï¸ Delete a Set
redis> DEL set1
âœ… Deletes myset from Redis.



============================================================================================================================================================




ğŸ”¥ Redis Hashes (HashMaps) Explained ğŸ”¥

A Redis Hash (similar to a HashMap in programming) is a key-value store where each key contains a map of field-value pairs.

Think of it like a mini JSON object stored in Redis!
Used to store structured data, like user profiles, product details, or session data.

ğŸ¯ Features of Redis Hashes
âœ… Compact Storage â†’ Uses less memory than storing individual keys.
âœ… Efficient Access â†’ Retrieve, update, and delete specific fields without affecting the entire object.
âœ… Atomic Operations â†’ Supports atomic field modifications.
âœ… Optimized for Small Objects â†’ Best for storing structured data with fewer than 100 fields.

âš¡ Use Cases for Redis Hashes
âœ… User Profiles â†’ Store user data like name, email, age, and preferences.
âœ… Session Storage â†’ Save temporary user session details (cart items, authentication tokens).
âœ… Product Catalog â†’ Store product details like price, stock, and description.
âœ… Leaderboard / Scores â†’ Maintain scores of players in a game.
âœ… Configuration Storage â†’ Save system configurations dynamically.


âš ï¸ Drawbacks of Redis Hashes
âŒ Not Ideal for Large Objects â†’ If a hash has too many fields, it may use more memory than separate keys.
âŒ No Nested Structures â†’ Unlike JSON, Redis Hashes donâ€™t support nesting.
âŒ Limited Field Operations â†’ You can't apply operations like sorting directly on hash fields.


example: 

const profile = await redis.hSet(
   "user:1",
   {
      name: "Adesh",
      age: 22,
      email: "adejad1234@gmail.com"
   }
)


ğŸ›  Basic Commands & Examples

ğŸ”¹ 1ï¸âƒ£ Create a Hash
redis> HSET user:1 name "Adesh" age 25 email "adejad1234@gmail.com"
ğŸ‘‰ Creates a user profile with name, age, and email.

ğŸ”¹ 2ï¸âƒ£ Get a Single Field
redis> HGET user:1 name
> Adesh

ğŸ”¹ 3ï¸âƒ£ Get All Fields in a Hash
redis> HGETALL user:1
1) "name"
2) "Adesh"
3) "age"
4) "25"
5) "email"
6) "adejad1234@gmail.com"


ğŸ”¹ 4ï¸âƒ£ Update a Field
redis> HSET user:1 age 24


ğŸ”¹ 5ï¸âƒ£ Check if a Field Exists
redis> HEXISTS user:1 email
# Output: 1 (true) if exists, 0 if not


ğŸ”¹ 6ï¸âƒ£ Increment a Numeric Field
redis> HINCRBY user:1 age 1 
ğŸ‘‰ Increments Aliceâ€™s age from 26 â†’ 27.


ğŸ”¹ 7ï¸âƒ£ Delete a Specific Field
redis> HDEL user:1 email
ğŸ‘‰ Removes only the email field, but the hash remains.


ğŸ”¹ 8ï¸âƒ£ Delete an Entire Hash
redis> DEL user:1





============================================================================================================================================================


ğŸ”¥ Redis Sorted Sets (ZSETs) Explained ğŸ”¥


ğŸ‘‰ A Redis Sorted Set is a collection of unique elements where each element is associated with a score that determines the ordering.
ğŸ‘‰ Unlike normal Sets (which are unordered), Sorted Sets maintain elements in a sorted order based on their score.
ğŸ‘‰ Think of it as a ranking system, where the score defines the position of an element


ğŸ¯ Features of Redis Sorted Sets
âœ… Sorted Automatically â†’ Elements are always kept in ascending order of scores.
âœ… Fast Access â†’ Get elements by rank, score, or range in O(log N) time.
âœ… No Duplicates â†’ Each element is unique but can have different scores.
âœ… Efficient for Leaderboards â†’ Quickly get top-ranking elements.



âš¡ Use Cases for Redis Sorted Sets
âœ… Leaderboards & Rankings â†’ Keep track of high scores in games.
âœ… Time-based Queues â†’ Store events with timestamps for priority processing.
âœ… Rate Limiting â†’ Implement rate limiting with expiration timestamps.
âœ… Analytics & Statistics â†’ Track most popular products or frequently accessed items.
âœ… Stock Market / Real-time Data â†’ Store and sort stock prices dynamically.


âš ï¸ Drawbacks of Redis Sorted Sets
âŒ More Memory Usage â†’ Since each element has a score, it takes more space than a normal set.
âŒ Write Performance Overhead â†’ Adding elements requires maintaining the sorted order, so it's slower than simple sets.
âŒ Not Suitable for Large Datasets â†’ For massive datasets, indexing might slow down performance.


ğŸš€ When to Use Redis Sorted Sets?
âœ… When you need real-time ranking systems.
âœ… When sorting is required without additional computation.
âœ… When retrieving top/bottom N elements efficiently.



ğŸ›  Basic Commands & Examples

ğŸ”¹ 1ï¸âƒ£ Add Elements to a Sorted Set

redis> ZADD players 1 Adesh
redis> ZADD players 2 Akshay
redis> ZADD players 3 Manoj
ğŸ‘‰ Adds Adesh, Akshay, and Manoj to the players with respective scores ( 1, 2, 3) .


ğŸ”¹ 2ï¸âƒ£ Retrieve All Elements (Sorted by Score)
redis> ZRANGE players 0 -1
1) "Adesh"
2) "Akshay"   
3) "Manoj"

redis> ZRANGE players 0 -1 WITHSCORES
1) "Adesh"
2) "1"
3) "Akshay"
4) "2"
5) "Manoj"
6) "3"
ğŸ‘‰ Retrieves all elements sorted in ascending order of scores.


ğŸ”¹ 3ï¸âƒ£ Get Elements in Descending Order
redis> ZREVRANGE players 0 -1 WITHSCORES
1) "Manoj"
2) "3"
3) "Akshay"
4) "2"
5) "Adesh"
6) "1"
ğŸ‘‰ Retrieves elements sorted in descending order.


ğŸ”¹ 4ï¸âƒ£ Get the Rank of an Element
redis> ZSCORE players Adesh
"1"
redis> ZRANK players Adesh
(integer) 0
redis> ZRANK players Akshay
(integer) 1
redis> ZRANK players Manoj
(integer) 2
ğŸ‘‰ Returns Charlieâ€™s rank (0-based index) in ascending order.

ğŸ”¹ 5ï¸âƒ£ Get the Score of an Element
redis> ZSCORE players Adesh  // "Adesh" !== "adesh  case sensitive
"1"
ğŸ‘‰ Retrieves Alice's score.

ğŸ”¹ 6ï¸âƒ£ Increment an Elementâ€™s Score
redis> ZINCRBY players 50 "Alice"
ğŸ‘‰ Increases Aliceâ€™s score by 50 (now 150).


ğŸ”¹ 7ï¸âƒ£ Remove an Element
redis> ZREM players Manoj
ğŸ‘‰ Removes Manoj from the players.


ğŸ”¹ 8ï¸âƒ£ Get Top N Elements (Highest Scores)
redis> ZREVRANGE players 0 3 WITHSCORES
ğŸ‘‰ Retrieves top 3 players.





============================================================================================================================================================




ğŸ”¥ Redis Streams Explained ğŸ”¥
âœ… What is Redis Streams?
Redis Streams is a high-performance data structure that enables message queuing, real-time event processing, and data storage. 
It's similar to Kafka or RabbitMQ, but built inside Redis.
.

ğŸ’¡ Think of it as a log-based message broker, where producers add messages, and consumers read them asynchronously.


ğŸ¯ Key Features of Redis Streams
âœ… Persistent Message Storage â†’ Unlike Pub/Sub, Redis Streams retains messages until explicitly deleted.
âœ… Consumer Groups â†’ Supports multiple consumers to process messages efficiently.
âœ… Reliable Messaging â†’ Messages wonâ€™t be lost if consumers go offline.
âœ… Ordered Log Format â†’ Messages are stored in insertion order.
âœ… Automatic Acknowledgment â†’ Consumers can acknowledge messages after processing.
âœ… Supports Range Queries â†’ Fetch messages within a specific time range.

âš¡ Use Cases for Redis Streams
âœ… Real-time Analytics â†’ Track logs, events, or user actions.
âœ… Message Queuing â†’ Like Kafka, RabbitMQ, but built into Redis.
âœ… IoT & Sensor Data â†’ Store and process time-series data efficiently.
âœ… Event-driven Architectures â†’ Microservices communicate using streams.
âœ… Chat & Notifications â†’ Handle real-time messages.
âœ… Rate Limiting & Logging â†’ Log API requests for monitoring.

âš ï¸ Drawbacks of Redis Streams
âŒ Higher Memory Usage â†’ Stores messages persistently, consuming more RAM.
âŒ No Built-in Message Deduplication â†’ Unlike Kafka, it doesnâ€™t prevent duplicate processing.
âŒ More Complexity â†’ Requires consumer groups for load balancing.

ğŸš€ When to Use Redis Streams?
âœ… When you need persistent event storage.
âœ… When multiple consumers should process different parts of a stream.
âœ… When real-time message queuing is required.


ğŸ›  Basic Redis Stream Commands & Examples
ğŸ”¹ 1ï¸âƒ£ Create & Add Messages to a Stream
sh
Copy
Edit
XADD mystream * name "Alice" age 25 city "New York"
XADD mystream * name "Bob" age 30 city "Los Angeles"
ğŸ‘‰ Adds Alice and Bob to the stream mystream.
ğŸ‘‰ * automatically generates a unique ID for each entry.

ğŸ”¹ 2ï¸âƒ£ Read Messages from a Stream
sh
Copy
Edit
XRANGE mystream - +
ğŸ‘‰ Reads all messages in the stream.

Output:

pgsql
Copy
Edit
1) "1710670932843-0"  // Unique ID (timestamp-sequence)
   2) "name" "Alice"
   3) "age" "25"
   4) "city" "New York"
2) "1710670932844-0"
   2) "name" "Bob"
   3) "age" "30"
   4) "city" "Los Angeles"
ğŸ”¹ 3ï¸âƒ£ Read Only New Messages (Blocking Read)
sh
Copy
Edit
XREAD BLOCK 5000 STREAMS mystream $
ğŸ‘‰ Waits up to 5 seconds (5000ms) for new messages.
ğŸ‘‰ $ means only read new messages (good for real-time processing).

ğŸ”¹ 4ï¸âƒ£ Read a Specific Number of Messages
sh
Copy
Edit
XREAD COUNT 2 STREAMS mystream 0
ğŸ‘‰ Fetches the first 2 messages.

ğŸ”¹ 5ï¸âƒ£ Read Messages in a Time Range
sh
Copy
Edit
XRANGE mystream 1710670932843-0 1710670932844-0
ğŸ‘‰ Retrieves messages between two IDs.

ğŸ”¹ 6ï¸âƒ£ Remove Old Messages (Trim Stream)
sh
Copy
Edit
XTRIM mystream MAXLEN 1000
ğŸ‘‰ Keeps only the latest 1000 messages, deleting older ones.
ğŸ‘‰ Helps prevent memory overflow.

ğŸ”¹ 7ï¸âƒ£ Create a Consumer Group (For Parallel Processing)
sh
Copy
Edit
XGROUP CREATE mystream mygroup 0 MKSTREAM
ğŸ‘‰ Creates a Consumer Group named mygroup.
ğŸ‘‰ Consumers in this group share workload.

ğŸ”¹ 8ï¸âƒ£ Add Consumers to the Group
sh
Copy
Edit
XREADGROUP GROUP mygroup Alice COUNT 1 STREAMS mystream >
ğŸ‘‰ Consumer Alice reads one message at a time from mystream.

ğŸ”¹ 9ï¸âƒ£ Acknowledge a Processed Message
sh
Copy
Edit
XACK mystream mygroup 1710670932843-0
ğŸ‘‰ Marks message 1710670932843-0 as processed.

ğŸ”¹ ğŸ”Ÿ Delete a Message from the Stream
sh
Copy
Edit
XDEL mystream 1710670932843-0
ğŸ‘‰ Removes the message with ID 1710670932843-0.


























































