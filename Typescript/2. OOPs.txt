1. classes
2. Constructors
3. Properties and methods
4. Access control keywords
5. Getter and Setter 
6. Static members
7. Index Signature
8. Inheritance
9. Polymorphism 
10. Abstract classes
11. Interfaces



JavaScript and TypeScript both support Object-Oriented Programming (OOP) and Functional Programming (FP) paradigms.




classes in Typescript: 
---------------------

class Account {
    id: number;
    owner: string;
    balance: number;

    constructor(id: number, owner: string, balance: number){
        this.id = id;
        this.owner = owner;
        this.balance = balance;
    }

    deposit (amount: number): void {
        if(amount <= 0){
            throw new Error("Invalid Amout");
        }
        this.balance += amount;
    }
}



instanceof operator: 
-------------------
console.log(account instanceof Account);  // return true



Readonly and optional properties: 
---------------------------------

-> In typescript we have modifiers that we can applied to properties.
code: 
class Account {
    readonly id: number;  <-------- Readonly, can't change
    owner: string;
    balance: number;
    nickName?: string;  <------------ Optional

    constructor(id: number, owner: string, balance: number){  <-------- No need to add nickName here.
        this.id = id;
        this.owner = owner;
        this.balance = balance;
    }

    deposit(amout: number){
        this.balance = amout;
    }
}




Access Control Keyword:
-----------------------

1. public   : all properties are pulic by default.
2. private : use underscore(_) before name of property(naming convention). ex: private _balance: number.
3. protected : When a class member is marked as protected, it can be accessed within the class itself 
and by any subclasses (derived classes) that extend the class. 
However, it cannot be accessed from outside the class or its subclasses.

code: 
class Animal {
    protected name: string;

    constructor(name: string) {
        this.name = name;
    }

    protected displayName(): void {
        console.log(`Animal name: ${this.name}`);
    }
}

class Dog extends Animal {
    private breed: string;

    constructor(name: string, breed: string) {
        super(name);
        this.breed = breed;
    }

    public displayInfo(): void {
        // Accessing protected member from the superclass
        console.log(`Dog name: ${this.name}, Breed: ${this.breed}`);
        this.displayName(); // Accessing protected method from the superclass
    }
}

const myDog = new Dog("Buddy", "Golden Retriever");
myDog.displayInfo(); // Works fine

// The following lines would cause errors because `name` and `displayName` are protected:
// console.log(myDog.name); // Error: Property 'name' is protected and only accessible within class 'Animal' and its subclasses.
// myDog.displayName(); // Error: Property 'displayName' is protected and only accessible within class 'Animal' and its subclasses.




parameter properties: 
---------------------
Old Code:
class Account {
    readonly id: number;
    owner: string;
    private _balance: number;
    nickName?: string;

    constructor(id: number, owner: string, _balance: number){
        this.id = id;
        this.owner = owner;
        this._balance = _balance;
    }
}

code using parameter properties:
class Account {
    nickName?: string;

    // we initialize propertiesd in one go.
    constructor(public readonly id: number, public owner: string, private _balance: number){  
        this.id = id;
        this.owner = owner;
        this._balance = _balance;
    }

}




Getter and Setter: 
------------------

-> getter is a method we used inside a class to get the value of a property.
-> setter to set value of a filed.
class Account {
    constructor(public readonly id: number, public owner: string, private _balance: number){
        this.id = id;
        this.owner = owner;
        this._balance = _balance;
    }

    get balance (): number {
        return this._balance;
    }

    set balance(value: number){
        if(value <= 0) throw new Error("Invalid value");
        this._balance = value;
    }
} 

let account = new Account(101, "Adesh", 100000);

account.balance = 12;
console.log(account.balance);






Index signaure: 
--------------

-> In js we can add properties in object dynamically but in ts we can't so we have index signature, with help 
of this we can do this.
-> An index signature in TypeScript allows you to define flexible object types where you may not know all 
property names in advance.

code 1: 
type User = {
    [name: string]: string;  // name is "property name" and its type is string aswell as its value also have same type
}
const user: User = {}
user["name"] = 'Adesh';
user["age"] = "25";
console.log(user);


code 2: 
type User = {
    id: number;
    name: string;
    [name: string]: string | number;
}
const user: User = {
    id: 101,
    name: "Adesh"
}
user["city"]= "Pune";
user["pincode"] = 411047;
console.log(user);




Static Members:
----------------

=> In TypeScript, static members belong to the class itself, not to instances of the class. 
=> This means you can access them without creating an object of the class.
=> Static properties belong to the class.

1️⃣ Defining a Static Property & Method:
code:
class User {
  static role = "Admin"; // Static property

  static getRole() { // Static method
    return `User role is ${this.role}`;
  }
}

console.log(User.role); // ✅ "Admin"
console.log(User.getRole()); // ✅ "User role is Admin"

const user1 = new User();
console.log(user1.role); // ❌ Error: Property 'role' does not exist on type 'User'


code : 
class Counter {
    private static _count = 0;

    static increment() {
        this._count++;
        console.log(`Counter: ${this._count}`);
    }
    
    decrement() {
        Counter._count--;
        console.log(`Counter: ${Counter._count}`);
    }

    get count (): number {
        return Counter._count;
    }
}

let c = new Counter();
Counter.increment();
Counter.increment();
Counter.increment();

c.decrement()



Inheritance in TypeScript:
--------------------------

Inheritance allows a class to extend another class, reusing properties and methods while enabling modifications.

code: 
class Animal {
    public name: string;

    constructor(name: string){
        this.name = name;
    }

    public displayName(): void{
        console.log(`Animal name: ${this.name}`);
    }
}

class Dog extends Animal {
    public breed: string;

    constructor(name: string, breed: string){
        super(name);
        this.breed = breed;
    }

    public displayInfo(): void {
        console.log(`Dog Name: ${this.name}, Breed: ${this.breed}`);
        this.displayName();
    }
}

let myDog = new Dog("Tom", "Golden Retriever");

myDog.displayInfo();


2️⃣ Method Overriding:

Method Overriding occurs when a subclass provides a specific implementation of a method that is already defined 
in its superclass. 
The overridden method in the subclass must have the same name, return type, and parameters as the method in the 
parent class.

code 1: 
class Parent {
    display():void {
        console.log("parent");
    }
}

class Child extends Parent {
    override display():void {
        console.log("child");
    }
}

let c = new Child();
c.display()


code 2:
class Employee {
  calculateSalary() {
    return 50000;
  }
}

class Manager extends Employee {
  calculateSalary() {
    return super.calculateSalary() + 20000; // Adding a bonus
  }
}

const manager = new Manager();
console.log(manager.calculateSalary()); // ✅ 70000



4️⃣ Overriding with Different Access Modifiers
In TypeScript, when overriding methods, you can:

Increase accessibility (e.g., protected → public ✅)
Cannot reduce accessibility (e.g., public → private ❌)
code:
class Animal {
  protected speak() { // Protected method
    return "Animal makes a sound";
  }
}

class Dog extends Animal {
  public speak() { // Changing protected → public ✅ Allowed
    return "Dog barks";
  }
}

const dog = new Dog();
console.log(dog.speak()); // ✅ "Dog barks"




Polymorphism: 
-------------

-> Polymorphism means "many forms" and allows one interface (or method) to be used in multiple ways. 
-> It enables different classes to implement the same method in different ways, promoting code reusability and flexibility.


1️⃣ Method Overriding (Runtime Polymorphism)
When a child class provides a specific implementation for a method already defined in its parent class.
code:
class Animal {
  makeSound(): string {
    return "Some generic sound";
  }
}

class Dog extends Animal {
  makeSound(): string { // Overriding parent method
    return "Bark!";
  }
}

class Cat extends Animal {
  makeSound(): string { // Overriding parent method
    return "Meow!";
  }
}

const animals: Animal[] = [new Dog(), new Cat()];

animals.forEach(animal => console.log(animal.makeSound()));


2️⃣ Method Overloading (Compile-Time Polymorphism):

-> Method overloading means defining multiple methods with the same name but different parameter types.
-> The correct method to be called is determined at "compile time" based on the number and types of arguments passed to the method.

1. Define Multiple Method Signatures:
You can define multiple method signatures for the same method name. These signatures describe the different ways the method can be called.

2. Implement the Method
After defining the overloaded signatures, you provide a "single implementation" of the method that can handle all the different cases.

code: 
class Calculator {
    // Overload signatures
    add(a: number, b: number): number;
    add(a: string, b: string): string;
    add(a: number, b: string): string;
    add(a: string, b: number): string;

    // Implementation
    add(a: number | string, b: number | string): number | string {
        if (typeof a === 'number' && typeof b === 'number') {
            return a + b; // Numeric addition
        } else {
            return a.toString() + b.toString(); // String concatenation
        }
    }
}

const calc = new Calculator();

console.log(calc.add(1, 2)); // Output: 3 (number)
console.log(calc.add("Hello, ", "World!")); // Output: "Hello, World!" (string)
console.log(calc.add(1, " is the loneliest number")); // Output: "1 is the loneliest number" (string)
console.log(calc.add("The answer is ", 42)); // Output: "The answer is 42" (string)


3️⃣ Polymorphism with Interfaces:
Different classes can implement the same interface in their own way.
code: 
interface Shape {
  getArea(): number;
}

class Circle implements Shape {
  constructor(private radius: number) {}
  getArea(): number {
    return Math.PI * this.radius ** 2;
  }
}

class Rectangle implements Shape {
  constructor(private width: number, private height: number) {}
  getArea(): number {
    return this.width * this.height;
  }
}

const shapes: Shape[] = [new Circle(5), new Rectangle(4, 6)];

shapes.forEach(shape => console.log(shape.getArea()));
// ✅ Output: 78.54, 24





Abstract Classes and Methods in TypeScript:
-------------------------------------------

Abstract classes and abstract methods are key features in TypeScript and object-oriented programming in general that allow you to define a blueprint for other classes. 
They cannot be instantiated directly but can be extended by other classes. 
Abstract methods are methods that must be implemented by any subclass that extends the abstract class.


Key Concepts:

1. Abstract Class:
-> A class that cannot be instantiated directly.
ex: const animal = new Animal(); // ❌ Error: Cannot create an instance of an abstract class.
-> It can contain both abstract methods (methods without implementation) and concrete methods (methods with implementation).
-> Used as a base class for other classes
-> Abstract classes are useful when you want to define a common structure or behavior for a group of related classes.


2. Abstract Method:
-> A method declared in an abstract class but without an implementation.
-> Must be implemented by any subclass that extends the abstract class.
-> Any subclass that extends an abstract class "must" implement all its abstract methods.



3. Concrete Method:
-> A method in an abstract class that has an implementation.
-> Can be inherited and used directly by subclasses.
-> Subclasses inherit concrete methods from the abstract class and can use them directly or override them.


When to Use Abstract Classes:
1. When you want to provide a common base class with shared behavior and structure.
2. When you need to enforce that subclasses implement certain methods (abstract methods).
3. When you want to provide default implementations for some methods (concrete methods).




ex: 

abstract class Shape {
    abstract calculateArea(): number;

    displayArea(): void {
        console.log(`Area: ${this.calculateArea()}`);
    }
}

class Circle extends Shape {
    constructor(private radius: number) {
        super();
    }

    calculateArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}

class Rectangle extends Shape {
    constructor(private width: number, private height: number) {
        super();
    }

    calculateArea(): number {
        return this.width * this.height;
    }
}

const circle = new Circle(5);
circle.displayArea(); // Output: Area: 78.53981633974483

const rectangle = new Rectangle(4, 6);
rectangle.displayArea(); // Output: Area: 24