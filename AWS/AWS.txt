https://eu-north-1.console.aws.amazon.com/console/home?region=eu-north-1




AWS needs to verify your payment method by charging a small refundable amount (like â‚¹2 or $1), and SBI blocks international or online transactions by default unless you enable international or online usage for your card.

âœ… Through SBI YONO App
Open the YONO SBI app.
Go to "Services" > "ATM/Debit Card Services".
Select "Manage Card".
Choose your active debit card.
Enable:
International usage
Online (E-commerce) transactions
Set a daily limit (â‚¹100 or more should be fine for AWS verification).


âœ… Through SBI Net Banking
Log in to onlinesbi.com
Go to e-Services > ATM Card Services > ATM Card Limit/Channel/Usage Change
Select your card and enable:
E-commerce (CNP)
International usage (if you're using a global site like AWS)
Set transaction limits.


âš ï¸ After enabling it:
Wait 5â€“10 minutes and try adding the card again on the AWS billing page. Make sure:
You're entering correct CVV, expiry date, and your name exactly as on the card.
You have some balance in the account (â‚¹100â€“â‚¹200 just to be safe).




â­ Cloud Computing: 
-------------------

Cloud computing is the delivery of computing services (like storage, servers, databases, networking, software, analytics, and more) 
over the internet (â€œthe cloudâ€) instead of your local computer or data center.


These services are provided by cloud providers like:
----------------------------------------------------
Amazon Web Services (AWS)
Microsoft Azure
Google Cloud Platform (GCP)


ðŸ”´ What Happens If We Donâ€™t Use Cloud Computing?
------------------------------------------------

If we don't use cloud computing then you have to manage all the services like hardware, software, and networks by yourself.
Without cloud computing, everything becomes slower, more expensive, and harder to manage â€” especially as your business or 
application grows.


ðŸš« 1. High Upfront Costs
You must buy servers, networking equipment, and storage.
Also need to pay for power, cooling systems, and physical space (like a data center or server room).


ðŸ› ï¸ 2. Complex Maintenance
Youâ€™re responsible for installing, updating, and maintaining everything â€” hardware, operating systems, security patches, softwares, etc.
Need a team of skilled IT professionals to manage it all.


âš–ï¸ 3. Hard to Scale
If your traffic increases suddenly, you may not have enough capacity.
Scaling up means buying and setting up new hardware, which takes time and money.
If traffic drops, youâ€™re stuck with unused servers.


ðŸ” 4. Risk of Data Loss
If your server crashes, gets stolen, or suffers a fire or flood â€” your data could be lost permanently unless youâ€™ve set up backups.


ðŸ§¯ 6. Disaster Recovery is Tough
If something goes wrong (e.g., power failure, natural disaster), restoring everything takes a lot more time and effort without cloud 
backup systems.




ðŸŸ¢ Why Do We Use Cloud Computing?
---------------------------------

1. Cost-Effective
You only pay for what you use (like a utility bill).
No need to buy expensive hardware or maintain servers.


2. Scalability
Easily scale up or down your computing power depending on your needs (e.g., traffic spikes).


3. Accessibility
Access your apps and data from anywhere in the world using an internet connection.


4. Reliability
Cloud providers offer high uptime and automatic backups, reducing the risk of data loss.


5. Performance
Cloud data centers are fast, secure, and globally distributed, which improves the performance of applications.

6. Security
Cloud providers invest heavily in security features (firewalls, encryption, etc.).

7. Automatic Updates
Software and infrastructure updates happen automatically without downtime or manual work.


ðŸ‘‰ Common Use Cases:
--------------------
Hosting websites or applications
Data backup and disaster recovery
Big data analytics
Machine learning and AI
Email services (e.g., Gmail, Outlook)
Streaming services (e.g., Netflix, Spotify)


=================================================================================================================================




models
ðŸ”¥ Most Common for Beginners / Startups:
EC2 â€“ for hosting
S3 â€“ for file storage
Lambda â€“ for serverless backend
RDS or DynamoDB â€“ for database
IAM â€“ for permissions
CloudWatch â€“ for monitoring






Serverless:

-> Serverless doesnâ€™t mean there are no servers. It just means you donâ€™t have to manage the servers.
Instead of setting up, managing, and scaling servers, you only write your code, and the cloud provider (like AWS) takes care of 
the rest â€” running it, scaling it, and even shutting it down when not needed.
You only pay for what you use.
-> You pay only for the time it runs (like milliseconds or seconds).
-> Serverless is not only related to AWS, it can be found in Google, Microsoft, and many other providers. its just a service.
ðŸ› ï¸ AWS Serverless Example: AWS Lambda
Letâ€™s take the most popular serverless service from AWS: AWS Lambda


ðŸ”´ disadvnatages: ðŸ”´
1. cold start
2. Connection Pool for mongodb


â„ï¸ What is a Cold Start?
A cold start happens when AWS runs your Lambda function for the first time (or after it's been idle for a while).

AWS needs to:
Create a new container
Load your code
Initialize dependencies
This takes a little extra time â€” usually a few hundred milliseconds, but can be longer if your function has heavy dependencies.

ðŸ• When Cold Starts Happen:
First time you invoke a function
After it's idle (usually 10+ minutes) (ðŸ”¥ Warm Start )
During scaling (many new users at once)



ðŸ§  Whatâ€™s a Connection Pool?

A connection pool is a group of database connections that are kept open to be reused instead of opening a new one every time.
In traditional servers (like EC2), you open a pool once and reuse it.
In serverless, the function starts fresh each time (especially during cold starts), which can lead to too many open MongoDB connections if not managed properly.









âœ… How it works:
Letâ€™s say you want to build a function that resizes images when someone uploads a photo.

Without Serverless:
Youâ€™d have to create a server.
Keep it running all the time.
Handle scaling, updates, security, etc.

With Serverless (like AWS Lambda):
You write a function (e.g., resizeImage.js).
Upload it to AWS Lambda.
Event-Driven -> Run code on events like API calls, file uploads, database updates, etc.
Set it to trigger automatically when someone uploads an image to S3 (Amazon's storage service).
AWS runs your function only when needed and then shuts it down.
You pay only for the time it runs (like milliseconds or seconds).


â“ what actually happens when 1000 users interact with an AWS Lambda function:
------------------------------------------------------------------------------
When 1000 users call a Lambda function at the same time:
AWS automatically creates multiple instances of your function â€” like temporary copies â€” to handle all the requests in parallel.
Each request runs in its own isolated environment (like its own mini container).
You donâ€™t manage or see these copies â€” AWS handles it all behind the scenes.
Once the function finishes executing and there's no traffic, AWS shuts down those copies to save cost.


â­ one of the best parts about AWS Lambda
-> Whether you're a student, hobbyist, or working professional â€” if you're using your personal AWS account, you get:

ðŸŽ Lambda Free Tier Includes:

| --------------------- | ------------------------- |
| Free Resource         | Amount                    |
| --------------------- | ------------------------- |
| 1 million invocations | per month                 |
| 400,000 GB-seconds    | of compute time per month |
| --------------------- | ------------------------- |


ðŸŒ Other AWS Serverless Tools:

AWS Lambda â€“ Runs your code.
Amazon API Gateway â€“ For creating APIs that trigger Lambda functions.
Amazon S3 â€“ Serverless file storage.
DynamoDB â€“ Serverless NoSQL database.
EventBridge or SQS â€“ For handling events/messages


In non-serverless architecture yo have to manage everything like OS, Softeware, RAM, Storege, monitoring, security, configure
deployment, scale up/down, billing per hour: 
All this headache.
| -------------------------------- | --------------------------------------------------------------- |
| Task                             | Who handles it in EC2?                                          |
| -------------------------------- | --------------------------------------------------------------- |
| Buying physical server           | (AWS does it)                                     |
| Choosing how powerful (RAM, CPU) | âœ… **You do it**                                                 |
| Installing OS (Linux, Windows)   | âœ… **You do it**                                                 |
| Installing software, updates     | âœ… **You manage**                                                |
| Scaling (up/down)                | âœ… **You decide and configure it**                               |
| Restarting if it crashes         | âœ… **You handle it**                                             |
| Security updates, firewall rules | âœ… **You configure it**                                          |
| Monitoring usage                 | âœ… **You set it up (or use AWS tools)**                          |
| Cooling, electricity             | **AWS handles** (you donâ€™t worry about this)                  |
| Charges                          | âœ… **You pay based on time used, type of server, storage, etc.** |
| -------------------------------- | --------------------------------------------------------------- |


In serverless you just write code, thts it. AWS will automatically decide what RAM, Storage and other things based on you code.
1000 peoples invole our lambda function so 1000 * over invokation rate = monthly bill.
if you donâ€™t have customer then bill will be 0.

But in 

ðŸ†š EC2 vs Lambda (Server vs Serverless)
| --------------------- | -------------------------------------- | ------------------------------------------ |
| Feature               | **EC2 (Server-based)**                 | **Lambda (Serverless)**                    |
| --------------------- | -------------------------------------- | ------------------------------------------ |
| **Server Management** | You manage server setup, OS, updates   | No server to manage                        |
| **Execution Time**    | Runs continuously                      | Short-lived (max 15 minutes per function)  |
| **Billing**           | Pay per hour/second (while running)    | Pay **per request** and **execution time** |
| **Scalability**       | Manual or auto-scaling (you configure) | Auto-scales automatically                  |
| **Use Case**          | Long-running apps, websites, databases | Event-driven tasks, APIs, automation       |
| **Setup Time**        | Minutes to hours                       | Seconds                                    |
| **Maintenance**       | High (updates, patches, monitoring)    | Low to none                                |
| **Flexibility**       | Full control over environment          | Limited (function-based logic only)        |
| --------------------- | -------------------------------------- | ------------------------------------------ |


â“â“â“â“   if i have movify application where each endpoint like getUsers, getMovies, getGenres, should i create a lambdaa function for each route, ?

Awesome question â€” and very common when thinking about **serverless architecture** for real-world apps like your **Movify application**!

---

### âœ… **Short Answer:**

> **Yes**, in a typical serverless design, you'd **create a separate Lambda function for each route** (like `getUsers`, `getMovies`, `getGenres`), **BUT** there's another option too ðŸ‘‡

---

### ðŸ”€ **You Have Two Options:**

#### **Option 1: One Lambda per Route (Recommended for Microservices / Simple APIs)**
- Create one Lambda function **per endpoint**:
  - `GET /users` â†’ `getUsersLambda`
  - `GET /movies` â†’ `getMoviesLambda`
  - `GET /genres` â†’ `getGenresLambda`

**Pros:**
- Clean separation of concerns
- Each function is small, focused, and fast
- Easier to scale independently

**Cons:**
- More setup in AWS (each route needs to be mapped to a Lambda)
- More functions to manage

---

#### **Option 2: Single Lambda for All Routes (Monolith-style Handler)**
- Use **one Lambda** with an internal **router** (like Express or a switch statement).
- All routes handled in one function.

```js
export const handler = async (event) => {
  const { path, httpMethod } = event;

  if (path === '/users' && httpMethod === 'GET') {
    return getUsers();
  }
  if (path === '/movies' && httpMethod === 'GET') {
    return getMovies();
  }
  // more routes...
};
```

**Pros:**
- Easier to get started
- Simple deployment (just one Lambda)

**Cons:**
- Gets messy as app grows
- Harder to scale parts separately
- Bigger cold start time

---

### ðŸ§  **Best Practice:**
For a project like Movify:
- If it's a **small/medium project**, you can start with **one Lambda with routing** (Option 2).
- As it grows, **split into separate Lambdas** for performance and better scaling (Option 1).

---

### Bonus Tip: Use **API Gateway**
- Use **AWS API Gateway** to route:
  - `GET /users` â†’ Lambda A
  - `GET /movies` â†’ Lambda B
  - `GET /genres` â†’ Lambda C

---

Want a sample structure or serverless framework config for this?

============================================================================================================================================================



âš¡ What is EC2?

ðŸ‘‰ EC2 (Elastic Compute Cloud) is like renting a virtual computer (server) from Amazon.
ðŸ‘‰ You can use it to run websites, apps, databases, or anything else â€” just like a real computer. 
But instead of sitting in your room, it's in Amazon's data center.

EC2 code always run wheter there is traffice or not.

| ----------------- | --------------------------------------------------------------------------- |
| Feature           | Meaning                                                                     |
| ----------------- | --------------------------------------------------------------------------- |
| **Elastic**       | You can easily scale up/down (more or less power) anytime.                  |
| **Customizable**  | Choose OS, memory, CPU, storage, and more.                                  |
| **Remote Access** | You can connect to your EC2 machine from anywhere (like using TeamViewer).  |
| **Secure**        | You control who can access your server using key pairs and security groups. |
| ----------------- | --------------------------------------------------------------------------- |

ðŸš€ If Traffic Increases in EC2: What Happens?
âœ… If You Don't Change Anything (No Auto Scaling):
Your EC2 instance handles traffic up to its limit (CPU, RAM).
If it gets overloaded, your app might slow down or crash.
Cost stays the same (youâ€™re still paying for that one EC2 instance, 24/7).

âš™ï¸ If You Enable Auto Scaling:
AWS automatically adds more EC2 instances to handle extra traffic.
You are charged for each extra instance (per second or hour).
More traffic = more EC2s = more cost.

ðŸŸ¢ If traffic goes down, extra EC2 instances added by auto scaling will automatically shut down, and only the minimum number of 
instances will keep running.


ðŸ†š EC2 vs Lambda (Server vs Serverless)

| ---------------------- | -------------------------------- | --------------------------- |
| Feature                | EC2                              | Lambda                      |
| ---------------------- | -------------------------------- | --------------------------- |
| **You manage server?** | âœ… Yes                           | âŒ No                        |
| **Always running?**    | âœ… Often                         | âŒ Runs only when triggered  |
| **Use cases**          | Websites, DBs, long-running apps | Short tasks, APIs, triggers |
| ---------------------- | -------------------------------- | --------------------------- |


âœ… When we say â€œyou manage the serverâ€ in EC2, it means:

| -------------------------------- | --------------------------------------------------------------- |
| Task                             | Who handles it in EC2?                                          |
| -------------------------------- | --------------------------------------------------------------- |
| Buying physical server           | (AWS does it)                                     |
| Choosing how powerful (RAM, CPU) | âœ… **You do it**                                                 |
| Installing OS (Linux, Windows)   | âœ… **You do it**                                                 |
| Installing software, updates     | âœ… **You manage**                                                |
| Scaling (up/down)                | âœ… **You decide and configure it**                               |
| Restarting if it crashes         | âœ… **You handle it**                                             |
| Security updates, firewall rules | âœ… **You configure it**                                          |
| Monitoring usage                 | âœ… **You set it up (or use AWS tools)**                          |
| Cooling, electricity             | AWS handles** (you donâ€™t worry about this)                  |
| Charges                          | âœ… **You pay based on time used, type of server, storage, etc.** |
| -------------------------------- | --------------------------------------------------------------- |



ðŸ§  Think of it like this:

Imagine you need a computer to run a big project.
Instead of buying one, you rent a powerful one from AWS through EC2.
You can choose how powerful it is (RAM, CPU, storage).
You can use it for 1 hour, 1 day, or forever â€” you only pay for what you use.


ðŸ”§ What Can You Do With EC2?

Host a website or backend server
Run a database (like MySQL or MongoDB)
Deploy a React app, Node.js app, etc.
Test apps on different operating systems
Build your own gaming or streaming server


============================================================================================================================================================


What is S3 Bucket?


S3 (Simple Storage Service) is 'Amazon's cloud storage' where you can store files like images, videos, documents, backups, etc.
Bucket name should be unique globally

ðŸ”¹ What is a Bucket?
A bucket in S3 is like a container or folder where you store your files (called objects).
Each file (object) can be up to 5 TB in size
Each bucket has a unique name and is used to organize your data.


ðŸ”¸ How Many Buckets Can I Create?
By default: You can create 100 buckets per AWS account
You can request a limit increase if needed

ðŸ”¹ How Much Data Can Each Bucket Hold?
Each bucket can store unlimited data
You can upload files up to 5 TB in size
Thereâ€™s no size limit per bucket, only per file


So in short:
Bucket = folder for files
Default: 100 buckets
Each bucket = unlimited storage



âœ… Packages to Install:
```
npm install aws-sdk multer multer-s3
```

âœ… Step-by-Step Setup:
1. Create an S3 Bucket on AWS Console
Make sure it's public or has the right permissions if you want public access.

2. Set Your AWS Credentials
You can set them using environment variables or ~/.aws/credentials:
```
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
AWS_REGION=your-region
```



3. Node.js Code (Express Example);


const express = require("express");
const AWS = require("aws-sdk");
const multer = require("multer");
const multerS3 = require("multer-s3");

const app = express();

// Initialize S3
const s3 = new AWS.S3({
  region: "your-region",
  credentials: {
    accessKeyId: ....,
    secretKey: ....
  }
});


// Set up multer with S3
const upload = multer({
  storage: multerS3({
    s3: s3,
    bucket: "your-bucket-name",
    acl: "public-read",
    metadata: function (req, file, cb) {
      cb(null, { fieldName: file.fieldname });
    },
    key: function (req, file, cb) {
      cb(null, Date.now().toString() + "-" + file.originalname);
    },
  }),
});


// Create upload endpoint
app.post("/upload", upload.single("image"), (req, res) => {
  res.send({
    message: "Image uploaded successfully!",
    imageUrl: req.file.location,
  });
});


app.listen(3000, () => {
  console.log("Server is running on port 3000");
});