0:30 difference between state and props
1:25 creating a new react project with "create-react-app"
3:20 what is "create-react-app" doing. overview over default files created by it.
8:32 types of components in react
9:40 what is jsx
12:20 creating state using useState hook
14:06 normal variable vs useState variable
22:30 demo of using props
26:15 building a carousel
29:45 ways of exporting (default vs named export)
32:20 styling in react (inline inside jsx, css separate file, tailwind)
34:30 installing tailwind
51:37 getting rid of the same network calls using map inside jsx and dynamic className
59:00 what is CDN (content delivery network)
1:00:35 why use key with map
1:03:20 useEffect hook
1:09:28 react component lifecycle
1:10:55 moving hardcoded data in separate constants file



Q] Lifting State Up
When multiple components need to share the same data, the state is "lifted up" to their closest common ancestor.

The parent component manages the state and passes it down to the child components as props.





Q1] What is React & SPA?

-> React is a 'JavaScript library' created by 'Facebook' to build 'single-page applications'.
-> React allows us to 'create reusable UI components'.
-> Current version of React.JS is V18.0.0 (April 2022).

Q] Explain single page application

-> Traditional websites load a new HTML page from the server every time you click a link or request a new 
URL. This process involves a 'full page refresh', which can be slower and less interactive.

-> In SPA, we initially load just one HTML page most of the time its a Home page. Then, SPA use JavaScript 
to handle user interactions. 
-> When you click on a link or a button to navigate to a different "page" like suppose from home page to 
contact page, 
then React uses a mechanism (such as AJAX requests) to fetch the data needed for the contact page.
-> This data may include information for a new table, additional text, images, or any other content specific 
to the contact page.
-> when we talk about fetching data, we typically refer to retrieving the necessary information needed to 
update the content of the page. This data can include various types of information such as text, images, 
tables, etc. then question aries that why page is not reloaded? answer is that :-
-> React uses a router (like React Router) to manage navigation within the application.
When a user clicks on a link or interacts with the app to navigate to a different "page" (view), the router 
'intercepts the request' and prevents the default browser navigation.
This makes the user experience faster and smoother.

   - SPAs are often used for applications where user interaction is a priority, such as social media sites, 
   web-based email clients, project management tools, and online stores. They're excellent for creating 
   highly interactive and engaging web experiences.

   - SPAs introduce some challenges, like search engine optimization (SEO) difficulties (though these can be 
   mitigated with proper techniques), and initial load times can be longer since the whole application code 
   must be loaded upfront. Also, they may not work well on older web browsers.


ex. Gmail, Facebook, Twitter, Google Maps, Github, Netflix, 



Q] What are the differences between controlled and uncontrolled components?






Q0] What is the virtual DOM and why we use it? 

-> virtual DOM is a virtual representation of the real DOM is kept inside the memory and is 
synced with the real DOM by a library such as 'ReactDOM'.

Why we use: 
-> DOM manipulation is an imp part of any web application
-> The efficiency of the application gets affected when several DOM manipulations are being done
-> Most JavaScript frameworks 'update the entire DOM' even when a 'small part of the DOM changes'.
-> For example, consider a list that is being rendered inside the DOM. If one of the items in the list 
changes, the entire list gets rendered again instead of just rendering the item that was changed/updated. 
This is called 'inefficient updating'.
-> To address the problem of inefficient updating, the react team introduced the concept of virtual DOM.

working: 
-> For every DOM object(html tag), there is a corresponding virtual DOM object(copy), which has the same 
properties.
-> The main difference between the real DOM object and the virtual DOM object is that any changes in the 
virtual DOM object will not reflect on the screen directly.
-> Whenever a 'JSX element' gets rendered, 'virtual DOM object' gets updated.
-> React uses 'two virtual DOMs' to render the UI.
-> One virtual DOM is used to store the 'current state of the objects' and the other used to store the 
'previous state of the objects.'
-> Whenever the virtual DOM gets updated, react compares the two 'virtual DOMs' and gets to know  which 
'virtual DOM objects' were updated.
-> After knowing which objects were updated, react renders only those objects inside the real DOM instead of 
rendering the complete real DOM
-> This way, with the use of virtual DOM, react solves the problem of inefficient updating.





Q1] React JSX:
==============

-> JSX stands for JavaScript XML.
-> JSX is an extension of the JavaScript language, and is translated into JavaScript at runtime. 
-> JSX allows us to write HTML elements directly within the JavaScript code and place them in the DOM 
without any createElement() and/or appendChild() methods.
-> JSX converts 'HTML elements' into 'react elements'.
-> Its not compulsory to use JSX, but JSX makes it easier to write React applications.
-> Inside JSX you can write any valid 'JavaScript expression' inside curly braces { }.
-> The HTML code must be wrapped in ONE top level element. Alternatively, you can use a "fragment" to wrap 
multiple lines. This will prevent unnecessarily adding extra nodes to the DOM. A fragment looks like an 
empty HTML tag: <></>.
-> JSX follows XML rules.
-> To write HTML on multiple lines, put the HTML inside parentheses:
const myElement = (
  <ul>
    <li>Apples</li>
    <li>Bananas</li>
    <li>Cherries</li>
  </ul>
);
-> some keywords are reserved in javascript, html, css, and they are 'class', 'for' and so on. 
so these words you are not allowed to use it in JSX.
so instead of them you can use: 
class => className, for => htmlFor

-> React supports if statements, but not inside JSX.
if you want to use in JSX, you should put the if statements outside of the JSX, or you could use a ternary 
expression instead:

Without ternary: 
let text = "Goodbye";
if (x < 10) {
  text = "Hello";
}
const myElement = <h1>{text}</h1>;

with ternary: 
const x = 5;
const myElement = <h1>{(x < 10) ? "Hello" : "Goodbye"}</h1>;
const root = ReactDOM.createRoot(document.getElementById('root'));










1. How does React store state?

In React, state persistence is achieved through **closures** and the way React manages component re-renders. Let's break it down:

### 1. **Component and State Lifecycle**:
- When a component is rendered, React **creates an isolated instance** of that component.
- `useState` creates state variables that are **preserved** across re-renders.
- Even though a function component executes and "disappears" after rendering, React **remembers the state** because it manages this state **outside the component function itself**.

---

### 2. **How `useState` Works Internally**:
- When you call `useState`, React:
  - **Stores the state value** in an internal data structure (often linked to the component's "fiber" in React's reconciliation algorithm).
  - Associates this state with the specific component instance.
- On subsequent renders:
  - React **retrieves the preserved state** and reuses it during the function execution.

---

### 3. **Closure and Reference**:
- Even though function components execute and exit, the `setState` function returned by `useState` **closes over the component’s scope**.
- This **closure maintains access** to the component's preserved state, allowing it to persist between renders.

```javascript
function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```
- Here, `count` is re-evaluated on every render, but React **remembers** the previous value because `useState` preserves it behind the scenes.

---

### 4. **Why Local Variables Vanish**:
- Local variables **live only during the function's execution**.
- Once the function finishes, local variables are **garbage collected**.
- But `useState` **stores data at the component level, not inside the function’s local scope**.

---

### 5. **React’s Fiber Architecture**:
- React uses **fibers (lightweight objects)** to represent component instances.
- State and other properties are attached to these fibers, allowing React to **track and persist state** even when components re-render.

---

### In Short:
React preserves state by **managing it outside the component function** and linking it to the component instance. This design allows state to persist between re-renders, unlike local variables which are scoped to function execution.


==========================================================================================================================================================================================================================================



2. do we have lifecycle methods for functional component ?


Functional components in React **don’t have traditional lifecycle methods** like class components (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`).  

However, React provides the **`useEffect` hook** to handle side effects and lifecycle-like behavior in functional components. This makes `useEffect` a powerful replacement for lifecycle methods.

---

### How `useEffect` Replaces Lifecycle Methods:
1. **`componentDidMount` (Runs once after the component mounts):**
   ```javascript
   useEffect(() => {
     console.log("Component mounted");

     // Cleanup (equivalent to componentWillUnmount)
     return () => {
       console.log("Component unmounted");
     };
   }, []);  // Empty dependency array - runs only once
   ```

2. **`componentDidUpdate` (Runs after every update):**
   ```javascript
   const [count, setCount] = useState(0);

   useEffect(() => {
     console.log("Component updated");
   }, [count]);  // Runs when `count` changes
   ```

3. **`componentWillUnmount` (Cleanup when component unmounts):**
   ```javascript
   useEffect(() => {
     const interval = setInterval(() => {
       console.log("Running interval");
     }, 1000);

     return () => {
       clearInterval(interval);  // Cleanup logic
       console.log("Interval cleared on unmount");
     };
   }, []);
   ```

---

### Why Use `useEffect`:
- **Consolidates multiple lifecycle phases** into one place.
- Reduces code duplication.
- Makes functional components **simpler and more readable**.

---

### Key Takeaway:
Functional components **don’t have lifecycle methods** explicitly, but the **`useEffect` hook** allows you to replicate lifecycle behavior effectively.
















🔥 React Interview Questions on Data Flow
1️⃣ Basic Questions
What is unidirectional data flow in React?
How does data flow from parent to child in React?
Can a child component modify the props it receives?
How do you pass data from a child component to a parent?
2️⃣ State Management Questions
What is the difference between props and state?
When should you lift the state up in React?
How does the Context API help in managing data flow?
What are the alternatives to prop drilling?
3️⃣ Advanced Questions
How does Redux manage state across multiple components?
Explain the difference between local state, global state, and server state.
How does React Query differ from Redux for managing data flow?
What is the purpose of useReducer, and how does it affect state updates?
4️⃣ Performance & Optimization
How does React optimize re-renders when passing props?
What are React.memo and useMemo, and how do they help with data flow?
Why should we avoid unnecessary state variables in React?
5️⃣ Real-World Scenarios
How would you structure data flow in a large-scale React application?
How do you handle data flow in a form with multiple dependent fields?
How do you sync UI state with server state in an e-commerce app?