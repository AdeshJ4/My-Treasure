1. Memo function
-> Using memo we will skip rendering a component if its props have not changed, even though you didn't pass 
any state to that component it will unnecessary rerender so we can stop it by memo function.
->  It works by memoizing the rendered output of the component and re-rendering it only if its props change
-> refer w3school example and react website ex

===================================================================================================================================================================

2. useCallback hook: 
-> The React useCallback Hook returns a "memoized callback function".
-> Every time a component re-renders, its functions get recreated. 
-> The useCallback and useMemo Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function. 
-> This allows us to isolate resource intensive functions so that they will not automatically run on every render
-> The useCallback Hook only runs when one of its dependencies update
-> refer react website ex

===================================================================================================================================================================


3. useMemo hook: 
-> The React useMemo Hook returns a "memoized value".
-> The useMemo Hook only runs when one of its dependencies update
-> The useMemo Hook can be used to keep expensive, resource intensive functions from needlessly running.
-> refer react website ex


===================================================================================================================================================================


4. Debouncing and Throttling: 

example video : https://www.meziantou.net/assets/demo-throttle.mp4?v=af81

What is Debouncing?

-> Debouncing is a technique that delays the execution of a function until the user stops performing a 
certain action/event for a specified amount of time and If new events occur within the delay period, the 
timer is reset, and the timer started from beginning.
-> For example, if you have a search bar that fetches suggestions from the backend as the user types, you 
can "debounce the function" that makes the API call, so that it only runs after the user stops typing for 
specified amount of time. This way, you can avoid making too many API calls that might overload your server 
or return irrelevant results
-> To implement debouncing in JavaScript, you can use a timer variable to track the delay period. 
You can use the setTimeout function to set a timer that will execute your function after the delay period. 
You can also use the clearTimeout function to cancel the timer if the user performs the action again before 
the delay period ends. This way, you can ensure that your function only runs once after the user stops 
performing the action.


code 1 : debounceing in search bar:
-----------------------------------
Which function is debounced?
-> The function that is being debounced is the one inside the setTimeout

const App = () => {
  const [searchQuery, setSearchQuery] = useState('');
  useEffect(() => {    
    const timer = setTimeout(() => {
      console.log(searchQuery);
    }, 3000);
    return () => clearTimeout(timer);
  }, [searchQuery]);

  const handleInputChange = (e) => {
    const value = e.target.value;
    setSearchQuery(value);
  }
  return (
    <div>
      <input type="text" value={searchQuery} onChange={handleInputChange} />
    </div>
  )
}
export default App




code 2 : debounceing in button:
-------------------------------

const App = () => {
  const timerRef = useRef(null);

  const handleClick = () => {
    clearTimeout(timerRef.current);
    timerRef.current = setTimeout(() => {
      console.log('Button Pressed');
    }, 3000); 
  };

  useEffect(() => {
    return () => clearTimeout(timerRef.current); // Cleanup on unmount
  }, []);

  return <button onClick={handleClick}>Click Me</button>;
};

Note: What Happens If We Remove "clearTimeout" from useEffect?
If the component unmounts while a timer is active, it will still try to execute console.log('Button Pressed'), possibly causing errors or unexpected behavior.

What Does "Unmounting a Component" Mean in React?
In React, unmounting means that a component is removed from the UI and React's Virtual DOM.
import React, { useState, useEffect, useRef } from "react";

const TimerComponent = () => {
  const timerRef = useRef(null);

  useEffect(() => {
    timerRef.current = setTimeout(() => {
      console.log("Timer executed");
    }, 5000);

    return () => {
      // try to comment next line
      clearTimeout(timerRef.current); // If we didn't clear the timer, it would try to execute console.log("Timer executed") even after the component was removed.
      console.log("Component Unmounted");
    };
  }, []);

  return <h3>Timer Running... Check console!</h3>;
};

export default function App() {
  const [showTimer, setShowTimer] = useState(false);

  return (
    <div>
      <button onClick={() => setShowTimer((prev) => !prev)}>
        {showTimer ? "Hide Timer" : "Show Timer"}
      </button>
      {showTimer && <TimerComponent />}
    </div>
  );
}





🚀 code 3: created a custom hook for debouncing:
---------------------------------------------
import { useEffect, useRef } from "react";

const useDebounce = (callback, delay) => {
  const timeoutRef = useRef(null); // Explicitly initialize as null

  useEffect(() => {  
    return () => timeoutRef.current && clearTimeout(timeoutRef.current);  // If "timeoutRef.current" exists (i.e., it's not null or undefined), then call clearTimeout(timeoutRef.current).
  }, []);

  return (value) => {
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => callback(value), delay);
  };
};

export default useDebounce;


You can use this custom useDebounce hook for both input fields (search box) and button clicks:

1️⃣ Using useDebounce for an Input Field (Search Box):
import React, { useState } from "react";
import useDebounce from "./useDebounce"; // Import your custom hook

const SearchBox = () => {
  const [query, setQuery] = useState("");

  const debouncedSearch = useDebounce((value) => {
    console.log("Searching for:", value);
    // Call API or update state
  }, 500); // 500ms debounce time

  const handleChange = (e) => {
    setQuery(e.target.value);
    debouncedSearch(e.target.value); // Debounced function
  };

  return (
    <input
      type="text"
      value={query}
      onChange={handleChange}
      placeholder="Search..."
    />
  );
};

export default SearchBox;


2️⃣ Using useDebounce for a Button Click

import React from "react";
import useDebounce from "./useDebounce"; // Import your custom hook

const DebouncedButton = () => {
  const debouncedClick = useDebounce(() => {
    console.log("Button clicked!");
  }, 500); // 500ms debounce time

  return <button onClick={debouncedClick}>Click Me (Debounced)</button>;
};

export default DebouncedButton;








What is Throttling?

In throttling, the function is executed at a fixed interval. Even if the triggering event occurs more frequently, the 
function is invoked according to the defined interval.
This is particularly useful for performance optimization in scenarios like scrolling or resizing.

1️⃣ When to Use Throttling?
Window resizing events
Scroll events
Button clicks (prevent spam clicking)
API calls at regular intervals

2. Use Cases

Throttling: Throttling is suitable for scenarios where you want to limit the frequency of function calls, like handling scroll events or resizing events. 
It helps avoid overloading the system with frequent updates.
Debouncing: Debouncing is ideal when you want to wait for a pause in the events before triggering a function. 
This is useful for situations like search suggestions, where you want to wait for the user to finish typing before fetching suggestions.


🚀 custom hook: 

const useThrottle = (callback, delay) => {
  const lastCallRef = useRef(0);

  return (...args) => {
    const now = new Date().getTime();
    if (now - lastCallRef.current >= delay) {
      callback(...args);
      lastCallRef.current = now;
    }
  };
};

export default useThrottle;


1️⃣ Throttling a Button Click:

const ThrottledButton = () => {
  const handleClick = useThrottle(() => {
    console.log("Button Clicked!");
  }, 1000); // Throttle to 1 second

  return <button onClick={handleClick}>Click Me (Throttled)</button>;
};

2️⃣ Throttling a Scroll Event

const ScrollLogger = () => {
  const handleScroll = useThrottle(() => {
    console.log("Scrolling...");
  }, 1000); // Log once per second

  useEffect(() => {
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll); // Cleanup on unmount
  }, []);

  return <div style={{ height: "200vh", padding: "20px" }}>Scroll Down</div>;
};

3️⃣ Throttling a Search Input:

const SearchBox = () => {
  const [query, setQuery] = useState("");

  const throttledSearch = useThrottle((value) => {
    console.log("Searching for:", value);
    // Call API or update state here
  }, 1000); // Throttle to 1 second

  const handleChange = (e) => {
    setQuery(e.target.value);
    throttledSearch(e.target.value); // Throttled function
  };

  return (
    <input
      type="text"
      value={query}
      onChange={handleChange}
      placeholder="Search..."
    />
  );
};

export default SearchBox;


============================================================================================================================================================================================================================





Lazy Load and code splitting
-----------------------------

-> Code splitting and lazy loading are techniques used in React to optimize the performance of your application by reducing the 
initial load time. 


Code Splitting:

-> Code splitting is the process of dividing/Splitting your application's code into multiple bundles/files that can be loaded on 
demand instead of combining all components into a single JavaScript file/bundle.

-> If you don't use code splitting, all components get merged into a single JavaScript file after running the npm run build command.

-> This means that when a user visits your application, they have to download the entire codebase, including pages they might not even visit.

-> However, if you use code splitting and lazy loading, users only download the pages they visit, reducing the initial load time.

-> This is especially useful for large applications, as loading everything at once can slow down the initial page load and negatively affect performance.



2. Lazy Loading

-> Lazy loading is a technique that delays the loading of non-critical resources until they are needed, ensuring that these 
chunks/compoents/imagges/pages are loaded on demand when the user requires them.
-> Lazy loading is a technique where resources (like images, components, or scripts) are loaded only when they are needed, typically 
when they come into the viewport or are about to be rendered or we navigate to them. 
This improves performance by reducing the initial load time and bandwidth usage.
In React, we use React.lazy() for lazy loading components and "Suspense" to handle the fallback UI while the component is being loaded.


Relationship between Code Splitting and Lazy Loading:
Code splitting refers to the process of breaking the app’s code into smaller bundles (chunks).
Lazy loading refers to the technique of loading these bundles on demand (when the user needs them).

1️⃣ Lazt load with Pages
------------------------

import React, { lazy, Suspense } from 'react';
import { Route, Routes } from 'react-router-dom';
import Navbar from './Components/Navbar';
import Home from './Components/Home';

const About = lazy(() => import('./Components/About'));
const Contact = lazy(() => import('./Components/Contact'));

const App = () => { 
  return (
    <div>
      <Navbar /> {/* Navbar is rendered here */}
      <Suspense fallback={<div className='loading'>Loading...</div>}>
        <Routes>
          <Route path='/' element={<Home />} />
          <Route path='/about' element={<About />} />
          <Route path='/contact' element={<Contact />} />
        </Routes>
      </Suspense>
    </div>
  );
};

export default App;





2️⃣. lazy load images : 

you can implement lazy loading using multiple ways: 

-> rendering images using an "infinite scrolling technique" can be considered a form of lazy loading.
-> Native HTML loading="lazy": The loading="lazy" attribute on the <img> tag is a native browser feature that defers loading images until they are near the viewport. 
This is a form of lazy loading, but it is not React-specific. This approach works well for images but does not involve React's lazy loading mechanisms.
code: 
Note : Open Network tab and select "Img".
import React, { useState, useEffect } from 'react';
import './App.css';
import img1 from './assets/img1.jpg';
import img2 from './assets/img2.jpg';
import img3 from './assets/img3.jpg';
import img4 from './assets/img4.jpg';
import img5 from './assets/img5.jpg';
import img6 from './assets/img6.jpg';
import img7 from './assets/img7.jpg';
import img8 from './assets/img8.jpg';
import img9 from './assets/img9.jpg';
import img10 from './assets/img10.jpg';
import img11 from './assets/img11.jpg';
import img12 from './assets/img12.jpg';
import img13 from './assets/img13.jpg';
import img14 from './assets/img14.jpg';
import img15 from './assets/img15.jpg';
import img16 from './assets/img16.jpg';
import img17 from './assets/img17.jpg';
import img18 from './assets/img18.jpg';
import img19 from './assets/img19.jpg';
import img20 from './assets/img20.jpg';
import img21 from './assets/img21.jpg';
import img22 from './assets/img22.jpg';
import img23 from './assets/img23.jpg';


const images  = [ img1, img2, img3, img4, img5, img6, img7, img8, img9, img10, img11, img12, img13, img14, img15, img16, img17, img18, img19, img20, img21, img22, img23];

const App = () => {
  return (
    <>
      <div>
        {images.map((img, index) => (
          <img key={index} src={img} alt={`Image ${index + 1}`} loading="lazy" />
        ))}
      </div>
    </>
  );
}

export default App;



What Happens When You Run npm run build (Without Code Splitting & Lazy Loading)?
--------------------------------------------------------------------------------

When you run: "npm run build" in a React project, it triggers the build process, which optimizes your application for production

1. The React application is bundled into a single minified JavaScript file (e.g., index-[hash].js).
2. CSS files are extracted and optimized.
3. Assets (images, fonts, etc.) are processed and placed in the dist/ or build/ folder.
4. Tree shaking removes unused code.
5. The index.html file is generated, linking to the bundled JS and CSS files.
6. The entire build(CRA) or dist(Vite) folder is uploaded to a web server (e.g., Netlify, Vercel, Firebase, AWS, or traditional hosting).
7. The app is now static and ready to be served to users.
8. This file contains the entire React app (since no code splitting is used).
9. The browser downloads and executes it when a user visits the site.


to build: "npm run build"
to server build locally: "npx serve -s dist"



What Happens When You Run npm run build (With Code Splitting & Lazy Loading)?
-----------------------------------------------------------------------------

1. Multiple JavaScript Files (Chunks) Are Created: 
-> Instead of one large index.js file, React splits the code into smaller chunks (e.g., main.[hash].js, About.[hash].js, Contact.[hash].js).This reduces the initial download size for users.
2. Only Essential Code Loads Initially: 
-> The homepage loads faster because only the required JavaScript files are downloaded first.
Other pages/components are lazy-loaded (downloaded when the user navigates to them).
3. Generated Files in dist/ or build/ Folder
-> The entire build/ or dist/ folder is deployed to a hosting service like Netlify, Vercel, Firebase, or AWS.
-> Since code splitting is enabled, only necessary JavaScript chunks load when needed, improving performance.
















Most Used Design Patterns in React | Learn React Design Patterns in One Video

Dipesh Malvi