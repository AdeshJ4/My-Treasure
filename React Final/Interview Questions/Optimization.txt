1. Memo function
-----------------
-> Using memo we will skip rendering a component if its props have not changed, even though you didn't pass 
any state to that component it will unnecessary rerender so we can stop it by memo function.
->  It works by memoizing the "rendered output" of the component and re-rendering it only if its props change
-> Memoization is an optimization technique used to speed up function calls by caching the results of expensive function calls and returning the cached 
result when the same inputs occur again.
-> A cache is a place where data is stored temporarily so that it can be quickly accessed the next time it’s needed.
Cache is temporary and in-memory.
Once you refresh the page or restart your app, it’s gone.
If you want to store results permanently, you’d use localStorage, a database, or a file — not cache.

-> Wrap a component in memo to get a memoized version of that component.
-> This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. 
But React may still re-render it: memoization is a performance optimization, not a guarantee.
-> refer w3school example and react website ex

==============================================================================================================================================================

2. useCallback hook: 
-> The React useCallback Hook returns a "memoized callback function".
-> Every time a component re-renders, its functions get recreated. 
-> The useCallback and useMemo Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function. 
-> This allows us to isolate resource intensive functions so that they will not automatically run on every render
-> The useCallback Hook only runs when one of its dependencies update
-> refer react website ex

===================================================================================================================================================================

3. useMemo hook: 
-> The React useMemo Hook returns a "memoized value".
-> The useMemo Hook only runs when one of its dependencies update
-> The useMemo Hook can be used to keep expensive, resource intensive functions from needlessly running.
-> refer react website ex


===================================================================================================================================================================


4. Debouncing and Throttling: 

example video : https://www.meziantou.net/assets/demo-throttle.mp4?v=af81

What is Debouncing?

-> Debouncing is a technique that delays the execution of a function until the user stops performing a 
certain action/event for a specified amount of time and If new events occur within the delay period, the 
timer is reset, and the timer started from beginning.
-> For example, if you have a search bar that fetches suggestions from the backend as the user types, you 
can "debounce the function" that makes the API call, so that it only runs after the user stops typing for 
specified amount of time. This way, you can avoid making too many API calls that might overload your server 
or return irrelevant results
-> To implement debouncing in JavaScript, you can use a timer variable to track the delay period. 
You can use the setTimeout function to set a timer that will execute your function after the delay period. 
You can also use the clearTimeout function to cancel the timer if the user performs the action again before 
the delay period ends. This way, you can ensure that your function only runs once after the user stops 
performing the action.


code 1 : debounceing in search bar:
-----------------------------------
Which function is debounced?
-> The function that is being debounced is the one inside the setTimeout

const App = () => {
  const [searchQuery, setSearchQuery] = useState('');
  useEffect(() => {    
    const timer = setTimeout(() => {
      console.log(searchQuery);
    }, 3000);
    return () => clearTimeout(timer);
  }, [searchQuery]);

  const handleInputChange = (e) => {
    const value = e.target.value;
    setSearchQuery(value);
  }
  return (
    <div>
      <input type="text" value={searchQuery} onChange={handleInputChange} />
    </div>
  )
}
export default App




code 2 : debounceing in button:
-------------------------------

const App = () => {
  const timerRef = useRef(null);

  const handleClick = () => {
    clearTimeout(timerRef.current);
    timerRef.current = setTimeout(() => {
      console.log('Button Pressed');
    }, 3000); 
  };

  useEffect(() => {
    return () => clearTimeout(timerRef.current); // Cleanup on unmount
  }, []);

  return <button onClick={handleClick}>Click Me</button>;
};

Note: What Happens If We Remove "clearTimeout" from useEffect?
If the component unmounts while a timer is active, it will still try to execute console.log('Button Pressed'), possibly causing errors or unexpected behavior.

What Does "Unmounting a Component" Mean in React?
In React, unmounting means that a component is removed from the UI and React's Virtual DOM.
import React, { useState, useEffect, useRef } from "react";

const TimerComponent = () => {
  const timerRef = useRef(null);

  useEffect(() => {
    timerRef.current = setTimeout(() => {
      console.log("Timer executed");
    }, 5000);

    return () => {
      // try to comment next line
      clearTimeout(timerRef.current); // If we didn't clear the timer, it would try to execute console.log("Timer executed") even after the component was removed.
      console.log("Component Unmounted");
    };
  }, []);

  return <h3>Timer Running... Check console!</h3>;
};

export default function App() {
  const [showTimer, setShowTimer] = useState(false);

  return (
    <div>
      <button onClick={() => setShowTimer((prev) => !prev)}>
        {showTimer ? "Hide Timer" : "Show Timer"}
      </button>
      {showTimer && <TimerComponent />}
    </div>
  );
}





🚀 code 3: created a custom hook for debouncing:
---------------------------------------------
import { useEffect, useRef } from "react";

const useDebounce = (callback, delay) => {
  const timeoutRef = useRef(null); // Explicitly initialize as null

  useEffect(() => {  
    return () => timeoutRef.current && clearTimeout(timeoutRef.current);  // If "timeoutRef.current" exists (i.e., it's not null or undefined), then call clearTimeout(timeoutRef.current).
  }, []);

  return (value) => {
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => callback(value), delay);
  };
};

export default useDebounce;


You can use this custom useDebounce hook for both input fields (search box) and button clicks:

1️⃣ Using useDebounce for an Input Field (Search Box):
import React, { useState } from "react";
import useDebounce from "./useDebounce"; // Import your custom hook

const SearchBox = () => {
  const [query, setQuery] = useState("");

  const debouncedSearch = useDebounce((value) => {
    console.log("Searching for:", value);
    // Call API or update state
  }, 500); // 500ms debounce time

  const handleChange = (e) => {
    setQuery(e.target.value);
    debouncedSearch(e.target.value); // Debounced function
  };

  return (
    <input
      type="text"
      value={query}
      onChange={handleChange}
      placeholder="Search..."
    />
  );
};

export default SearchBox;


2️⃣ Using useDebounce for a Button Click

import React from "react";
import useDebounce from "./useDebounce"; // Import your custom hook

const DebouncedButton = () => {
  const debouncedClick = useDebounce(() => {
    console.log("Button clicked!");
  }, 500); // 500ms debounce time

  return <button onClick={debouncedClick}>Click Me (Debounced)</button>;
};

export default DebouncedButton;








What is Throttling?

In throttling, the function is executed at a fixed interval. Even if the triggering event occurs more frequently, the 
function is invoked according to the defined interval.
This is particularly useful for performance optimization in scenarios like scrolling or resizing.

1️⃣ When to Use Throttling?
Window resizing events
Scroll events
Button clicks (prevent spam clicking)
API calls at regular intervals

2. Use Cases

Throttling: Throttling is suitable for scenarios where you want to limit the frequency of function calls, like handling scroll events or resizing events. 
It helps avoid overloading the system with frequent updates.
Debouncing: Debouncing is ideal when you want to wait for a pause in the events before triggering a function. 
This is useful for situations like search suggestions, where you want to wait for the user to finish typing before fetching suggestions.


🚀 custom hook: 

const useThrottle = (callback, delay) => {
  const lastCallRef = useRef(0);

  return (...args) => {
    const now = new Date().getTime();
    if (now - lastCallRef.current >= delay) {
      callback(...args);
      lastCallRef.current = now;
    }
  };
};

export default useThrottle;


1️⃣ Throttling a Button Click:

const ThrottledButton = () => {
  const handleClick = useThrottle(() => {
    console.log("Button Clicked!");
  }, 1000); // Throttle to 1 second

  return <button onClick={handleClick}>Click Me (Throttled)</button>;
};

2️⃣ Throttling a Scroll Event

const ScrollLogger = () => {
  const handleScroll = useThrottle(() => {
    console.log("Scrolling...");
  }, 1000); // Log once per second

  useEffect(() => {
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll); // Cleanup on unmount
  }, []);

  return <div style={{ height: "200vh", padding: "20px" }}>Scroll Down</div>;
};


1️⃣ throttle in resize the window.

const App = () => {

  const handlerResize = useThrottle(() => {
    console.log('called');
  }, 1000) 

  useEffect(() => {
    window.addEventListener('resize', handlerResize);

    return () => window.removeEventListener('resize', handlerResize)
  }, []);


  return (
    <div style={{ height: '10000px', backgroundColor:"dodgerblue"}}>App</div>
  )
}




3️⃣ Throttling a Search Input:

const SearchBox = () => {
  const [query, setQuery] = useState("");

  const throttledSearch = useThrottle((value) => {
    console.log("Searching for:", value);
    // Call API or update state here
  }, 1000); // Throttle to 1 second

  const handleChange = (e) => {
    setQuery(e.target.value);
    throttledSearch(e.target.value); // Throttled function
  };

  return (
    <input
      type="text"
      value={query}
      onChange={handleChange}
      placeholder="Search..."
    />
  );
};

export default SearchBox;


============================================================================================================================================================================================================================


Lazy Load and code splitting
-----------------------------

🟢 build (for production)        : "npm run build"  
🟢 run build (for production)  : "npm run preview" 

1️⃣ if you don't use code spitting then it will create three files: html, js, css.
2️⃣ if you use code spitting then it will create multiple js files but single html, css.



☀️ Bundling:
Most React apps will have their files “bundled” using tools like Webpack, Rollup or Browserify.
Bundling is the process of following imported files and merging them into a single file: a “bundle”. 
This bundle can then be included on a webpage to load an entire app at once.


🧩 What is a Bundler?
👉 A "bundler is a tool" that takes all the files in your project ( JavaScript, CSS, images, etc.) and combines (bundles) them 
into one or more optimized files that can be loaded by a web browser. 
This bundle can then be included on a webpage to load an entire app at once.
👉 Bundling is great, but as your app grows, your bundle will grow too. 
Especially if you are including large third-party libraries. 
👉 You need to keep an eye on the code you are including in your bundle so that you don’t accidentally make it so 
large that your app takes a long time to load.
👉 To avoid winding up with a large bundle, it’s good to get ahead of the problem and start “splitting” your bundle. 
Code-Splitting is a feature supported by bundlers like Webpack, Rollup and Browserify (via factor-bundle) which can 
create multiple bundles that can be dynamically loaded at runtime.


How to code-splitting into your app:

1. "import()"
The best way to introduce code-splitting into your app is through the dynamic import() syntax.
When Webpack comes across this syntax, it automatically starts code-splitting your app.
when you import functions, arrays, or compoennts using "import()" it creates a seprate file of it.


📦 Example (React + Webpack)

1. You write:
```
import App from './App';
import './styles.css';
```

2. Bundler creates:
```
// bundled.js — minified and optimized
(function(){ /* your whole app here */ })();
```

3. Then your browser just loads:
```
<script src="bundled.js"></script>
```


🧪 Why Do We Need a Bundler?
In a real-world project:

You write many small files (components, styles, modules)
Browsers can't understand import/export or JSX directly
Loading too many files is slow

A bundler solves this by:

Combining files into fewer files
Transpiling code (like JSX, ES6+)
Minifying code to reduce file size
Optimizing for fast performance

⚙️ Common Bundlers
|--------------|--------------------------------|-------------------------------------|
| Tool         | Used With                      | Notes                               |
|--------------|--------------------------------|-------------------------------------|
| **Webpack**  | React, Angular, Vue, etc.      | Very powerful, configurable         |
| **Vite**     | React, Vue, Svelte, etc.       | Super fast, uses native ES modules  |
| **Parcel**   | Zero-config setup               | Simple for beginners                |
| **esbuild**  | Next-gen bundler, lightning fast| Used internally by Vite             |
| **Rollup**   | Libraries and frameworks        | Focuses on small and optimized output|
|--------------|--------------------------------|-------------------------------------|




🟢 Code splitting:
-> Code splitting is the process of dividing/Splitting your application's code into multiple bundles/files that can be loaded on 
demand instead of combining all components into a single JavaScript file/bundle.

-> Code splitting and lazy loading are techniques used in React to optimize the performance of your application by reducing the 
initial load time. 


🧠 Why is it useful?
👉 Faster initial load ⏱️
👉 Smaller JavaScript bundles 📦
👉 Improves performance and user experience 🚀


-> If you don't use code splitting, all components get merged into a single JavaScript file after running the npm run build command.

-> This means that when a user visits your application, they have to download the entire codebase, including pages they might not even visit.

-> However, if you use code splitting and lazy loading, users only download the pages they visit, reducing the initial load time.

-> This is especially useful for large applications, as loading everything at once can slow down the initial page load and negatively affect performance.



2. Lazy Loading

-> The React.lazy function lets you render a dynamic import as a regular component
-> Lazy loading is a technique that delays the loading of non-critical resources until they are needed, ensuring that these 
chunks/compoents/imagges/pages are loaded on demand when the user requires them.
-> Lazy loading is a technique where resources (like images, components, or scripts) are loaded only when they are needed, typically 
when they come into the viewport or are about to be rendered or we navigate to them. 
This improves performance by reducing the initial load time and bandwidth usage.
In React, we use React.lazy() for lazy loading components and "Suspense" to handle the fallback UI while the component is being loaded.

🎯 If you have 500 cards, lazy loading with React.lazy() won’t help much — because it lazy-loads component code, not component 
instances. 
Meaning: React.lazy is good for large components loaded once (e.g. pages or modals), not for repeating items like 500 cards.
pagination and infinite scroll are the most common optimization techniques for rendering large datasets like 500+ cards.


🎯 lazy load a array: 
```
import React, { useState } from 'react'

const App = () => {
  const [ todosList, setTododsList ] = useState([]);

🧠 Dynamic Import (on button click)
  const handleData = () => {
    import('../utils/todos').then((module => setTododsList(module.todos)))
  }

  return (
    <div>
      <h1>About</h1>
      <button onClick={handleData}>Load Data</button>
      <ul>
        { todosList.map(todo => (<li key={todo.id}>{todo.title}</li>))}
      </ul>
    </div>
  )
}

export default App
```

todos.js: 
--------
export const todos = [
  {
    userId: 1,
    id: 1,
    title: "delectus aut autem",
    completed: false,
  },
  {
    userId: 2,
    id: 2,
    title: "quis ut nam facilis et officia qui",
    completed: false,
  },

  ....
  ,

  {
    userId: n,
    id: n,
    title: "fugiat veniam minus",
    completed: false,
  }
]

explanation: 

👉 import() Loads data on demand (saves initial bundle size)
👉 import('../utils/todos') is a dynamic import.
👉 It means: load the module only when the user clicks the button, not when the component first loads.
👉 This helps with performance and code-splitting.
👉 Once the module is loaded, .then(...) gives you access to the exported stuff in that file.
👉 You're accessing module.todos and setting that as the new state (todosList).



Relationship between Code Splitting and Lazy Loading:
Code splitting refers to the process of breaking the app’s code into smaller bundles (chunks).
Lazy loading refers to the technique of loading these bundles on demand (when the user needs them).

1️⃣ Lazt load with Pages
------------------------

import React, { lazy, Suspense } from 'react';
import { Route, Routes } from 'react-router-dom';
import Navbar from './Components/Navbar';
import Home from './Components/Home';

const About = lazy(() => waitMe(2000).then(() => import('./pages/About')));
const Contact = lazy(() => import('./Components/Contact'));

const App = () => { 
  return (
    <div>
      <Navbar /> {/* Navbar is rendered here */}
      <Suspense fallback={<div className='loading'>Loading...</div>}>
        <Routes>
          <Route path='/' element={<Home />} />
          <Route path='/about' element={<About />} />
          <Route path='/contact' element={<Contact />} />
        </Routes>
      </Suspense>
    </div>
  );
};

export default App;





2️⃣. lazy load images : 

you can implement lazy loading using multiple ways: 

-> rendering images using an "infinite scrolling technique" can be considered a form of lazy loading.
-> Native HTML loading="lazy": The loading="lazy" attribute on the <img> tag is a native browser feature that defers loading images until they are near the viewport. 
This is a form of lazy loading, but it is not React-specific. This approach works well for images but does not involve React's lazy loading mechanisms.
code: 
Note : Open Network tab and select "Img".
import React, { useState, useEffect } from 'react';
import './App.css';
import img1 from './assets/img1.jpg';
import img2 from './assets/img2.jpg';
import img3 from './assets/img3.jpg';
import img4 from './assets/img4.jpg';
import img5 from './assets/img5.jpg';
import img6 from './assets/img6.jpg';
import img7 from './assets/img7.jpg';
import img8 from './assets/img8.jpg';
import img9 from './assets/img9.jpg';
import img10 from './assets/img10.jpg';
import img11 from './assets/img11.jpg';
import img12 from './assets/img12.jpg';
import img13 from './assets/img13.jpg';
import img14 from './assets/img14.jpg';
import img15 from './assets/img15.jpg';
import img16 from './assets/img16.jpg';
import img17 from './assets/img17.jpg';
import img18 from './assets/img18.jpg';
import img19 from './assets/img19.jpg';
import img20 from './assets/img20.jpg';
import img21 from './assets/img21.jpg';
import img22 from './assets/img22.jpg';
import img23 from './assets/img23.jpg';


const images  = [ img1, img2, img3, img4, img5, img6, img7, img8, img9, img10, img11, img12, img13, img14, img15, img16, img17, img18, img19, img20, img21, img22, img23];

const App = () => {
  return (
    <>
      <div>
        {images.map((img, index) => (
          <img key={index} src={img} alt={`Image ${index + 1}`} loading="lazy" />
        ))}
      </div>
    </>
  );
}

export default App;



What Happens When You Run npm run build (Without Code Splitting & Lazy Loading)?
--------------------------------------------------------------------------------

When you run: "npm run build" in a React project, it triggers the build process, which optimizes your application for production

1. The React application is bundled into a single minified JavaScript file (e.g., index-[hash].js).
2. CSS files are extracted and optimized.
3. Assets (images, fonts, etc.) are processed and placed in the dist/ or build/ folder.
4. Tree shaking removes unused code.
5. The index.html file is generated, linking to the bundled JS and CSS files.
6. The entire build(CRA) or dist(Vite) folder is uploaded to a web server (e.g., Netlify, Vercel, Firebase, AWS, or traditional hosting).
7. The app is now static and ready to be served to users.
8. This file contains the entire React app (since no code splitting is used).
9. The browser downloads and executes it when a user visits the site.


to build: "npm run build"
to server build locally: "npx serve -s dist"



What Happens When You Run npm run build (With Code Splitting & Lazy Loading)?
-----------------------------------------------------------------------------

1. Multiple JavaScript Files (Chunks) Are Created: 
-> Instead of one large index.js file, React splits the code into smaller chunks (e.g., main.[hash].js, About.[hash].js, Contact.[hash].js).
This reduces the initial download size for users.
2. Only Essential Code Loads Initially: 
-> The homepage loads faster because only the required JavaScript files are downloaded first.
Other pages/components are lazy-loaded (downloaded when the user navigates to them).
3. Generated Files in dist/ or build/ Folder
-> The entire build/ or dist/ folder is deployed to a hosting service like Netlify, Vercel, Firebase, or AWS.
-> Since code splitting is enabled, only necessary JavaScript chunks load when needed, improving performance.



















video: 


