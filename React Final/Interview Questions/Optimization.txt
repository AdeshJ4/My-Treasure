1. Memo function
-> Using memo we will skip rendering a component if its props have not changed, even though you didn't pass any state to 
that component it will unnecessary rerender so we can stop it by memo function.
-> React.memo is a higher-order component (HOC) 
->  It works by memoizing the rendered output of the component and re-rendering it only if its props change
-> refer w3school example and react website ex



2. useCallback hook: 
-> The React useCallback Hook returns a "memoized callback function".
-> Every time a component re-renders, its functions get recreated. 
-> The useCallback and useMemo Hooks are similar. The main difference is that useMemo returns a memoized value and 
useCallback returns a memoized function. 
-> This allows us to isolate resource intensive functions so that they will not automatically run on every render
-> The useCallback Hook only runs when one of its dependencies update
-> refer react website ex



3. useMemo hook: 
-> The React useMemo Hook returns a "memoized value".
-> The useMemo Hook only runs when one of its dependencies update
-> The useMemo Hook can be used to keep expensive, resource intensive functions from needlessly running.
-> refer react website ex





































. Debouncing and Throttling: 

-> Event triggers, such as key presses, button clicks, and mouse movements, are commonly utilised in applications to initiate 
functions based on user actions. However, users have the potential to trigger these events excessively, leading to notable performance
problems within the application.
-> Most common Example you will encounter is ,while creating a search component


import React, { useState, useCallback } from "react";
import _ from "lodash";

const App = () => {
  const [query, setQuery] = useState("");
  const [searchResults, setSearchResults] = useState("");

  // Mock search function to simulate API call
  const performSearch = (query) => {
    setSearchResults(`${query}`);
  };

  // Use Lodash's debounce function
  const debouncedSearch = useCallback(_.debounce(performSearch, 500), []);

  const handleInputChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={handleInputChange}
      />

      <h1>{searchResults}</h1>
    </div>
  );
};

export default App;
