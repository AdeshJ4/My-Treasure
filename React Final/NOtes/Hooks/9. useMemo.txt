-> The React useMemo Hook returns a memoized value.
-> The useMemo Hook only runs when one of its dependencies update. This can improve performance
-> The useMemo and useCallback Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback 
returns a memoized function
-> The useMemo Hook can be used to keep expensive, resource intensive functions from needlessly running
-> We can wrap the expensive function call with useMemo. The useMemoHook accepts a second parameter to declare dependencies. 
The expensive function will only run when its dependencies have changed.

syntax: const calculation = useMemo(() => expensiveCalculation(), [count]);



import { useState } from "react";
const App = () => {
  const [count, setCount] = useState(0);
  const calculation = expensiveCalculation(count);
//const calculation = useMemo(expensiveCalculation(count), [count]);
  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
        Count: {count}
        <button onClick={increment}>+</button>
        <h2>Expensive Calculation: {calculation}</h2>
    </div>
  );
};

const expensiveCalculation = (num) => {
  console.log("Calculating...");
  for (let i = 0; i < 1000000000; i++) {
    num += 1;
  }
  return num;
};


export default App








