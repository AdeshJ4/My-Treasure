Redux: 

-> Redux Toolkit is an official package from the creators of Redux that aims to simplify the process of working with Redux, making it more efficient and developer-friendly
-> Redux is an open source javascript library and state management tool for managing and centralizing application data and to easily pass data between components.
-> Redux provides a store which makes the state inside components easier to maintain.
-> Along with stores, react-redux introduces actions and reducers which work simultaneously with stores to make the state more predictable.


Redux ToolKit (RTK): 

-> Redux Toolkit is used for writing redux code but in a more concise way. 
-> Redux Toolkit (RTK) solves problems that most of the developer’s face who used redux in a react application. 
-> RTK abstracts the basic redux code and provides us boilerplate that enable us to write redux code in less lines of code


Issues with basic Redux:

Configuring a Redux store is too complicated
Have to add a lot of packages to build a large-scale application
Redux requires too much boilerplate code which makes it cumbersome to write efficient and clean code


Reasons for preferring RTK(Redux ToolKit):

Redux ToolKit solves various issues by providing a hook-based implementation of Redux 
RTK gives the ability to write mutable state updates in the reducers.
It also eliminates the use of extra coding by providing boilerplate.
RTK also has the feature of RTK query which eliminates the use of Thunks and makes the query processing faster
It also provides automatic support for Redux Dev-tools Extension and for immer.js library which is a great tool to deal with immutable objects. 
You can also use the various predefined functions of Redux Toolkit which not only speeds up the process but also saves time.



To install RTK(Redux ToolKit) in the existing project use the command

npm install @reduxjs/toolkit
npm install react-redux



Here are some key features and components of Redux Toolkit:

1. configureStore(): 

-> A friendly abstraction over the standard Redux createStore() function.
-> configureStore is a function provided by Redux Toolkit that simplifies the process of creating a Redux store. 
-> It combines Redux-thunk, Redux DevTools Extension, and default middleware

2. createReducer();



code : 

store.js
--------
import { configureStore } from '@reduxjs/toolkit';
import customReducer from './Reducers';

const store = configureStore({
/ *
"reducer" is a object which contain multiple reducers. customReducer is a function in a file having a name "Reducers.js" where all reducers are defined.
*/
    reducer: {
    	custom: customReducer,
   },
});


Reducers.js
-----------




src/
  ├── components/
  ├── pages/
  ├── features/
  │   ├── user/
  │   │   ├── userReducers.js
  │   │   ├── userActions.js
  │   │   └── ...
  │   ├── post/
  │   │   ├── postReducers.js
  │   │   ├── postActions.js
  │   │   └── ...
  └── redux/
      └── store.js




src/
  ├── components/
  ├── pages/
  ├── redux/
  │   ├── store.js
  │   ├── userReducers.js
  │   └── postReducers.js
  └── ...








reducers should be pure functions and not have side effects.







:

🔍 Why use rejectWithValue?
By default, if an error is thrown inside a createAsyncThunk, Redux Toolkit catches it and puts it into the rejected action — but it only gives you the error object, which might not contain the actual message or error structure you want (like the one returned by your backend).

rejectWithValue allows you to:

Pass custom error data (e.g., error.response.data.message)

Access this custom payload later in your slice’s extraReducers

Handle backend validation or API errors gracefully

✅ Without rejectWithValue
If you just throw the error or don't use rejectWithValue, the rejected action’s payload will be undefined, and you’ll need to check action.error.message.

✅ With rejectWithValue
js
Copy
Edit
return rejectWithValue(error.response?.data || error.message);
Now in your slice:

js
Copy
Edit
extraReducers: (builder) => {
  builder
    .addCase(registerUser.rejected, (state, action) => {
      state.error = action.payload; // This contains the value you passed with rejectWithValue
    });
}
🔄 Analogy
Think of rejectWithValue like saying:

“Hey, my async function failed, but here's a neat, specific error message you can use to show toasts or update the UI.”






