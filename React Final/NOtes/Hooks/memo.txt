-> we use memo to skip unnecessary rendering of a component if its props have not changed. This can improve performance
-> The memo function is used to create a memoized version of a functional component.
-> Memoization is a programming technique where we are storing the results of expensive function calls and returning the cached result when the same inputs given which helps prevent unnecessary renders.


 * suppose there are two components App component and Child component
 * we are passing state from App component to Child component
 * when we change a state in App component a App component render itself.
 * but important part here is that child component also render with App component.
 * we are not changing anything related to child component not its state but still child component render itself
 * to avoid this default behavior we use memo function
 * at the time of exporting child component like 'export default Child' we wrap name of child component inside memo function
 * child component only rendered when its props are changed.

App.jsx: 
========

const App = () => {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState(["todo 1", "todo 2"]);

  return (
    <>
      <Todos todos={todos} />
      <hr />
      <div>
        Count: {count}
        <button onClick={()=>setCount(count + 1)}>+</button>
      </div>
    </>
  );
};




Todos.js:
=========

import { memo } from "react";
const Todos = ({ todos }) => {
  console.log("child render");
  return (
    <>
      <h2>My Todos</h2>
      {todos.map((todo, index) => {
        return <p key={index}>{todo}</p>;
      })}
    </>
  );
};
export default memo(Todos);
	       ------------





difference between memo and useCallback hook: 
----------------------------------------------

-> Suppose we have two compoents 1. App.jsx  2. Todos.jsx
-> Inside App component we have two states which are initialized using useState Hook. 1. count state  2. todos state
-> so  we are passing todos state to todo component as a props.
-> so we use memo if we are just passing state from one compnet to another componet. to stop unnecessory re-rendring we use memo in todos component.
-> Now suppose inside App.jsx we write some event Handler related to todo compoent since there is a rule in react js which is the component which old the state is responsible for updating it. since inside our App componet we have todos state so our App componet is responsible for updating it.
-> so when the state of App component changes it will re-render Todo componet also, even we are using memo inside a Todo component.
-> The reason is that Every time a component re-renders, its functions get recreated. Because of this, the addTodo function has actually changed.
-> To fix this, we can use the useCallback hook to prevent the function from being recreated unless necessary.
-> Now the Todos component will only re-render when the todos prop changes.




App.jsx:
--------

import { useState, useCallback } from 'react';
import Todo from './File2';

const App = () => {
  const [count, setCount] = useState(0);
  const [todo, setTodos] = useState(['todo1', 'todo2'])

  const addTodos = useCallback((value) => {
    setTodos([...todo, value]);
  }, [todo])

  return (
    <>
      <Todo todos={todo} addTodo={addTodos}/>
      <h1>Count: {count}</h1>
      <button onClick={()=>setCount(count+1)}>count increment</button>
    </>
  )
}
export default App



Todos.jsx:
----------

import {memo} from 'react'

const Todo = ({todos, addTodo}) => {
  console.log('todo component rendered');
  return (
    <>
    <ul>
      {
        todos.map((todo, index)=><li key={index}>{todo}</li>)
      }
    </ul>
    <button onClick={()=>addTodo('todo3')}>Add Todo</button>

    </>
  )
}
export default memo(Todo);















