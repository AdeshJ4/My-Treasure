-> we use memo to skip unnecessary rendering of a component if its props have not changed. This can improve performance
-> The memo function is used to "create a memoized version of a functional component".
-> Memoization is a programming technique where we are storing the results of expensive function calls and returning the cached 
result when the same inputs given which helps prevent unnecessary renders.


 * suppose there are two components App component and Child component
 * we are passing state from App component to Child component
 * when we change a state in App component a App component render itself.
 * but important part here is that child component also render with App component.
 * we are not changing anything related to child component not its state but still child component render itself
 * to avoid this default behavior we use memo function
 * at the time of exporting child component like 'export default Child' we wrap name of child component inside memo function
 * child component only rendered when its props are changed.

App.jsx: 
========

const App = () => {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState(["todo 1", "todo 2"]);

  return (
    <>
      <Todos todos={todos} />
      <hr />
      <div>
        Count: {count}
        <button onClick={()=>setCount(count + 1)}>+</button>
      </div>
    </>
  );
};




Todos.js:
=========

import { memo } from "react";
const Todos = ({ todos }) => {
  console.log("child render");
  return (
    <>
      <h2>My Todos</h2>
      {todos.map((todo, index) => {
        return <p key={index}>{todo}</p>;
      })}
    </>
  );
};
export default memo(Todos);
	       ------------


