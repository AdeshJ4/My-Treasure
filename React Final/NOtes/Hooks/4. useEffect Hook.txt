-> The useEffect Hook allows you to perform 'side effects' in your components.

-> Some examples of side effects are: fetching data, directly updating the DOM, and timers, store data in local storage.

-> useEffect accepts two arguments. The second argument is optional.
   useEffect(<function>, <dependency>)


-> The useEffect Hook allows you to specify a callback function that will be executed after the component renders. 
This function can perform side effects.

-> useEffect runs on every render That means that when the state changes, a render happens, which then triggers another effect. 
Thats why we use dependencies.

-> Dependencies: You can also specify dependencies, which are variables or values that, when they change, trigger the useEffect to 
run. This allows you to control when your side effect should be executed.



ex: 
const UseMe = () => {
  const [count, setCount] = useState(0);
  useEffect(()=> {
    setTimeout(() => {
      setCount(count + 1);  // state variable changes its value 
    }, 2000);
  });
  return (
    <div>I have rendered {count} times.</div>
  )
}



Dependency :
------------

1. No dependency passed:
useEffect(() => {
  //Runs on every render
});

2. An empty array:
useEffect(() => {
  //Runs only on the first render
}, []);

3. Props or state values:
useEffect(() => {
  //Runs on the first render
  //And any time any dependency value changes
}, [prop, state]);




const App = () => {
  const [count, setCount] = useState(0);
  const[calculation, setCalculation] = useState(0);

  useEffect(() => {
      setCalculation(count * 2);
  }, [count]);

  return (
    <>
      <h1>Count: {count}</h1>
      <h1>Calculation: {calculation}</h1>

      <button onClick={()=>setCount(count+1)}>Count</button>
    </>
  );
};



Example No 1: fetch the data : 
------------------------------

// inside a list

import axios from "axios";
import React, { useEffect, useState } from "react";

const UseMe = () => {
  const [data, setData] = useState(null);

  const fetchData = async () => {
    try {
      const response = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      const result = response.data;
      setData(result);
    } catch (err) {
      console.error("Error : ", err.message);
    }
  };
  useEffect(() => {
    fetchData();
  }, []);

  return (
    <div>
      {data ? (
        // Render the data
        <ul>
          {data.map((item) => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      ) : (
        // Render a loading message or handle no data scenario
        <p>Loading...</p>
      )}
    </div>
  );
};

export default UseMe;

// inside a table
import { useState, useEffect } from 'react';
import axios from 'axios';

const App = () => {
  const [users, setUsers ] = useState(null);
  async function fetchUsers(controller){
    try{
      const {data} = await axios.get('https://jsonplaceholder.typicode.com/users', {signal: controller.signal});
      setUsers(data);
    }catch(err){
      console.log(err.message);
    }
  }
  useEffect(()=>{
    const controller = new AbortController();
    fetchUsers(controller);
    return ()=> controller.abort();
  }, []);
  return(
    <>
      {users?
        <table className='table table-bordered'>
          <thead>
            <tr>
              <th>ID</th>
              <th>Name</th>
              <th>UserName</th>
              <th>Email</th>
            </tr>
          </thead>
          <tbody>
            {users.map(user=><tr key={user.id}>
              <td>{user.id}</td>
              <td>{user.name}</td>
              <td>{user.username}</td>
              <td>{user.email}</td>
            </tr>)}
          </tbody>
        </table> : 
        <p>Loading....</p>
      }
    </>
  )
}
export default App;






DOM manipulation
----------------------------------------------------


// document.title
import axios from "axios";
import React, { useEffect, useState } from "react";
const UseMe = () => {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetchUsers();
  }, []);

  useEffect(() => {
    if (users) {
      document.title = `Users: ${users.length}`;
    } else {
      document.title = "Loading...";
    }
  }, [users]);

  async function fetchUsers() {
    try {
      const response = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      const result = response.data;
      setUsers(result);
    } catch (err) {
      console.log("error: ", err);
    }
  }
  return <>
    {users ? (
      <ul>
        {users.map((user)=> <li key={user.id}>{user.name}</li>)}
      </ul>
    ):
    <p>Loading...</p>
  }
  </>;
};



// document.body.style.background
const App = () => {
  const [backgroundColor, setBackgroundColor] = useState('white');
  const [inputColor, setInputColor] = useState('');

  useEffect(() => {
    // Update the background color when the inputColor state changes
    document.body.style.backgroundColor = backgroundColor;
  }, [backgroundColor]); // Only re-run the effect when backgroundColor changes

  return (
    <div>
      <input type="text" value={inputColor} onChange={(e)=>setInputColor(e.target.value)}/>
      <button onClick={()=> setBackgroundColor(inputColor)}>Change Color</button>
    </div>
  );
};



Ex 3 : Timer
------------

const UseMe = () => {
  const [count, setCount] = useState(0);
  useEffect(()=> {
    setTimeout(() => {
      setCount(count + 1);
    }, 2000);
  });
  return (
    <div>I have rendered {count} times.</div>
  )
}







Effect Cleanup: 
===============

-> Some effects require cleanup to reduce memory leaks.
-> Timeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed
-> We do this by including a return function at the end of the useEffect Hook.
-> If the component is unmounted or if the dependencies of the useEffect change, the cleanup function is executed.
-> The cleanup function is a good place to release resources, cancel subscriptions, clear intervals, or perform any other necessary 
cleanup.
-> Not all useEffect functions require a cleanup. If cleanup is not needed, you can omit the return statement.


Ex 1 : Timer 
------------

const UseMe = () => {
  const [count, setCount] = useState(0);
  useEffect(() => {
    let timer = setTimeout(() => {
      setCount(count + 1);
    }, 2000);
    return () => clearTimeout(timer);
  }, []);
  return <div>COunt : {count}</div>;
};

export default UseMe;




Ex. fetch users : 
-----------------

import React, { useState, useEffect } from 'react';
import axios, { CanceledError } from 'axios';

const UseMe = () => {
  const [users, setUsers] = useState(null);

  useEffect(() => {
  // AbortController allow us to cancel or abort asynchronous operations like fetch request or dom manipulation or any operation that might takes long time to complete
    const controller = new AbortController();
    fetchUsers(controller);
    return () => controller.abort();
  }, []);

  const fetchUsers = async (controller) => {
    try {
      const response = await axios.get("https://jsonplaceholder.typicode.com/users", {
        signal: controller.signal
      });

      const result = response.data;
      setUsers(result);
    } catch (err) {
      if (err instanceof CanceledError) {
        // Request was canceled
        return;
      }
      console.log("Error: ", err);
    }
  };

  return (
    <>
      {users ? (
        <ul>
          {users.map((user) => <li key={user.id}>{user.name}</li>)}
        </ul>
      ) : (
        <p>Loading...</p>
      )}
    </>
  );
};

export default UseMe;







How to fetch data in react js : 

There are mainly two ways of fetching data in react: 

1. Fetch API: 
2. Using Axios:






1. Fetch API: 
const Fun = () => {
    const [data, setData] = useState(null);

    const fetchData = async () => {
        try{
            const response = await fetch('https://jsonplaceholder.typicode.com/users');
            if(!response.ok){
                throw new Error('Network Error');
            }

            const result = await response.json(); // json() method used to extract the JSON body content from the HTTP response obtained using the Fetch API. 
            setData(result);
            
        }catch(err){
            console.log(err.message);
        }
    }

    useEffect(()=>{
        fetchData();
    }, [])

    return (
        <>
        {data ? (
            <ul>
                {data.map(d=><li key={d.id}>{d.name}</li>)}
            </ul>
        ): <p>Loading...</p>}
        </>
    );
}





2. Using Axios:

import axios from "axios";
import React, { useEffect, useState } from "react";

const UseMe = () => {
  const [data, setData] = useState(null);

  const fetchData = async () => {
    try {
      const response = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      const result = response.data;
      setData(result);
    } catch (err) {
      console.error("Error : ", err.message);
    }
  };
  useEffect(() => {
    fetchData();
  }, []);

  return (
    <div>
      {data ? (
        // Render the data
        <ul>
          {data.map((item) => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      ) : (
        // Render a loading message or handle no data scenario
        <p>Loading...</p>
      )}
    </div>
  );
};

export default UseMe;







