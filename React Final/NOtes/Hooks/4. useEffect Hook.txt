-> The useEffect Hook allows you to perform 'side effects' in your components.

-> When we talk about side effects in the context of React.js, we are referring to anything that is outside the scope of React. 
because react is designed around this concept called "Pure function".
-> Pure function is a function, if you called pure function nth times then it will return you the same output and has no side effects.
-> Pure functions help keep React components predictable and easier to debug.
-> so  if we given same input like a same props it will always return the same JSX .and this is for performance reason. so if the 
inputs of components haven't change react can skip re-rendering of that component.
-> Side effects can include things like modifying variables outside of a function, fetching data(network requests), directly updating 
the DOM, and timers, store data in local storage.
-> we must handle this side effects inside useEffect hook.


🔹 What is a Pure Function?

A pure function is a function that:
👉 Always returns the same output for the same input.
👉 Has no side effects (like modifying global variables, making API calls, logging to the console, etc.).

✅ Characteristics:
👉 predictable
👉 No side effects
👉 Does not rely on or change external state


💡 Example of a Pure Function:

```
function add(a, b) {
  return a + b;
}

add(2, 3); // Always returns 5
```
Explanation: if you call add function with arguments 2, 3 nth times then it always return you 5 as a result.


❌ Impure Function:
```
let count = 0;
function increment() {
  count += 1;
}
increment();

```
Explanation: Every time you call increment() functionvalue changes.


🔹 What is the relation between pure functions and useEffect?

React components themselves should ideally be pure functions — they take props and state as input and return JSX.
But sometimes, you need to do side effects, like:

⏺️ Fetching data
⏺️ Subscribing to events
⏺️ Updating the DOM
⏺️ Logging

That’s where useEffect comes in!




-> useEffect accepts two arguments. The second argument is optional.
   useEffect(<function>, <dependency>)


-> The useEffect Hook allows you to specify a callback function that will be executed after the component renders. 
This function can perform side effects.

-> useEffect runs on every render That means that when the state changes, a render happens, which then triggers another effect. 
Thats why we use dependencies.

-> Dependencies: You can also specify dependencies, which are variables or values that, when they change, trigger the useEffect to 
run. This allows you to control when your side effect should be executed.



ex: 
const UseMe = () => {
  const [count, setCount] = useState(0);
  useEffect(()=> {
setTimeout(() => {
      setCount(count + 1);  // state variable changes its value 
    }, 2000);    
  });
  return (
    <div>I have rendered {count} times.</div>
  )
}



Dependency :
------------

1. No dependency passed:
useEffect(() => {
  //Runs on every render
});

2. An empty array:
useEffect(() => {
  //Runs only on the first render
}, []);

3. Props or state values:
useEffect(() => {
  //Runs on the first render
  //And any time any dependency value changes
}, [prop, state]);




const App = () => {
  const [count, setCount] = useState(0);
  const[calculation, setCalculation] = useState(0);

  useEffect(() => {
      setCalculation(count * 2);
  }, [count]);

  return (
    <>
      <h1>Count: {count}</h1>
      <h1>Calculation: {calculation}</h1>

      <button onClick={()=>setCount(count+1)}>Count</button>
    </>
  );
};




============================================================================================================================================================


🔹 What is a Cleanup Function in useEffect?
In React, a useEffect hook can return a function, and that returned function is called a cleanup function.

✅ Purpose:
It’s used to clean up side effects like:

👉 Removing event listeners
👉 Clearing timers or intervals
👉 Cancelling API requests
👉 Unsubscribing from services or sockets

Basically, it prevents memory leaks and unwanted behavior when the component unmounts or before the effect re-runs.



🧠 Why it's important:

Without cleanup, you could end up with:

👉 Multiple intervals running
👉 Duplicate event listeners
👉 Memory leaks
👉 Bugs that are hard to trace




-> Some effects require cleanup to reduce memory leaks.
-> Timeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed
-> We do this by including a return function at the end of the useEffect Hook.
-> If the component is unmounted or if the dependencies of the useEffect change, the cleanup function is executed.
-> The cleanup function is a good place to release resources, cancel subscriptions, clear intervals, or perform any other necessary 
cleanup.
-> Not all useEffect functions require a cleanup. If cleanup is not needed, you can omit the return statement.



✅ Rule of thumb:
👉 If your useEffect sets something up, like a timer, subscription, or listener — you should clean it up.


syntax: 

```
useEffect(() => {
  console.log('Component mounted');

  // 👇 return a cleanup function
  return () => {
    console.log('Component unmounted');
  };
}, []);
```

============================================================================================================================================================



Example No 1: fetch the data using axios: 
------------------------------


import React, { useEffect, useState } from 'react';
import axios from 'axios';

const App = () => {
  const [users, setUsers] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchUsers = async (controller) => {
    try {
      const { data } = await axios.get(
        'https://jsonplaceholder.typicode.com/users',
        { signal: controller.signal }
      );
      setUsers(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    const controller = new AbortController();
    fetchUsers(controller);

    return () => controller.abort();
  }, []);

  useEffect(()=> {
    document.title = users ? `Users: ${users.length}` : 'Loading...';
  }, [users])
 
  const displayUsers = (users) => {
    return (
      <div style={{ overflow: 'auto' }}>
        <table style={styles.table}>
          <thead style={styles.thead}>
            <tr>
              <th style={styles.thtd}>ID</th>
              <th style={styles.thtd}>Name</th>
              <th style={styles.thtd}>Username</th>
              <th style={styles.thtd}>Email</th>
              <th style={styles.thtd}>Street</th>
              <th style={styles.thtd}>Suite</th>
              <th style={styles.thtd}>City</th>
              <th style={styles.thtd}>Zipcode</th>
              <th style={styles.thtd}>Phone</th>
              <th style={styles.thtd}>Website</th>
              <th style={styles.thtd}>Company</th>
            </tr>
          </thead>
          <tbody>
            {users.map((user) => (
              <tr key={user.id}>
                <td style={styles.thtd}>{user.id}</td>
                <td style={styles.thtd}>{user.name}</td>
                <td style={styles.thtd}>{user.username}</td>
                <td style={styles.thtd}>{user.email}</td>
                <td style={styles.thtd}>{user.address?.street}</td>
                <td style={styles.thtd}>{user.address?.suite}</td>
                <td style={styles.thtd}>{user.address?.city}</td>
                <td style={styles.thtd}>{user.address?.zipcode}</td>
                <td style={styles.thtd}>{user.phone}</td>
                <td style={styles.thtd}>{user.website}</td>
                <td style={styles.thtd}>{user.company?.name}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    );
  };

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div style={{ padding: '20px' }}>
      <h2 style={{ textAlign: 'center' }}>User List</h2>
      {users && users.length > 0 ? displayUsers(users) : <p>No Users</p>}
    </div>
  );
};

const styles = {
  table: {
    width: '100%',
    borderCollapse: 'collapse',
    minWidth: '800px',
  },
  thead: {
    backgroundColor: '#f2f2f2',
    textAlign: 'left',
  },
  thtd: {
    border: '1px solid #ddd',
    padding: '8px',
  },
};

export default App;

============================================================================================================================================================

AbortController: 

We use 'AbortController' in Axios or Fetch in React to "cancel an ongoing request" , especially when a component "unmounts" or when
a new request replaces an old one. 

✅ Why we use AbortController:

1️⃣ Prevent memory leaks – avoid updating state on unmounted components.
2️⃣ Avoid race conditions – when multiple requests are triggered (e.g., during a search), cancel the previous one.
3️⃣ Improve performance – cancel unnecessary requests.
4️⃣ Clean UX – user doesn’t get outdated or unwanted data.


============================================================================================================================================================

fetch data using fetch api : 

1. Fetch API: 
const Fun = () => {
    const [data, setData] = useState(null);

    const fetchData = async () => {
        try{
            const response = await fetch('https://jsonplaceholder.typicode.com/users');
            if(!response.ok){
                throw new Error('Network Error');
            }

            const result = await response.json(); // json() is method provided by the "Response" object to parse the body of a response as JSON.
            setData(result);
            
        }catch(err){
            console.log(err.message);
        }
    }

    useEffect(()=>{
        fetchData();
    }, [])

    return (
        <>
        {data ? (
            <ul>
                {data.map(d=><li key={d.id}>{d.name}</li>)}
            </ul>
        ): <p>Loading...</p>}
        </>
    );
}




============================================================================================================================================================



🎯 DOM manipulation  - document.body.style.background   &&     document.title
-----------------------------------------------------------------------------

code 1
```
const App = () => {
  const [inputColor, setInputColor] = useState('white');

  useEffect(() => {
    document.body.style.backgroundColor = inputColor;    
  }, [inputColor]);

  useEffect(() => {
    document.title = inputColor ? inputColor.length : 0;
  }, [inputColor]);
  
  return <input type="text" placeholder='Enter Color name' onChange={(e) => setInputColor(e.target.value)} />
}
```

code 2: 
```
const App = () => {
  const [inputColor, setInputColor] = useState(null);
  const [color, setColor] = useState(null);

  useEffect(() => {
    document.body.style.backgroundColor = inputColor;
  }, [color]);


  useEffect(() => {
    document.title = inputColor ? inputColor.length : 0;
  }, [inputColor]);


  return (
    <div>
      <input type="text" onChange={(e) =>  setInputColor(e.target.value)} />
      <button onClick={() => setColor(inputColor)}>Clcik</button>
    </div>
  )
}
```

