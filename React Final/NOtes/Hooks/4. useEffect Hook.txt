-> The useEffect Hook allows you to perform side effects in your components.

-> Some examples of side effects are: fetching data, directly updating the DOM, and timers, store data in local storage.

-> useEffect accepts two arguments. The second argument is optional.
   useEffect(<function>, <dependency>)


-> The useEffect Hook allows you to specify a callback function that will be executed after the component renders. This function can perform side effects.

-> useEffect runs on every render That means that when the state changes, a render happens, which then triggers another effect. Thats why we use depenedecies.
-> Dependencies: You can also specify dependencies, which are variables or values that, when they change, trigger the useEffect to run. This allows you to control when your side effect should be executed.

-> For example, you can use useEffect to fetch data from a server when your component loads, update the document title when certain data changes, or set up event listeners to respond to user interactions. These are all side effects that don't directly affect the component's rendering but are essential for the overall functionality of your application. The useEffect Hook helps you manage and control these side effects in a structured and efficient way.



ex: 
const UseMe = () => {
  const [count, setCount] = useState(0);
  useEffect(()=> {
    setTimeout(() => {
      setCount(count + 1);  // state variable changes its value 
    }, 2000);
  });
  return (
    <div>I have rendered {count} times.</div>
  )
}



Dependency :
------------

1. No dependency passed:
useEffect(() => {
  //Runs on every render
});

2. An empty array:
useEffect(() => {
  //Runs only on the first render
}, []);

3. Props or state values:
useEffect(() => {
  //Runs on the first render
  //And any time any dependency value changes
}, [prop, state]);






Example No 1: fetch the data : 
------------------------------


import axios from "axios";
import React, { useEffect, useState } from "react";

const UseMe = () => {
  const [data, setData] = useState(null);

  const fetchData = async () => {
    try {
      const response = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      const result = response.data;
      setData(result);
    } catch (err) {
      console.error("Error : ", err.message);
    }
  };
  useEffect(() => {
    fetchData();
  }, []);

  return (
    <div>
      {data ? (
        // Render the data
        <ul>
          {data.map((item) => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      ) : (
        // Render a loading message or handle no data scenario
        <p>Loading...</p>
      )}
    </div>
  );
};

export default UseMe;








update the document title when certain data changes:
----------------------------------------------------

import axios from "axios";
import React, { useEffect, useState } from "react";

const UseMe = () => {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetchUsers();
  }, []);

  useEffect(() => {
    if (users) {
      document.title = `Users: ${users.length}`;
    } else {
      document.title = "Loading...";
    }
  }, [users]);

  async function fetchUsers() {
    try {
      const response = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      const result = response.data;
      setUsers(result);
    } catch (err) {
      console.log("error: ", err);
    }
  }

  return <>
    {users ? (
      <ul>
        {users.map((user)=> <li key={user.id}>{user.name}</li>)}
      </ul>
    ):
    <p>Loading...</p>
  }
  </>;
};

export default UseMe;




Ex 3 : Timer
------------

const UseMe = () => {
  const [count, setCount] = useState(0);
  useEffect(()=> {
    setTimeout(() => {
      setCount(count + 1);
    }, 2000);
  });
  return (
    <div>I have rendered {count} times.</div>
  )
}







Effect Cleanup: 
===============

-> Some effects require cleanup to reduce memory leaks.
-> Timeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed
-> We do this by including a return function at the end of the useEffect Hook.
-> If the component is unmounted or if the dependencies of the useEffect change, the cleanup function is executed.
-> The cleanup function is a good place to release resources, cancel subscriptions, clear intervals, or perform any other necessary cleanup.
-> Not all useEffect functions require a cleanup. If cleanup is not needed, you can omit the return statement.


Ex 1 : Timer 
------------

const UseMe = () => {
  const [count, setCount] = useState(0);
  useEffect(() => {
    let timer = setTimeout(() => {
      setCount(count + 1);
    }, 2000);
    return () => clearTimeout(timer);
  }, []);
  return <div>COunt : {count}</div>;
};

export default UseMe;




Ex. fetch users : 
-----------------

import React, { useState, useEffect } from 'react';
import axios, { CanceledError } from 'axios';

const UseMe = () => {
  const [users, setUsers] = useState(null);

  useEffect(() => {
  // AbortController allow us to cancel or abort asynchronous operations like fetch request or dom manipulation or any operation that might takes long time to complete
    const controller = new AbortController();

    fetchUsers(controller);

    return () => controller.abort();
  }, []);

  const fetchUsers = async (controller) => {
    try {
      const response = await axios.get("https://jsonplaceholder.typicode.com/users", {
        signal: controller.signal
      });

      const result = response.data;
      setUsers(result);
    } catch (err) {
      if (err instanceof CanceledError) {
        // Request was canceled
        return;
      }
      console.log("Error: ", err);
    }
  };

  return (
    <>
      {users ? (
        <ul>
          {users.map((user) => <li key={user.id}>{user.name}</li>)}
        </ul>
      ) : (
        <p>Loading...</p>
      )}
    </>
  );
};

export default UseMe;







How to fetch data in react js : 

There are mainly two ways of fetching data in ract: 

1. Fetch API: 
2. Using Axios:






1. Fetch API: 
const Fun = () => {
    const [data, setData] = useState(null);

    const fetchData = async () => {
        try{
            const response = await fetch('https://jsonplaceholder.typicode.com/users');
            if(!response.ok){
                throw new Error('Network Error');
            }

            const result = await response.json(); // json() method used to extract the JSON body content from the HTTP response obtained using the Fetch API. 
            setData(result);
            
        }catch(err){
            console.log(err.message);
        }
    }

    useEffect(()=>{
        fetchData();
    }, [])

    return (
        <>
        {data ? (
            <ul>
                {data.map(d=><li key={d.id}>{d.name}</li>)}
            </ul>
        ): <p>Loading...</p>}
        </>
    );
}





2. Using Axios:

import axios from "axios";
import React, { useEffect, useState } from "react";

const UseMe = () => {
  const [data, setData] = useState(null);

  const fetchData = async () => {
    try {
      const response = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      const result = response.data;
      setData(result);
    } catch (err) {
      console.error("Error : ", err.message);
    }
  };
  useEffect(() => {
    fetchData();
  }, []);

  return (
    <div>
      {data ? (
        // Render the data
        <ul>
          {data.map((item) => (
            <li key={item.id}>{item.name}</li>
          ))}
        </ul>
      ) : (
        // Render a loading message or handle no data scenario
        <p>Loading...</p>
      )}
    </div>
  );
};

export default UseMe;







