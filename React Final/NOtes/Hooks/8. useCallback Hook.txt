-> useCallback Hook returns a "memoized version of callback function".
-> basically it is used to isolate 'resource intensive functions' which are passed as a prop to child component so they will not 
automatically recreated on every render when state of the parent component get changed, they will only changed when one of the 
dependency get changed.
-> Every time a component re-renders, its functions get recreated. Because of this, another nested component will re-render to stop 
this we use useCallback hook.
-> The useCallback Hook only runs when one of its `dependencies update`. This can improve performance.	
-> we use memo function along with useCallback hook.

Extra Notes:
1. Function recreated: When a function is recreated, it means that a new instance of the function is created every time the component 
re-renders. This can happen when the dependencies array provided to useCallback changes, causing the callback function to be redefined.
2. Function executed: When the function is executed, it means that it is actually being called and its code is being run.


how can i know that function is recreated?
-> When a function is recreated, its reference will change.
-> You can track this by comparing the reference of the function before and after a render cycle.










what is Memoization ?
=====================

-> Memoization is a programming technique where we are storing the results of expensive function calls and returning the cached 
result when the same inputs given which helps prevent unnecessary renders.


what is cached result ?
=======================
A cached result is 'temporary data' which is used to store, "stored output" or "value of a computation" or "function call" that has 
been previously calculated and saved for future use.
ex> 
function multiply(){
    const cache = {};
    return function (num){
        if(num in cache){
            console.log('Data coming from cache object');
            console.log(cache[num]);
        }else{
            cache[num] = num * num;
            console.log(cache[num]);
        }
    }
}
const res = multiply();
res(10);
res(10);

