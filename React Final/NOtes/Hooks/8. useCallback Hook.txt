-> useCallback Hook returns a "memoized version of callback function".
-> basically it is used to isolate 'resource intensive functions' which are passed as a prop to child component so they will not 
automatically recreated on every render when state of the parent component get changed, they will only changed when one of the 
dependency get changed.
-> Every time a component re-renders, its functions get recreated. Because of this, another nested component will re-render to stop 
this we use useCallback hook.
-> The useCallback Hook only runs when one of its `dependencies update`. This can improve performance.	
-> we use memo function along with useCallback hook.

Extra Notes:
1. Function recreated: When a function is recreated, it means that a new instance of the function is created every time the component 
re-renders. This can happen when the dependencies array provided to useCallback changes, causing the callback function to be redefined.
2. Function executed: When the function is executed, it means that it is actually being called and its code is being run.


how can i know that function is recreated?
-> When a function is recreated, its reference will change.
-> You can track this by comparing the reference of the function before and after a render cycle.










what is Memoization ?
=====================

-> Memoization is a programming technique where we are storing the results of expensive function calls and returning the cached 
result when the same inputs given which helps prevent unnecessary renders.


what is cached result ?
=======================
A cached result is 'temporary data' which is used to store, "stored output" or "value of a computation" or "function call" that has 
been previously calculated and saved for future use.
ex> 
function multiply(){
    const cache = {};
    return function (num){
        if(num in cache){
            console.log('Data coming from cache object');
            console.log(cache[num]);
        }else{
            cache[num] = num * num;
            console.log(cache[num]);
        }
    }
}
const res = multiply();
res(10);
res(10);



what is meaning of useCallback with empty dependency array:



When you use `useCallback` with an **empty dependency array** (`[]`), it means that the function you are memoizing will be created **only once**, 
during the initial render of the component. This ensures that the same instance of the function is reused across all renders.

### Syntax
```javascript
const memoizedFunction = useCallback(() => {
  // Function logic here
}, []);
```

### What It Means
1. **"Create once and reuse":**  
   The function is created only during the component's first render. On subsequent renders, React reuses the same instance of the function without recreating it.

2. **No dependencies:**  
   The function does not rely on any values or variables from the component that may change over time. If you include variables as dependencies (e.g., `[value]`), React will recreate the function whenever those variables change.

### When to Use `useCallback([])`
- **Stable function reference:**  
   If a child component depends on the function (e.g., passed as a prop), using `useCallback([])` prevents unnecessary re-renders of the child component. React checks prop equality by reference, so keeping the function instance stable helps optimization.

- **Dependencies are not needed:**  
   The function does not rely on dynamic state, props, or other variables that can change.

### Example
```javascript
import React, { useCallback, useState } from 'react';

const MyComponent = () => {
  const [count, setCount] = useState(0);

  // Function that doesn't depend on any changing values
  const handleClick = useCallback(() => {
    console.log('Button clicked!');
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={handleClick}>Log Message</button>
    </div>
  );
};
```

### Behavior in This Example:
- `handleClick` is created once and reused, even if `count` changes.
- React reuses the same instance of `handleClick` across renders, which can improve performance if `handleClick` is passed to child components.

### Key Points
- Use `useCallback([])` for functions that don’t rely on external variables.
- Avoid overusing `useCallback` for all functions—use it only when there's a clear benefit, like preventing unnecessary re-renders.


