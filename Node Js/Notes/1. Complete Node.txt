What is Node js ? 
=================

->Node is not a programming language nor its a framework it is just a open source, cross platform runtime environment for 
executing js code outside a browser.
-> we use Node js to build backend services also call APIs.
-> NodeJS is an asynchronous event-driven JavaScript runtime environment designed to build scalable network applications.

APIs : 

-> API Stands for "Application Programming Interface".
-> The API acts as middleware or bridge between the frontend(client-side applications) and backend(server-side applications or 
services).
-> It defines a set of rules and protocols for how the frontend can communicate with the backend
-> It provides a structured way for the frontend to request specific operations from the backend.
-> When the frontend needs to interact with the backend, it sends API requests. These requests specify the desired action 
(e.g., fetching data, updating records) and may include additional information.
-> In the backend, The backend processes these requests, performs the necessary operations, and sends back API responses containing
the results.
-> In summary, APIs serve as a bridge between the frontend and backend, allowing them to communicate in a standardized and structured 
manner.


Node Architecture: 
==================

-> up to 2009 only way to executing js code was inside a browser.  A browser provide a runtime environment for js code.
-> so every browser have "JS Engine" that takes our js code and converts it  into machine code that computer understand.
-> Microsoft edge uses 'chakra', firefox uses 'SpiderMonkey' and chrome uses 'V8' and because of this verities of "JS ENGINE" 
sometimes the js code can behave differently browser to browser.
->In 2009,Ryan Dahl the creator of node came up with brilliant idea. He took google v8 engine which is the fastest js engine out 
there and embedded it inside a c++ program and called that  program  'Node.exe' means Node. 
-> so similar to browser, Node became runtime environment for js code. 
-> Node contain js engine, with certain objects which provides an environment for executing our js code.
-> for ex we don't have document object like "document.getElementById('')" in a node instead we have different objects that gives us 
more interesting capabilities. for ex we can work with file system like "fs.readFile()" listen for request like "http.createServer()" 
in a given port. and so on we can't do this kind of stuff inside a browser.
-> In summary Node is a program that contain chrome v8 engine plus some additional modules which gave us some capabilities not 
available inside a browser.
-> we can work with file system , network and so on..
-> Both  chrome and node share same V8 engine but they provide different runtime environment for js code to run.



How Node js Works: 
==================

-> In a synchronous architecture, when we receive a request on a server, we allocate a thread to handle that request. 
suppose that request is queering a database. as you know queering a database may takes some time for returning a result.
-> so When database is executing a query that thread is sitting ideal. 
-> Now suppose another request comes at that point then we have to allocate another thread for a new request.
-> Now imagine, what will happen, if we have a server with lots of no of concurrent requests/clients.
-> At some time we will out of threads because there are lots of concurrent request.
-> so new client or request have to wait until threads are available or if we don't want to wait them we need to add more hardware. 
so with this kind of architecture we are not utilizing recourses efficiently this is a problem with  blocking or synchronous 
architecture. this is how applications are build with frameworks like ASP.NET. works by default. of course in ASP.net it is possible 
to use asynchronous architecture but you have to do extra work for that

-> Node applications are Asynchronous by default.
-> In node we have a single thread to handle all requests.
-> In Asynchronous architecture, When a request arrives on a server, Node assign single thread to handle that request. suppose that 
request is queering a database. as you know queering a database may takes some time for returning a result but important point is 
that our thread doesn't have to wait for database to return a data. while the database is executing query that thread is used to 
serve another client/request.
-> When our asynchronous task completes in our case asynchronous task is fetching data from database, database puts the message in 
what we called "Event Queue".
-> Node is continuously monitoring queues in background. when Node found event in this event queue node will take out that event or 
data and process it. 
-> This kind of architecture make a node ideal for building applications which includes lots of disk or network access like 
I/O-intensive apps.
-> we can serve more clients without the need of using more hardware. and that why node application highly scalable.
-> In contrast Node should not be used for CPU intensive apps like a video encoding or image manipulations services. In this kind of 
applications we have a lots of calculation that should be done by CPU  and few operations touch the file system or the network. 
-> Since Node applications are single threaded when performing calculations to serve one client other clients have to wait and thats 
why node should not be used for CPU intensive applications. it should only be used for data intensive and real time applications. 


Event Queue:
-> The event queue is a data structure that holds tasks or events that need to be processed.
-> It acts as a waiting area for tasks that are triggered by various events, such as user interactions, I/O operations, or timers.
-> When you make an asynchronous function call or register an event listener, the associated task goes into the event queue.
-> Imagine people standing in line to buy tickets. Each person represents a task waiting to be processed.
-> Tasks in the event queue are processed in the order they are added (FIFO - First In, First Out - the first item that is added to 
a queue is the first one to be removed).
-> Tasks can include callbacks, promises, or other asynchronous operations.


Event Loop: 

-> 'Event loop' is a C program and is part of libuv.
-> Event loop is a loop that is alive as long as your node js application is up and running.
-> The event loop is what allows Node.js to perform non-blocking I/O operations â€” despite the fact that JavaScript is single-threaded
-> The event loop is like a manager that checks the event queue and decides which task to execute next.
-> An event loop is an loop, which waits for tasks, executes them, and then sleeps until it receives more tasks.
-> The event loop constantly checks whether the call stack is empty and executes tasks one by one
-> The event loop executes tasks from the event queue only when the call stack is empty i.e. there is no ongoing task.
-> The event loop follows a cycle: it checks if the call stack is empty, and if so, it takes tasks from the event queue and adds 
them to the call stack for execution.
-> The event loop processes tasks in the order they were added to the queue. 
This follows the FIFO principle. (First In, First Out - the first item that is added to a queue is the first one to be removed).
-> The event loop allows for non-blocking, asynchronous execution in a single-threaded environment.
-> It prevents the program from getting stuck on one task, enabling it to handle multiple tasks concurrently.


call Stack : 

-> The call stack is a data structure that keeps track of the currently executing functions. When a function is called, 
it is pushed to the call stack and popped off when completed.
-> The call stack in Node.js follows the Last In, First Out (LIFO) order. This means that the most recently added function call 
in the stack is the first one to be executed and removed when the function completes.
-> Whenever a function is called, a new frame is added to the top of the call stack.
-> frame contains information about the function call, including the function's parameters and local variables.
-> As functions are executed, their frames are pushed onto the call stack. When a function completes, its frame is popped off the 
stack.

ex: 
function f1() {
    console.log('Hi by f1!');
}
function f2() {
    f1();
    console.log('Hi by f2!');
}
f2();

The call stack would look like:
------------------------------

-> suppose we have two functions f1() and f2(). we called f1() inside f2(). 
Step 1: When the code loads in memory, the 'global execution context' gets pushed in the stack.
Step 2: The f2() function gets called, and the 'execution context of f2()' gets pushed into the stack
Step 3: The execution of f2() starts and during its execution, the f1() function gets called inside the f2() function. 
This causes the execution context of f1() to get pushed in the call stack.
Step 4: Now the f1() function starts executing.
Step 5: When f1() completes its execution it will be popped from the stack.
Step 6: Now remaining code of f2() gets executed and after that f2() will be popped from the stack.
Step 7: Now left is only 'global execution context' which at the end will be popped out.
global execution context: 

The global execution context is the outermost or top-level context in the JavaScript execution environment. When a JavaScript 
program starts running, it creates a global execution context, which includes the following key components like Global Object, this etc.







why we use single thread in Node js?
==========================================
-> A single-threaded approach consumes less memory than multi-threading, making Node.js suitable for lightweight, memory-efficient 
applications and microservices.
-> To maximize efficiency in handling I/O operations. 
-> This allows it to handle many concurrent requests without the overhead of managing multiple threads. 


list of I/O operations: 
-> In Node.js, I/O (Input/Output) operations are how you handle data exchange with external entities, such as files, networks, 
databases, and more. Here are some common I/O operations in Node.js:

1. File System Operations:
const fs = require('fs');
// Reading a file
fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
// Writing to a file
fs.writeFile('example.txt', 'Hello, Node.js!', (err) => {
  if (err) throw err;
  console.log('File written successfully.');
});


2. Network Operations
const http = require('http');
// Creating an HTTP server
const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Hello, Node.js!');
})
server.listen(3000, 'localhost', () => {
  console.log('Server listening on port 3000');
});


3. Database Operations
const { MongoClient } = require('mongodb');
const uri = 'mongodb://localhost:27017'; // Replace with your MongoDB connection string
cost client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });
async function connectToDatabase() {
  try {
    await client.connect();
    console.log('Connected to MongoDB');

    // Perform MongoDB CRUD operations here

  } catch (error) {
    console.error('Error connecting to MongoDB:', error.message);
  } finally {
    // Ensure the database connection is closed when operations are done
    await client.close();
    console.log('Disconnected from MongoDB');
  }
}








There are also other languages to build back-end services like ASP.NET, java then why Node ?
============================================================================================


1.  Node is easy to started.
2.  Super fast and highly scalable services
3.  Node applications are Asynchronous by default.
4.  In node we have a single thread to handle all requests.
5.  it is used in production in big companies like paypal, uber, netflix, walmart
-> In payPal company they rebuild their backend services from java springboot to node js. and they found that the node application 
was build twice as fast with lower peoples. with 33% fewer lines of code and 40% fewer files.and more importantly they doubled the 
requests serve per second.
while decreasing the average response time with 35%  
-> so node is great choice for building highly scalable apps.
3. Javascript everywhere: so if you are a frontend developer who knows js you can reuse js skills to become fullstack developer.
4. Cleaner and more consistent codebase.
5. It has a large ecosystem of open source libraries.

