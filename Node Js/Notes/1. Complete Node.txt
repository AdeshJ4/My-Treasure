Q] What is Node js ? 
====================

->Node is not a programmong language nor its a framework it is just a open sourse, cross platform runtime environment for executing js code outside a broswer.

-> we use Node js to build backend services also calle APIs.

APIs : 

-> API Stands for "Application Programming Interface".
-> The API acts as middleware or bridge between the frontend(client-side applications) and backend(server-side applications or services).
-> It defines a set of rules and protocols for how the frontend can communicate with the backend
-> It provides a structured way for the frontend to request specific operations from the backend.
-> When the frontend needs to interact with the backend, it sends API requests. These requests specify the desired action (e.g., fetching data, updating records) and may include additional information.
-> In the backend, The backend processes these requests, performs the necessary operations, and sends back API responses containing the results.
> In summary, APIs serve as a bridge between the frontend and backend, allowing them to communicate in a standardized and structured manner.


Q] Node Architecture: 
=====================

-> upto 2009 only way to executing js code was inside a browser.  A browser provide a runtime environment for js code.
-> so every browser have "JS Engine" that takes our js code and converts it  into machine code that computer understand.
-> Micosoft edge uses chakra, firefox uses SpiderMonkey and chrome uses V8 and because of this verieties of "JS ENGINE" sometimes the js code can behave differntly browser to browser.
->In 2009,Ryan Dahl the creator of node came up with brilliant idea. He took google v8 engine which is the fastest js engine out there and embedded it inside a c++ progeam and called that  program  Node.exe means Node. 
-> so similaer to browser, Node became runtime environment for js code. 
-> Node contain js engine, with certain objects which provides an environemnt for executing our js code.
-> for ex we don't have document object like "document.getElementById('')" in a node instead we have different objets that gives us more intersting capabilities. for ex we can work with file system like "fs.readFile()" listen for request like "http.createServer()" in a given port. and so on we can't do this kind of stuf inside a browser.
-> In summary Node is a program that contain chrome v8 engine plus some additional modules which gave us some capabilities not available inside a broswer.
-> we can work with file system , network and so on..
-> Both  chrome and node share same V8 engine but they provide different runtime environment for js code to run.



Q] How Node js Works: 
=====================

-> In a synchronous architecture, when we receive a request on a server, we allocate a thread to handle that request. suppose that request is querring a database. as you know querring a database may takes some time for returning a result.
-> so When database is executing a query that thread is sitting ideal. 
-> Now suppose another request comes at that point then we have to allocate another thread for a new request.
-> Now imagine, what will happen, if we have a server with lots of no of concueernt requests/clients.
-> At some time we will out of threads beecause there are lots of cuncurrrent requets.
-> so new client or request have to wait until threads are available or if we don't want to wait them we need to add more hardware. so with this kind of architecture we are not utilizing resourses efficiently this is a problem with  blocking or synchronous architecture. this is how applications are build with framewoks like ASP.NET. works by default. ofcourse in ASP.net it is possible to use asynchronous architecture but you have to do extra work for that

-> Node applcaitions are Asynchronous by default.
-> In node we have a single thread to handle all requests.
-> In Aynchronous architecture, When a request arrives on a server, Node assign single thread to handle that request. suppose that request is querring a database. as you know querring a database may takes some time for returning a result but important point is that our thread doesn't have to wait for database to return a data. while the database is executing query that thread is used to serve another client/request.
-> When our asynchronous task completes in our case asynchronous task is fetching data from databse, database puts the message in what we called "Event Queue".
-> Node is continuously monitoring queuse in background. when Node found event in this event queue node will take out that event or data and process it. 
-> This kind of architecture make a node ideal for building applications which includes lots of disk or network access like I/O-intensive apps.
-> we can serve more clients without the need of using more hardware. and that why node application higly scalable.
-> In contrast Node should not be used for CPU intensive apps like a video encoding or image manipulations servises. In this kind of applications we have a lots of calculatios that should be done by CPU  and few operations touch the file system or the netwok. 
-> Since Node applcaitions are single threaded when performing calculations to serve one client other clients have to wait and thats why node should not be used for CPU intensive applications. it should only be used for data intensive and real time applications. 


Q] why we use single thread in Node js?
==========================================

-> To maximize efficiency in handling I/O operations. 
-> This allows it to handle many concurrent requets without the overhead of managing multiple threads. 


list of I/O operations: 
-> In Node.js, I/O (Input/Output) operations are how you handle data exchange with external entities, such as files, networks, databases, and more. Here are some common I/O operations in Node.js:

1. File System Operations:
const fs = require('fs');
// Reading a file
fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
// Writing to a file
fs.writeFile('example.txt', 'Hello, Node.js!', (err) => {
  if (err) throw err;
  console.log('File written successfully.');
});


2. Network Operations
const http = require('http');
// Creating an HTTP server
const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Hello, Node.js!');
})
server.listen(3000, 'localhost', () => {
  console.log('Server listening on port 3000');
});


3. Database Operations
const { MongoClient } = require('mongodb');
const uri = 'mongodb://localhost:27017'; // Replace with your MongoDB connection string
cost client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });
async function connectToDatabase() {
  try {
    await client.connect();
    console.log('Connected to MongoDB');

    // Perform MongoDB CRUD operations here

  } catch (error) {
    console.error('Error connecting to MongoDB:', error.message);
  } finally {
    // Ensure the database connection is closed when operations are done
    await client.close();
    console.log('Disconnected from MongoDB');
  }
}








Q] There are also other languages to build back-end services like ASP.NET, java then why Node ?
===============================================================================================


1.  Node is easy to started.
2.  Superfast and highly scalable servises
3.  Node applcaitions are Asynchronous by default.
4.  In node we have a single thread to handle all requests.
5.  it is used in production in big companies like paypal, uber, netflix, wallmart
-> In payPal company they rebuild their backend services from java springboot to node js. and they found that the node application was build twice as fast with lower peoples. with 33% fewer lines of code and 40% fewer files.and more importantly they doubled the requests serve per second.
while decreasing the average response time with 35%  
-> so node is great choice for building highly scalable apps.
3. Javascript everywhere: so if you are a frontend developer who knows js you can reuse js skills to become fullstack developer.
4. Cleaner and more consistent codebase.
5. It has a large ecosystem of open source libraries.

