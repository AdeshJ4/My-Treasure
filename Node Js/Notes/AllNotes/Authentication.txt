We are going to provide some endpoints which will help the user to register themselves  and then login. 
Once they login they can use access token and then with the help of that token they can manage their contacts.


Authentication and Authorization:
---------------------------------

1. Authentication: 

-> The process of verifying a user's identity .  It involves validating their email/password.


2. Authorization:

-> it is process of determining if the user has permission to perform a given operation.




JWT Token :
-----------

-> In JWT (JSON Web Token), a token is a string that contains encoded information about a user that is used for authentication and authorization purposes.
Ex. token looks like this :  
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IkFkZXNoIiwiZW1haWwiOiJhZGVqYWQxMjM0QGdtYWlsLmNvbSJ9LCJpYXQiOjE2Nzg3NzA2NTUsImV4cCI6MTY3ODc3MDk1NX0.0CmG7Ykj69lK0EbUtShPBbAV6pyKefSYKRZNUqJGTZU"

-> The token is made up of three parts: a header, a payload, and a signature. 

1. HEADER: ALGORITHM & TOKEN TYPE

{
  "alg": "HS256",
  "typ": "JWT"
}

2. PAYLOAD:DATA

{
  "user": {
    "id": 1,
    "username": "Adesh",
    "email": "adejad1234@gmail.com"
  },
  "iat": 1678770655,
  "exp": 1678770955
}

3. VERIFY SIGNATURE

HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),your-256-bit-secret) secret base64 encoded


-> The token is signed using a secret key that only the server knows, which ensures that the data cannot be tampered with or modified.
This signature is created by combining the header and payload with the secret key using a cryptographic algorithm.

-> Once the token is created, it can be sent to the client and stored in a cookie or local storage. On subsequent requests, the 
client can send the token back to the server in the HTTP headers to authenticate and authorize the user.









several ways to send and receive tokens between the frontend and backend:
------------------------------------------------------------------------


1️⃣. Using HTTP Headers (Most Common)
This is the most secure and widely used method for sending tokens.

How It Works:
The frontend includes the token in the HTTP headers of the request.

The backend extracts the token from the headers.

Example (Frontend):
---
fetch("/api/protected-route", {
  method: "GET",
  headers: {
    "x-auth-token": "your-jwt-token-here", // Custom header
  },
});
---

Example (Backend):
---
const token = req.header("x-auth-token"); // Extract token from header
---

Pros:
Flexibility: You can name the header whatever you want (e.g., x-auth-token, x-access-token).
Simple: Easy to implement and understand.

Cons:
Non-Standard: Custom headers are not part of the HTTP/1.1 specification, so they might not be recognized by all tools or frameworks.
Less Semantic: Custom headers don't convey the purpose of the header as clearly as standard headers.




2️⃣. Using Authorization Header (Standard)
This is a standardized way of sending tokens, often used with Bearer tokens.
The word "Bearer" indicates that whoever holds (bears) the token can access the associated resources, provided the token is valid.
A Bearer Token is a cryptic string (usually a JWT) that represents the authorization granted to the client.

How It Works:
The frontend sends the token in the Authorization header with the Bearer scheme.

The backend extracts the token from the Authorization header.

Example (Frontend):
---
fetch("/api/protected-route", {
  method: "GET",
  headers: {
    Authorization: "Bearer your-jwt-token-here", // Standard header
  },
});
---

Example (Backend):
---
const token = req.header("Authorization").split(" ")[1]; // Extract token
---

Pros:
Standard Compliance: Follows the HTTP/1.1 specification for authentication.
Widely Supported: Recognized by most frameworks, libraries, and tools.
Semantic: Clearly indicates that the header is used for authentication.

Cons:
Less Flexibility: You must use the Authorization header and the Bearer scheme.




3️⃣. Using Cookies (Secure and HttpOnly)
Cookies are another common way to handle tokens, especially for session-based authentication.

How It Works:
The backend sets the token in an HttpOnly cookie when the user logs in.

The frontend automatically includes the cookie in subsequent requests.

The backend reads the token from the cookie.

Example: 

login route:
---
res.cookie("token", "your-jwt-token-here", {
  httpOnly: true, // Prevents client-side JavaScript from accessing the cookie
  secure: true, // Ensures the cookie is only sent over HTTPS
});
---

Middleware:
---
async function validateToken(req, res, next) {
    const {token} = req.cookies;

    if(!token) return handleResponse({res, status: 401,success: false, message: 'Unauthorized user. Access denied. No token provided'});

    try{  
        const decoded = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET_KEY);
        req.user = decoded;
        next();
    }catch(err){
        return handleResponse({res, status: 401, message: 'Invalid token', success: false})
    }
}
---

Why It’s Popular:
Security: HttpOnly and Secure flags protect the token from XSS and MITM attacks.
Automatic Handling: Cookies are automatically sent with every request to the same domain.





4️⃣. Using URL Query Parameters (Not Recommended) 🚫
This method involves passing the token as a query parameter in the URL.

How It Works:
The frontend includes the token in the URL.

The backend extracts the token from the query parameters.

Example (Frontend):
---
fetch("/api/protected-route?token=your-jwt-token-here", {
  method: "GET",
});
---

Example (Backend):
---
const { token } = req.query; // Extract token from query
---

Why It’s Not Recommended:
Security Risk: URLs are logged in server logs, browser history, and proxy servers, exposing the token.
Length Limitations: URLs have length restrictions, which could truncate long tokens.




5️⃣. Using Request Body (For POST Requests Only):

This method involves sending the token in the request body, typically for POST requests.

How It Works:
The frontend includes the token in the request body.

The backend extracts the token from the body.

Example (Frontend):
---
fetch("/api/protected-route", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ token: "your-jwt-token-here" }),
});
---

Example (Backend):
---
const { token } = req.body; // Extract token from body
---

Why It’s Less Common:
Limited to POST: Cannot be used for GET requests.

Less Secure: The token is still exposed in the request, though not in the URL.



🚀 Which Method is Most Used?
Use the Authorization Header (Standard) for most cases, as it is standardized, widely supported, and semantically clear.

HTTP Headers (especially the Authorization header with Bearer tokens) are the most widely used method for sending tokens. 
They are secure, standardized, and supported by most frameworks and libraries.
Cookies are also popular, especially for session-based authentication, due to their built-in security features (HttpOnly, Secure).






=======================================================================================================================


Authentication Types: 
---

Authentication is a critical part of web development, and there are several methods to authenticate users.


1️⃣ Session-Based Authentication: 

Session-based authentication is a traditional method where the server maintains the user's state (session) after login.

How It Works:

Login:
The user sends their credentials (e.g., username and password) to the server.
The server verifies the credentials and creates a session for the user.
The session ID is stored in the server's memory or database and sent to the client as a cookie.

Subsequent Requests:
The client sends the session ID (cookie) with every request.
The server cheks the session ID to authenticate the user.

Logout:
The server destroys the session, and the client deletes the cookie.



Pros:
Simple: Easy to implement and understand.
Stateful: The server maintains the user's state, which can be useful for certain applications.

Cons:
Scalability Issues: Storing sessions on the server can be problematic for distributed systems.
Performance Overhead: Requires server-side storage and lookups for every request.
CSRF Vulnerability: Requires additional measures to prevent Cross-Site Request Forgery (CSRF) attacks.


code: 
```
const express = require("express");
const mongoose = require("mongoose");
const session = require("express-session");
const MongoStore = require("connect-mongo");
const bcrypt = require("bcryptjs");
const dotenv = require("dotenv");

dotenv.config();
const app = express();

// Middleware
app.use(express.json());

// MongoDB Connection
mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
    .then(() => console.log("MongoDB connected"))
    .catch(err => console.error(err));

/* 
Session Middleware (stores session in MongoDB)
What happens here?
express-session stores session data.
MongoStore saves sessions in MongoDB.
The session ID is stored in a cookie on the client.
*/
app.use(session({
    secret: process.env.SESSION_SECRET,  // Keep it secure
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({ mongoUrl: process.env.MONGO_URI }),  // Store in MongoDB
    cookie: { maxAge: 1000 * 60 * 60 } // 1 hour session
}));

// User Model
const UserSchema = new mongoose.Schema({
    username: String,
    email: String,
    password: String
});
const User = mongoose.model("User", UserSchema);

// Register Route
app.post("/register", async (req, res) => {
    const { username, email, password } = req.body;

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = new User({ username, email, password: hashedPassword });

    await user.save();
    res.status(201).json({ message: "User registered successfully" });
});

/*
Login Route (Session-Based)
🔹 What happens here?
Find the user in the database using email.
Compare the password using bcrypt.compare.
If valid, store user._id in req.session (creates a session).
Respond with success message.
🛠️ Session is now stored on the server, and the session ID is sent to the client in a cookie.
*/

app.post("/login", async (req, res) => {
    const { email, password } = req.body;
    const user = await User.findOne({ email });

    if (!user || !(await bcrypt.compare(password, user.password))) {
        return res.status(400).json({ message: "Invalid credentials" });
    }

    req.session.userId = user._id;  // Store user ID in session
    res.json({ message: "Logged in successfully" });
});

// Logout Route
app.post("/logout", (req, res) => {
    req.session.destroy(() => {
        res.json({ message: "Logged out successfully" });
    });
});

app.get("/session", (req, res) => {
    res.json({ sessionId: req.sessionID });
});


// Authentication Middleware
const authMiddleware = (req, res, next) => {
    if (!req.session.userId) {
        return res.status(401).json({ message: "Unauthorized" });
    }
    next();
};

// Protected Route (Only logged-in users can access)
app.get("/profile", authMiddleware, async (req, res) => {
    const user = await User.findById(req.session.userId);
    res.json({ message: "Welcome to your profile", user });
});

// Start Server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

```

env: 
```
MONGO_URI=mongodb://localhost:27017/auth_db
SESSION_SECRET=supersecretkey
PORT=5000
```




------------------------



2️⃣. Token-Based Authentication:

Token-based authentication is a stateless method where the server issues a token (e.g., JWT) after login, and the client sends this token with every request.

How It Works:

Login:
The user sends their credentials to the server.
The server verifies the credentials and issues a token (e.g., JWT) containing user information and an expiration time.

Subsequent Requests:
The client sends the token in the Authorization header.
The server validates the token and grants access if it's valid.

Logout:
The client deletes the token (no server-side action is needed since tokens are stateless).



Pros:
Stateless: No need to store session data on the server.
Scalable: Works well in distributed systems.
Flexible: Tokens can include additional data (e.g., roles, permissions).

Cons:
Token Size: Tokens can be larger than session IDs, increasing request size.
Security: Tokens must be securely stored on the client side to prevent theft.



3️⃣. OAuth (Open Authorization)
OAuth is a protocol that allows third-party applications to access user data without exposing their credentials.

How It Works:

Authorization Request:
The client redirects the user to the OAuth provider (e.g., Google, Facebook).
The user logs in and grants permission to the client.

Authorization Grant:
The OAuth provider sends an authorization code to the client.

Token Exchange:
The client exchanges the authorization code for an access token.

Access Resource:
The client uses the access token to access the user's resources.


Pros:
Security: No need to share user credentials with third-party apps.
Standardized: Widely supported by major platforms (e.g., Google, Facebook).

Cons:
Complexity: More complex to implement than session or token-based authentication.
Overhead: Requires additional requests for token exchange.





4. API Keys
API keys are simple tokens used to authenticate clients accessing an API.

How It Works:

Client Registration:
The client registers with the server and receives an API key.

API Requests:
The client sends the API key with every request (e.g., in the header or query parameters).

Server Validation:
The server validates the API key and grants access if it's valid.


Pros:
Simple: Easy to implement and use.
Lightweight: No need for complex protocols.

Cons:
Security: API keys can be easily exposed if not handled properly.
Limited Scope: Suitable only for simple use cases (e.g., machine-to-machine communication).




🚀 Which One Should You Use?
Session-Based Authentication: Use for traditional web applications where server-side state is manageable.
Token-Based Authentication: Use for APIs, SPAs, and mobile apps where scalability and statelessness are important.
OAuth: Use for third-party integrations (e.g., "Login with Google").
API Keys: Use for simple machine-to-machine communication.





=================================================================================================================================================================================






JSON Web Token (JWT):
---------------------

- A JSON Web Token (JWT) is a JSON object encoded as a long string. We use 
them to identify users. It’s similar to a passport or driver’s license. It includes a 
few public properties about a user in its payload. These properties cannot be 
tampered because doing so requires re-generating the digital signature. 
- When the user logs in, we generate a JWT on the server and return it to the 
client. We store this token on the client and send it to the server every time we 
need to call an API endpoint that is only accessible to authenticated users.
-To generate JSON Web Tokens in an Express app use jsonwebtoken package.





what do you mean by "To hash passwords, use bcrypt"
---------------------------------------------------

"To hash passwords, use bcrypt" means that when storing passwords in a database, it is important to hash them for security reasons, 
and the recommended way to do this is using the bcrypt algorithm. Hashing a password means converting the password into a 
fixed-length string of characters that cannot be easily reversed, making it more difficult for attackers to access user accounts 
even if they gain access to the password database.

Bcrypt is a popular and widely-used algorithm for password hashing because it is designed to be slow and resource-intensive, 
which makes it harder for attackers to crack the hash. It also includes features like salting (adding random data to the password 
before hashing) and configurable work factors (to adjust the computational cost of hashing), which further increase the security 
of the hash.

In summary, if you need to store passwords in a database, it is important to hash them using a secure algorithm like bcrypt to 
protect your users' data from unauthorized access.



Hashing Passwords

When you hash a password using a function like "bcrypt.hash", you're converting the password into a fixed-length string of characters. 
This process is one-way, meaning that it's computationally infeasible (गणनात्मकदृष्ट्या अशक्य) to reverse the hash back into the original password. 
The hash is generated using a cryptographic algorithm (Bcrypt is a popular and widely-used algorithm) that includes a salt, which is a random value that ensures even 
if two users have the same password, their hashes will be different.
code: 
const salt = await bcrypt.genSalt(10);
const hashedPassword = await bcrypt.hash(password, salt);


Comparing Hashes:
When a user logs in, you need to verify that the password they entered matches the hashed password stored in your database. However, since the hash is one-way, you 
can't simply "reverse" the hash to compare the original passwords. Instead, you use the "bcrypt.compare" function to perform the comparison.

Here's how it works:
1. User Enters Password: When the user logs in, they provide their password.
2. Retrieve Hashed Password: You retrieve the hashed password from your database for that user.
3. Re-hash the Entered Password: The bcrypt.compare function takes the plaintext password entered by the user and re-hashes it using the same salt that was used to create 
the original hash. This is possible because the salt is stored as part of the hashed password string in the database.
4. Compare Hashes: The function then compares the newly generated hash with the stored hash. If they match, it means the entered password is correct.


📄 How Does bcrypt Store the Salt?
When you hash a password with bcrypt, the resulting hash includes:

The algorithm identifier (e.g., $2b$).
The cost factor (e.g., 10).
The salt (22 characters).
The hashed password (31 characters).

For example:

token> $2b$10$nOUIs5kJ7naTuTFkBy1veuK0kSxUFXfuaOKdOKf9xYT0KKIGSJwFa

$2b$ = algorithm identifier.
10 = cost factor.
nOUIs5kJ7naTuTFkBy1veu = salt.
K0kSxUFXfuaOKdOKf9xYT0KKIGSJwFa = hashed password.

This means the salt is embedded in the hash, so you don't need to store it separately. When you compare a password using bcrypt.compare, it extracts the salt from the 
stored hash and uses it to re-hash the input password for comparison



👉 What Happens During Password Comparison?

When you use bcrypt.compare, the following steps occur:

1. Extract the Salt: The salt is extracted from the stored hashed password (since the salt is embedded in the hash).
2. Re-hash the Input Password: The plaintext password provided by the user is combined with the extracted salt and hashed using the same algorithm and cost factor.
3. Compare Hashes: The newly generated hash is compared to the stored hash. If they match, the password is correct.


🚀 What if an Attacker Extracts the Salt?
If an attacker extracts the salt from the hashed password, they still face significant challenges in cracking the password. Here's why:

a. The Salt is Unique per Password
Each password has a unique salt, so even if the attacker extracts the salt for one user, it won't help them crack another user's password (unless they use the same 
password, which is unlikely).

b. The Salt Doesn't Reveal the Password
The salt is just a random string. Knowing the salt doesn't give the attacker any information about the password itself. They still need to guess the password.

c. Brute-Forcing is Still Hard
Even with the salt, the attacker would need to:

1. Guess the password (e.g., through a brute-force or dictionary attack).
2. Combine the guessed password with the extracted salt.
3. Hash the result using the same algorithm and cost factor.
4. Compare the generated hash to the stored hash.

This process is computationally expensive because:

1. bcrypt is designed to be slow (due to the cost factor).
2. The attacker would need to repeat this process for every possible password guess.


🚀 Why is bcrypt Secure Even if the Salt is Known?
The security of bcrypt doesn't rely on keeping the salt secret. Instead, it relies on:
1. The Slowness of the Algorithm: The cost factor makes bcrypt intentionally slow, so brute-forcing is infeasible.
2. The Uniqueness of the Salt: Even if two users have the same password, their hashes will be different due to the unique salts.
3. The One-Way Nature of Hashing: It's computationally infeasible to reverse the hash to get the original password.



code: 
if (  userAvailable &&  (await bcrypt.compare(password, userAvailable.password))) {
  const token = userAvailable.generateToken();
  return res.status(200).send(token);
}

userSchema.methods.generateToken = function () {
  const token = jwt.sign(
    { _id: this._id, userName: this.name, isAdmin: this.isAdmin },
    config.get("jwtPrivateKey"),
    { expiresIn: "2 days" }
  );

  return token;
};




🚀 What is Hashing?
Hashing is the process of converting a password (or any input) into a fixed-length string of characters using a cryptographic hash function. 
The output (the hash) is unique to the input, and the process is one-way, meaning you cannot reverse the hash to get the original password.


🚀 What is a Salt?
A salt is a random string of data that is added to a password before it is hashed. 
it means that the salt is combined with the password, and the resulting combination is then hashed.
This process ensures that the final hashed password is unique and secure, even if two users have the same password.
The purpose of a salt is to ensure that even if two users have the same password, their hashed passwords will be different. 
This makes it much harder for attackers to use precomputed tables (like rainbow tables) to crack passwords.

Key Properties of a Salt:
Uniqueness: Each password should have a unique salt.
Randomness: The salt should be generated using a cryptographically secure random number generator.
Length: Salts are typically long enough to ensure uniqueness (e.g., 16 bytes or more).







📄 What is bcrypt.genSalt?
bcrypt.genSalt is a function provided by the bcrypt library that generates a random salt. 
It takes an optional parameter called the cost factor (or work factor), which determines how computationally expensive the hashing process will be.
Example:
const salt = await bcrypt.genSalt(10);

The 10 here is the cost factor. It controls "how many iterations of the hashing algorithm are performed". 
A higher cost factor makes the hashing process slower and more resource-intensive, which is good for security because it makes brute-force attacks harder.


📄 What Happens if You Don't Provide a Salt?
If you don't provide a salt when hashing a password, bcrypt will automatically generate one for you. This is why the following code works:

const hashedPassword = await bcrypt.hash(password, 10);
Here, 10 is the cost factor, and bcrypt will internally generate a salt for you.

However, if you explicitly generate a salt using bcrypt.genSalt, you can control the cost factor and reuse the same salt for multiple operations if needed 
(though this is generally not recommended for password hashing).


📄 Why is a Salt Important?
Without a salt, password hashing becomes vulnerable to certain types of attacks:

1. Rainbow Table Attacks:
A rainbow table is a precomputed table of hashes for common passwords. If two users have the same password, their hashes will be identical. 
An attacker can use a rainbow table to quickly look up the original password from the hash.
A salt ensures that even if two users have the same password, their hashes will be different, making rainbow tables useless.

2. Dictionary Attacks:
Without a salt, an attacker can precompute hashes for a list of common passwords and compare them directly to the hashes in your database.
A salt forces the attacker to recompute hashes for every possible salt value, making the attack much slower and more resource-intensive.





📄 What Happens if You Don't Use a Salt?

If you don't use a salt:

Identical Passwords = Identical Hashes: If two users have the same password, their hashes will be identical. This makes it easier for attackers to identify common passwords.
Vulnerability to Rainbow Tables: Attackers can use precomputed tables of hashes for common passwords to quickly crack the passwords.









































































