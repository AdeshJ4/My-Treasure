Here’s a list of **important HTTP status codes** commonly used in **Node.js** applications (especially REST APIs):

---

### ✅ **1xx – Informational**
| Code | Meaning                  | Description                                  |
|------|--------------------------|----------------------------------------------|
| 100  | Continue                 | Initial part of request received; continue.  |

---

### ✅ **2xx – Success**
| Code | Meaning                  | Description                                  |
|------|--------------------------|----------------------------------------------|
| 200  | OK                       | Successful request.                          |
| 201  | Created                  | Resource successfully created.               |
| 204  | No Content               | Success, but no content to return.           |


✅ HTTP Status Code 204 – No Content
📘 Meaning:
The server successfully processed the request, but there's no content to send in the response.
🔄 When to Use It:
Scenario	                              Description
✅ DELETE request	                    Resource was deleted, nothing else to return
✅ PUT/PATCH request	                    Update was successful, no new content to send
✅ Form submission (no page reload)	    Just want to signal success
✅ Background actions	                When action succeeds but client doesn’t need data


---


### ⚠️ **3xx – Redirection**
| Code | Meaning                  | Description                                  |
|------|--------------------------|----------------------------------------------|
| 301  | Moved Permanently        | Resource moved to a new URL permanently.     |
| 302  | Found                    | Temporary redirect.                          |
| 304  | Not Modified             | Use cached version.                          |


🔁 301 – Moved Permanently
Meaning: The requested resource has been permanently moved to a new URL.

Usage:

Typically used for SEO and URL redirection.
Browsers and search engines will update bookmarks and indexes to the new location.

```
HTTP/1.1 301 Moved Permanently
Location: https://new-url.com
```


🔁 302 – Found
Meaning: The resource is temporarily located at a different URL.

Usage:

Often used when a resource has moved temporarily and may return to the original URL.
The browser will redirect automatically to the URL specified in the Location header.
Note: Originally intended for GET requests, but it can sometimes cause unexpected behavior with POST requests (use 307/308 instead in those cases).
Example: Redirecting to a login page when the user is not authenticated.
```
HTTP/1.1 302 Found
Location: https://temporary-redirect.com
```


🔁 304 – Not Modified
Meaning: The resource has not changed since the last request. Use the cached version.

The client (like your browser) makes a request with headers like:
If-Modified-Since
or If-None-Match (used with ETag)

The server checks if the resource has changed:
If it has changed, it sends back 200 OK with the new data.
If it hasn’t changed, it sends back 304 Not Modified with no body, telling the client:
“You already have the latest version in your cache — just use that.”




---

### ❌ **4xx – Client Errors**
| Code | Meaning                  | Description                                  |
|------|--------------------------|----------------------------------------------|
| 400  | Bad Request              | Invalid request (missing/invalid params).    |
| 401  | Unauthorized             | Authentication required.                     |
| 403  | Forbidden                | Authenticated but not allowed.               |
| 404  | Not Found                | Resource not found.                          |
| 409  | Conflict                 | Conflict with existing resource (e.g., duplicate email). |
| 429  | Too Many Requests        | The client has sent too many requests in a given amount of time (rate limiting).    |



⚠️ 409 – Conflict
Meaning: The request could not be completed due to a conflict with the current state of the resource.

Usage:
Commonly used when trying to create a resource that already exists, violating uniqueness constraints (e.g., duplicate email, username).
Also used when two users attempt to update the same resource simultaneously, causing a versioning conflict.


🔁 HTTP Status Code 429 – Too Many Requests
✅ Meaning:
The client has sent too many requests in a given amount of time (rate limiting).
This status is used to protect the server from being overloaded by clients or bots.



---

### 💥 **5xx – Server Errors**
| Code | Meaning                  | Description                                  |
|------|--------------------------|----------------------------------------------|
| 500  | Internal Server Error    | Generic server error.                        |
| 502  | Bad Gateway              | Invalid response from upstream server.       |
| 503  | Service Unavailable      | Server is down or overloaded.                |
| 504  | Gateway Timeout          | Timeout from upstream server.                |


💥 HTTP Status Code 500 – Internal Server Error
📘 Meaning:
The server encountered an unexpected condition that prevented it from fulfilling the request.
It's a generic catch-all error when the server knows something went wrong, but isn’t sure what exactly or doesn't want to expose 
the internal details.


🚧 502 – Bad Gateway
Meaning: The server (acting as a gateway or proxy) received an invalid response from an upstream server.

Usage:
Happens in systems where there are multiple layers, like:
Nginx → Node.js app
Load balancer → Backend service
If the backend crashes, times out, or returns a bad response, the gateway (e.g., Nginx) returns 502.


🛑 503 – Service Unavailable
Meaning: The server is temporarily unavailable due to being down, overloaded, or under maintenance.

Usage:

Indicates that the server cannot handle the request right now, but it might become available later.

Often includes a Retry-After header to tell the client when to try again.

Example: During server maintenance, or when a server is overloaded with too many requests.
```
HTTP/1.1 503 Service Unavailable
Retry-After: 120
```
This means: “Service is down. Try again in 120 seconds.”







============================================================================================================================================================





We are going to provide some endpoints which will help the user to register themselves  and then login. 
Once they login they can use access token and then with the help of that token they can manage their contacts.


Authentication and Authorization:
---------------------------------

1. Authentication: 

-> The process of verifying a user's identity .  It involves validating their email/password.


2. Authorization:

-> it is process of determining if the user has permission to perform a given operation.




JWT Token :
-----------

-> In JWT (JSON Web Token), a token is a string that contains encoded information about a user that is used for authentication and authorization purposes.
Ex. token looks like this :  
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoxLCJ1c2VybmFtZSI6IkFkZXNoIiwiZW1haWwiOiJhZGVqYWQxMjM0QGdtYWlsLmNvbSJ9LCJpYXQiOjE2Nzg3NzA2NTUsImV4cCI6MTY3ODc3MDk1NX0.0CmG7Ykj69lK0EbUtShPBbAV6pyKefSYKRZNUqJGTZU"

-> The token is made up of three parts: a header, a payload, and a signature. 

1. HEADER: ALGORITHM & TOKEN TYPE

{
  "alg": "HS256",
  "typ": "JWT"
}

2. PAYLOAD:DATA

{
  "user": {
    "id": 1,
    "username": "Adesh",
    "email": "adejad1234@gmail.com",
    "role: 'admin'  
  },
  "iat": 1678770655,
  "exp": 1678770955
}

3. VERIFY SIGNATURE

HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),your-256-bit-secret) secret base64 encoded


-> The token is signed using a secret key that only the server knows, which ensures that the data cannot be tampered with or modified.
This signature is created by combining the header and payload with the secret key using a cryptographic algorithm.

-> Once the token is created, it can be sent to the client and stored in a cookie or local storage. 
On subsequent requests, the client can send the token back to the server in the HTTP headers to authenticate and authorize the user.


⭐ Here's how you can pass a JWT token from the client (React + Redux + Axios) to the server with each request.

🔐 Best Practices:
Never store JWTs in cookies without "HttpOnly + Secure flags".
Use interceptors so you don’t repeat token logic everywhere.
Handle 401/403 errors globally (like logout on token expiry).

✅ 1. Store the JWT securely
When the user logs in and you receive the token:
Use localStorage or sessionStorage (less secure)
```
localStorage.setItem("token", res.data.token);
```

✅ 2. Setup Axios to include JWT in headers

Option A: Add token manually on each request
```
const token = localStorage.getItem("token");
axios.get("/api/customers", {
  headers: {
    Authorization: `Bearer ${token}`,
  },
});
```

Option B: Use Axios Interceptors (recommended with Redux)
This is cleaner and ensures all requests automatically carry the token.
```
import axios from "axios";
const instance = axios.create({
  baseURL: "https://your-api-url.com/api",
});

instance.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default instance;
```

Then use this instance everywhere in your Redux thunks or components:
```
import axios from "../utils/axios"; // your custom instance
export const fetchUser = createAsyncThunk("user/fetch", async () => {
  const res = await axios.get("/user/me");
  return res.data;
});
```

Note: The "config" here is not a file — it's an "object" representing the "HTTP request" that Axios is about to send.

🔍 What is config?
It’s the Axios request configuration object. It includes:

url
method (GET, POST, etc.)
headers
data (for POST/PUT)
params (for query strings)
You can modify this config before the request goes out — for example, to add headers like a JWT token.








several ways to send and receive tokens between the frontend and backend:
------------------------------------------------------------------------


1️⃣. Using HTTP Headers (Most Common)
This is the most secure and widely used method for sending tokens.

How It Works:
The frontend includes the token in the HTTP headers of the request.

The backend extracts the token from the headers.

Example (Frontend):
---
fetch("/api/protected-route", {
  method: "GET",
  headers: {
    "x-auth-token": "your-jwt-token-here", // Custom header
  },
});
---

Example (Backend):
---
const token = req.header("x-auth-token"); // Extract token from header
---

Pros:
Flexibility: You can name the header whatever you want (e.g., x-auth-token, x-access-token).
Simple: Easy to implement and understand.

Cons:
Non-Standard: Custom headers are not part of the HTTP/1.1 specification, so they might not be recognized by all tools or frameworks.
Less Semantic: Custom headers don't convey the purpose of the header as clearly as standard headers.




2️⃣. Using Authorization Header (Standard)
This is a standardized way of sending tokens, often used with Bearer tokens.
The word "Bearer" indicates that whoever holds (bears) the token can access the associated resources, provided the token is valid.
A Bearer Token is a cryptic string (usually a JWT) that represents the authorization granted to the client.

How It Works:
The frontend sends the token in the Authorization header with the Bearer scheme.

The backend extracts the token from the Authorization header.

Example (Frontend):
---
fetch("/api/protected-route", {
  method: "GET",
  headers: {
    Authorization: "Bearer your-jwt-token-here", // Standard header
  },
});
---

Example (Backend):
---
const token = req.header("Authorization").split(" ")[1]; // Extract token
---

Pros:
Standard Compliance: Follows the HTTP/1.1 specification for authentication.
Widely Supported: Recognized by most frameworks, libraries, and tools.
Semantic: Clearly indicates that the header is used for authentication.

Cons:
Less Flexibility: You must use the Authorization header and the Bearer scheme.




3️⃣. Using Cookies (Secure and HttpOnly)
Cookies are another common way to handle tokens, especially for session-based authentication.

How It Works:
The backend sets the token in an HttpOnly cookie when the user logs in.
The frontend automatically includes the cookie in subsequent requests.
The backend reads the token from the cookie.

Example: 

login route:
---
res.cookie("token", "your-jwt-token-here", {
  httpOnly: true, // Prevents client-side JavaScript from accessing the cookie
  secure: true, // Ensures the cookie is only sent over HTTPS
});
---

Middleware:
---
async function validateToken(req, res, next) {
    const {token} = req.cookies;

    if(!token) return handleResponse({res, status: 401,success: false, message: 'Unauthorized user. Access denied. No token provided'});

    try{  
        const decoded = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET_KEY);
        req.user = decoded;
        next();
    }catch(err){
        return handleResponse({res, status: 401, message: 'Invalid token', success: false})
    }
}
---

Why It’s Popular:
Security: HttpOnly and Secure flags protect the token from XSS and MITM attacks.
Automatic Handling: Cookies are automatically sent with every request to the same domain.





4️⃣. Using URL Query Parameters (Not Recommended) 🚫
This method involves passing the token as a query parameter in the URL.

How It Works:
The frontend includes the token in the URL.

The backend extracts the token from the query parameters.

Example (Frontend):
---
fetch("/api/protected-route?token=your-jwt-token-here", {
  method: "GET",
});
---

Example (Backend):
---
const { token } = req.query; // Extract token from query
---

Why It’s Not Recommended:
Security Risk: URLs are logged in server logs, browser history, and proxy servers, exposing the token.
Length Limitations: URLs have length restrictions, which could truncate long tokens.




5️⃣. Using Request Body (For POST Requests Only):

This method involves sending the token in the request body, typically for POST requests.

How It Works:
The frontend includes the token in the request body.

The backend extracts the token from the body.

Example (Frontend):
---
fetch("/api/protected-route", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ token: "your-jwt-token-here" }),
});
---

Example (Backend):
---
const { token } = req.body; // Extract token from body
---

Why It’s Less Common:
Limited to POST: Cannot be used for GET requests.

Less Secure: The token is still exposed in the request, though not in the URL.



🚀 Which Method is Most Used?
Use the Authorization Header (Standard) for most cases, as it is standardized, widely supported, and semantically clear.

HTTP Headers (especially the Authorization header with Bearer tokens) are the most widely used method for sending tokens. 
They are secure, standardized, and supported by most frameworks and libraries.
Cookies are also popular, especially for session-based authentication, due to their built-in security features (HttpOnly, Secure).






=======================================================================================================================


Authentication Types: 
---

Authentication is a critical part of web development, and there are several methods to authenticate users.


1️⃣ Session-Based Authentication: 

Session-based authentication is a traditional method where the server maintains the user's state (session) after login.

How It Works:

Login:
1. The user sends their credentials (e.g., username and password) to the server.
2. The server verifies the credentials and creates a session for the user by Creates a session object and Stores it in memory/database.
ex: 
```
session object (e.g., { userId: 123 })
session ID, like sid=abc123xyz
````
3. The session ID is stored in the server's memory or database and sent to the client as a cookie.
Typically in memory, Redis, or a DB:
{
  abc123xyz: { userId: 123, role: 'admin' }
}
4. Server sends back session ID in a cookie
```
Set-Cookie: connect.sid=abc123xyz; Path=/; HttpOnly
```



Subsequent Requests:
The client sends the session ID (cookie) with every request.
```
Cookie: connect.sid=abc123xyz
```
The server cheks the session ID to authenticate the user.

Logout:
The server destroys the session, and the client deletes the cookie.


🔑 What is a Session ID?
A Session ID is a unique identifier that the server assigns to a user when they log in (or interact with the app for the first time). 
It's like giving each user their own ticket number so the server knows who they are on future requests.



🔒 Session ID Example (Express + express-session)
When you use this:
```
app.use(session({
  secret: 'your-secret-key',
  resave: false,
  saveUninitialized: false,
}));
```

The middleware:

Generates a session ID (like s%3Af9sW...)
Sends it to the browser as a cookie: connect.sid
Stores session data on the server in memory

✅ Purpose of "secret" key in session ():
This secret is used to sign the session ID cookie (connect.sid).
It ensures the session ID can't be tampered with on the client side.
So if someone tries to modify the cookie, the server can detect that it's invalid or fake.




🔐 Is it Secure?

HttpOnly: Prevents JavaScript from reading the cookie
Secure: Ensures it’s only sent over HTTPS
Signed: So clients can’t tamper with it
If someone steals the session ID, they can hijack your session — so always use HTTPS + proper cookie settings.





Pros:
Simple: Easy to implement and understand.
Stateful: The server maintains the user's state, which can be useful for certain applications.

Cons:
Scalability Issues: Storing sessions on the server can be problematic for distributed systems.
Performance Overhead: Requires server-side storage and lookups for every request.
CSRF Vulnerability: Requires additional measures to prevent Cross-Site Request Forgery (CSRF) attacks.


code: 
```
const express = require("express");
const mongoose = require("mongoose");
const session = require("express-session");
const MongoStore = require("connect-mongo");
const bcrypt = require("bcryptjs");
const dotenv = require("dotenv");

dotenv.config();
const app = express();

// Middleware
app.use(express.json());

// MongoDB Connection
mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
    .then(() => console.log("MongoDB connected"))
    .catch(err => console.error(err));

/* 
Session Middleware (stores session in MongoDB)
What happens here?
express-session stores session data.
MongoStore saves sessions in MongoDB.
The session ID is stored in a cookie on the client.
*/
app.use(session({
    secret: process.env.SESSION_SECRET,  // Keep it secure
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({ mongoUrl: process.env.MONGO_URI }),  // Store in MongoDB
    cookie: { maxAge: 1000 * 60 * 60 } // 1 hour session
}));

// User Model
const UserSchema = new mongoose.Schema({
    username: String,
    email: String,
    password: String
});
const User = mongoose.model("User", UserSchema);

// Register Route
app.post("/register", async (req, res) => {
    const { username, email, password } = req.body;

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = new User({ username, email, password: hashedPassword });

    await user.save();
    res.status(201).json({ message: "User registered successfully" });
});

/*
Login Route (Session-Based)
🔹 What happens here?
Find the user in the database using email.
Compare the password using bcrypt.compare.
If valid, store user._id in req.session (creates a session).
Respond with success message.
🛠️ Session is now stored on the server, and the session ID is sent to the client in a cookie.
*/

app.post("/login", async (req, res) => {
    const { email, password } = req.body;
    const user = await User.findOne({ email });

    if (!user || !(await bcrypt.compare(password, user.password))) {
        return res.status(400).json({ message: "Invalid credentials" });
    }

    req.session.userId = user._id;  // Store user ID in session
    res.json({ message: "Logged in successfully" });
});

// Logout Route
app.post("/logout", (req, res) => {
    req.session.destroy(() => {
        res.json({ message: "Logged out successfully" });
    });
});

app.get("/session", (req, res) => {
    res.json({ sessionId: req.sessionID });
});


// Authentication Middleware
const authMiddleware = (req, res, next) => {
    if (!req.session.userId) {
        return res.status(401).json({ message: "Unauthorized" });
    }
    next();
};

// Protected Route (Only logged-in users can access)
app.get("/profile", authMiddleware, async (req, res) => {
    const user = await User.findById(req.session.userId);
    res.json({ message: "Welcome to your profile", user });
});

// Start Server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

```

env: 
```
MONGO_URI=mongodb://localhost:27017/auth_db
SESSION_SECRET=supersecretkey
PORT=5000
```




------------------------



2️⃣. Token-Based Authentication:

Token-based authentication is a stateless method where the server issues a token (e.g., JWT) after login, and the client sends this token with every request.

How It Works:

Login:
The user sends their credentials to the server.
The server verifies the credentials and issues a token (e.g., JWT) containing user information and an expiration time.

Subsequent Requests:
The client sends the token in the Authorization header.
The server validates the token and grants access if it's valid.

Logout:
The client deletes the token (no server-side action is needed since tokens are stateless).



Pros:
Stateless: No need to store session data on the server.
Scalable: Works well in distributed systems.
Flexible: Tokens can include additional data (e.g., roles, permissions).

Cons:
Token Size: Tokens can be larger than session IDs, increasing request size.
Security: Tokens must be securely stored on the client side to prevent theft.





============================================================================================================================================================



## 🔐 Token-Based Auth vs Session-Based Auth

| ------------------------------ | ----------------------------------------------------------- | ----------------------------------------------------------------------- |
| Feature                        | Session-Based Authentication                                | Token-Based Authentication (JWT)                                        |
| ------------------------------ | ----------------------------------------------------------- | ----------------------------------------------------------------------- |
| Used in SPA / Mobile apps?     | Not ideal for mobile apps / SPAs                            | Perfect for SPAs and mobile apps                                        |
| Where is data stored?          | On the server (in-memory, Redis, or DB)                     | On the client (in a token, typically stored in localStorage or cookies) |
| How is user identified?        | Via a session ID cookie (`connect.sid`)                     | Via a token (usually JWT) sent with each request                        |
| Authentication state stored?   | Server-side                                                 | Client-side (token holds the user info and auth state)                  |
| Scalable?                      | Less scalable (server has to manage sessions for all users) | More scalable (no session tracking on server)                           |
| **Logout (token invalidation)? | Easy: server just deletes the session                       | Hard: must manage blacklist or change secret                            |
| Requires cookie?               | Yes (stores session ID)                                     | No, token is often sent in headers (but can use cookie too)             |
| Cross-Origin (CORS)?           | Trickier (cookie-based needs `withCredentials`)             | Easier (token sent in headers)                                          |
| Security                       | Safer from XSS (if HttpOnly cookies used)                   | Safer from CSRF (if token is in header, not cookie)                     |
| ------------------------------ | ----------------------------------------------------------- | ----------------------------------------------------------------------- |






============================================================================================================================================================



3️⃣. OAuth (Open Authorization)
OAuth is a protocol that allows third-party applications(Movify, vidly) to access user data of OAuth provider (facebook data) without exposing their 
credentials (username, passwords).

Example: You use your Google account to log into another website like Medium, Spotify, or a to-do app.

OAuth is primarily used for login purposes (Login with Google)

How It Works:

register your application with OAuth provider.


1. 🔑 Add Multiple OAuth Providers

if you're using Google OAuth, the user must have a Google account.


You can support:

Google
Facebook
GitHub
Twitter
Apple
Microsoft


Most Popular OAuth Packages
1. Passport.js (Most flexible)
The gold standard for authentication in Node.js
Works with any OAuth provider (Google, Facebook, GitHub, etc.)
passport + provider-specific strategy (e.g., passport-google-oauth20)

2. Firebase Auth (Easiest implementation)
Handles all OAuth flows for you
Provides SDKs for React and Node.js
firebase package

3. NextAuth.js (Great if using Next.js)
Simplified OAuth implementation






"Providing access to someone without exposing a password"
→ This is exactly what OAuth does. It uses access tokens instead of sharing login credentials like a password.

"Create an account in one application and use it in multiple applications without creating a password in those applications"
→ This describes SSO (Single Sign-On) using OAuth or OpenID Connect. 
You log in once via a central identity provider (e.g., Google, Facebook, Auth0), and use that identity to access other applications
 without registering separately or managing separate passwords.

OAuth is providing someone access without password , it is an open standard for authorization which aloow an third party 
application to go to an unauthorization provider on you behalf and get your data from their

You click "Sign in with Google" on a website (let's call it ExampleApp)
ExampleApp redirects you to Google's authorization page

Google shows a page asking: "ExampleApp wants to access your Google account"
It lists what information ExampleApp wants (e.g., your email, profile picture)


You review the permissions requested
You click "Allow" to grant access


Google sends an "authorization code" back to ExampleApp.
After you click "Allow" on Google's consent page, Google needs to send a temporary authorization code back to ExampleApp.
Google sends your browser to a special URL at ExampleApp, like:
https://exampleapp.com/auth/google/callback?code=A1B2C3D4E5...
(This code is the authorization code)
Your browser loads this URL, and the ExampleApp server sees the code in the address bar and extracts it.

ExampleApp exchanges this code with Google for an access token (behind the scenes)
Now, ExampleApp has the temporary code, but it needs a real access token to get your profile data. This happens behind the scenes between servers.
ExampleApp’s server sends a secret request to Google’s server (to a special Google API endpoint).
The request includes:
The temporary code (A1B2C3D4E5...)
ExampleApp’s client ID (like an ID card proving who they are)
ExampleApp’s client secret (a password only they know)
Google checks:
Is the code valid?
Does the client ID and client secret match what Google has on file?
If everything is correct, Google sends back an access_token (like a special key) to ExampleApp’s server.
Now, ExampleApp can use this access_token to ask Google for your email/profile (in the next step).

The client secret is private—it can’t be exposed in the browser.
Google needs to verify that only ExampleApp (not a hacker) can exchange the code.

ExampleApp checks if your email exists in their database:
If yes: logs you in
If no: creates a new account using your Google profile info, then logs you in


ExampleApp creates a session in your browser
You're now logged in and redirected to the main application


✅ Benefits of OAuth Login/Registration
🟢 No need to remember another password
🟢 Faster sign-up process (no forms to fill)
🟢 More secure (website never sees your actual Google/Facebook password)
🟢 Trusted by users (they recognize the provider's login page)
🟢 Most modern websites implement OAuth alongside traditional login to give users both options.





============================================================================================================================================================



4. API Keys
API keys are simple tokens used to authenticate clients accessing an API.

How It Works:

Client Registration:
The client registers with the server and receives an API key.

API Requests:
The client sends the API key with every request (e.g., in the header or query parameters).

Server Validation:
The server validates the API key and grants access if it's valid.


Pros:
Simple: Easy to implement and use.
Lightweight: No need for complex protocols.

Cons:
Security: API keys can be easily exposed if not handled properly.
Limited Scope: Suitable only for simple use cases (e.g., machine-to-machine communication).




🚀 Which One Should You Use?
Session-Based Authentication: Use for traditional web applications where server-side state is manageable.
Token-Based Authentication: Use for APIs, SPAs, and mobile apps where scalability and statelessness are important.
OAuth: Use for third-party integrations (e.g., "Login with Google").
API Keys: Use for simple machine-to-machine communication.





=================================================================================================================================================================================






JSON Web Token (JWT):
---------------------

- A JSON Web Token (JWT) is a JSON object encoded as a long string. We use 
them to identify users. It’s similar to a passport or driver’s license. It includes a 
few public properties about a user in its payload. These properties cannot be 
tampered because doing so requires re-generating the digital signature. 
- When the user logs in, we generate a JWT on the server and return it to the 
client. We store this token on the client and send it to the server every time we 
need to call an API endpoint that is only accessible to authenticated users.
-To generate JSON Web Tokens in an Express app use jsonwebtoken package.
jwt.sign(user data, JwtKey, exprriIn)
jwt.verify(token, jwtKey)

becryptjs.hash(pwd, salt)
bcryptjs.compare(pwd, user.pwd)



what do you mean by "To hash passwords, use bcrypt"
---------------------------------------------------

"To hash passwords, use bcrypt" means that when storing passwords in a database, it is important to hash them for security reasons, 
and the recommended way to do this is using the bcrypt algorithm. Hashing a password means converting the password into a 
fixed-length string of characters that cannot be easily reversed, making it more difficult for attackers to access user accounts 
even if they gain access to the password database.

Bcrypt is a popular and widely-used algorithm for password hashing because it is designed to be slow and resource-intensive, 
which makes it harder for attackers to crack the hash. It also includes features like salting (adding random data to the password 
before hashing) and configurable work factors (to adjust the computational cost of hashing), which further increase the security 
of the hash.

In summary, if you need to store passwords in a database, it is important to hash them using a secure algorithm like bcrypt to 
protect your users' data from unauthorized access.



Hashing Passwords

When you hash a password using a function like "bcrypt.hash", you're converting the password into a fixed-length string of characters. 
This process is one-way, meaning that it's computationally infeasible (गणनात्मकदृष्ट्या अशक्य) to reverse the hash back into the original password. 
The hash is generated using a cryptographic algorithm (Bcrypt is a popular and widely-used algorithm) that includes a salt, which is a random value that ensures even 
if two users have the same password, their hashes will be different.
code: 
const salt = await bcrypt.genSalt(10);
const hashedPassword = await bcrypt.hash(password, salt);


Comparing Hashes:
When a user logs in, you need to verify that the password they entered matches the hashed password stored in your database. 
However, since the hash is one-way, you  can't simply "reverse" the hash to compare the original passwords. 
Instead, you use the "bcrypt.compare" function to perform the comparison.

Here's how it works:
1. User Enters Password.
2. You get stored hashed password from your database for that user.
3. The bcrypt.compare function takes the plaintext password entered by the user and re-hashes it using the same salt that was used to create 
the original hash. This is possible because the salt is stored as part of the hashed password string in the database.
4. Compare Hashes: The function then compares the newly generated hash with the stored hash. If they match, it means the entered password is correct.


📄 How Does bcrypt Store the Salt?
When you hash a password with bcrypt, the resulting hash includes:

The algorithm identifier (e.g., $2b$).
The cost factor (e.g., 10).
The salt (22 characters).
The hashed password (31 characters).

For example:

token> $2b$10$nOUIs5kJ7naTuTFkBy1veuK0kSxUFXfuaOKdOKf9xYT0KKIGSJwFa

$2b$ = algorithm identifier.
10 = cost factor.
nOUIs5kJ7naTuTFkBy1veu = salt.
K0kSxUFXfuaOKdOKf9xYT0KKIGSJwFa = hashed password.

This means the salt is embedded in the hash, so you don't need to store it separately. When you compare a password using bcrypt.compare, it extracts the salt from the 
stored hash and uses it to re-hash the input password for comparison



👉 What Happens During Password Comparison?

When you use bcrypt.compare, the following steps occur:

1. Extract the Salt: The salt is extracted from the stored hashed password (since the salt is embedded in the hash).
2. Re-hash the Input Password: The plaintext password provided by the user is combined with the extracted salt and hashed using the same algorithm and cost factor.
3. Compare Hashes: The newly generated hash is compared to the stored hash. If they match, the password is correct.


🚀 What if an Attacker Extracts the Salt?
If an attacker extracts the salt from the hashed password, they still face significant challenges in cracking the password. Here's why:

a. The Salt is Unique per Password
Each password has a unique salt, so even if the attacker extracts the salt for one user, it won't help them crack another user's password (unless they use the same 
password, which is unlikely).

b. The Salt Doesn't Reveal the Password
The salt is just a random string. Knowing the salt doesn't give the attacker any information about the password itself. They still need to guess the password.

c. Brute-Forcing is Still Hard
Even with the salt, the attacker would need to:

1. Guess the password (e.g., through a brute-force or dictionary attack).
2. Combine the guessed password with the extracted salt.
3. Hash the result using the same algorithm and cost factor.
4. Compare the generated hash to the stored hash.

This process is computationally expensive because:

1. bcrypt is designed to be slow (due to the cost factor).
2. The attacker would need to repeat this process for every possible password guess.


🚀 Why is bcrypt Secure Even if the Salt is Known?
The security of bcrypt doesn't rely on keeping the salt secret. Instead, it relies on:
1. The Slowness of the Algorithm: The cost factor makes bcrypt intentionally slow, so brute-forcing is infeasible.
2. The Uniqueness of the Salt: Even if two users have the same password, their hashes will be different due to the unique salts.
3. The One-Way Nature of Hashing: It's computationally infeasible to reverse the hash to get the original password.



code: 
if (  userAvailable &&  (await bcrypt.compare(password, userAvailable.password))) {
  const token = userAvailable.generateToken();
  return res.status(200).send(token);
}

userSchema.methods.generateToken = function () {
  const token = jwt.sign(
    { _id: this._id, userName: this.name, isAdmin: this.isAdmin },
    config.get("jwtPrivateKey"),
    { expiresIn: "2 days" }
  );

  return token;
};




🚀 What is Hashing?
Hashing is the process of converting a password (or any input) into a fixed-length string of characters using a cryptographic hash function. 
The output (the hash) is unique to the input, and the process is one-way, meaning you cannot reverse the hash to get the original password.


🚀 What is a Salt?
A salt is a random string of data that is added to a password before it is hashed. 
it means that the salt is combined with the password, and the resulting combination is then hashed.
This process ensures that the final hashed password is unique and secure, even if two users have the same password.
The purpose of a salt is to ensure that even if two users have the same password, their hashed passwords will be different. 
This makes it much harder for attackers to use precomputed tables (like rainbow tables) to crack passwords.

Key Properties of a Salt:
Uniqueness: Each password should have a unique salt.
Randomness: The salt should be generated using a cryptographically secure random number generator.
Length: Salts are typically long enough to ensure uniqueness (e.g., 16 bytes or more).







📄 What is bcrypt.genSalt?
bcrypt.genSalt is a function provided by the bcrypt library that generates a random salt. 
It takes an optional parameter called the cost factor (or work factor), which determines how computationally expensive the hashing process will be.
Example:
const salt = await bcrypt.genSalt(10);

The 10 here is the cost factor. It controls "how many iterations of the hashing algorithm are performed". 
A higher cost factor makes the hashing process slower and more resource-intensive, which is good for security because it makes brute-force attacks harder.


📄 What Happens if You Don't Provide a Salt?
If you don't provide a salt when hashing a password, bcrypt will automatically generate one for you. This is why the following code works:

const hashedPassword = await bcrypt.hash(password, 10);
Here, 10 is the cost factor, and bcrypt will internally generate a salt for you.

However, if you explicitly generate a salt using bcrypt.genSalt, you can control the cost factor and reuse the same salt for multiple operations if needed 
(though this is generally not recommended for password hashing).


📄 Why is a Salt Important?
Without a salt, password hashing becomes vulnerable to certain types of attacks:

1. Rainbow Table Attacks:
A rainbow table is a precomputed table of hashes for common passwords. If two users have the same password, their hashes will be identical. 
An attacker can use a rainbow table to quickly look up the original password from the hash.
A salt ensures that even if two users have the same password, their hashes will be different, making rainbow tables useless.

2. Dictionary Attacks:
Without a salt, an attacker can precompute hashes for a list of common passwords and compare them directly to the hashes in your database.
A salt forces the attacker to recompute hashes for every possible salt value, making the attack much slower and more resource-intensive.





📄 What Happens if You Don't Use a Salt?

If you don't use a salt:

Identical Passwords = Identical Hashes: If two users have the same password, their hashes will be identical. This makes it easier for attackers to identify common passwords.
Vulnerability to Rainbow Tables: Attackers can use precomputed tables of hashes for common passwords to quickly crack the passwords.









































































