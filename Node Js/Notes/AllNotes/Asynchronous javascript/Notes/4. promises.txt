JavaScript Promises:
--------------------


-> "Producing code" is code that can take some time. ex. calculate function 
-> "Consuming code" is code that must wait for the result. ex. display function
-> A Promise is a JavaScript object that links producing code and consuming code


-> promise is javascript object which holds the eventual(result of period of time) result of an asynchronous operation.
-> when asynchronous operation completes it can either return result in value or an error.
-> A promise basically promise you that it will give the result of an asynchronous operation.
-> this object can be in one of the three state: 
	1. Pending
	2. Fulfilled
	3. Rejected

While a Promise object is "pending" (working), the result is undefined.

When a Promise object is "fulfilled", the result is a value.

When a Promise object is "rejected", the result is an error object.



-> Initially when we create promise object it is initially in "pending" state.
-> at this point it will kick/start some asynchronous operations.
-> when the result is ready the promise can either be fulfilled or resolved which basically means asynchronous operation completes 
successfully so here we have a value.
-> otherwise if something went wrong during the execution of that asynchronous operation our promise is in the rejected state.
in this we have an error object.



Ex.
--

let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        // resolve({id: 101, name: 'Adesh'});
          reject(new Error("Message: Error...."));
    }, 2000);
});

p
    .then((res) => console.log(res))
    .catch((err) => console.log(err.message));



Ex 2:

console.log("Before");
getUser(101)
    .then((user)=>getRepositories(user.gitHubUsername))
    .then((repos) => getCommits(repos[0]))
    .then((commits)=> console.log(commits))
    .catch((err)=>console.log(err.message))
console.log("After");

function getUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log("Fetching User from Database...");
      resolve({ id: id, gitHubUsername: "AdeshJ4" });
    }, 2000);
  });
}

function getRepositories(userName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching repos from Database for user ${userName}...`);
      resolve(["repo1", "repo2", "repo3"]);
    }, 2000);
  });
}

function getCommits(repoName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching commits from Database for repo ${repoName}...`);
      resolve(["commit1", "commit2", "commit3"]);
    }, 2000);
  });
}










Promise.all([])
---------------

-> Promise.all is a method that takes an array of promises and returns a new promise.
-> This new promise contain array of the results when all promises are successfully fulfilled.
-> Sometimes we have to run few asynchronous operations in parallel,and when they all complete you wanna do something after.
-> for example you may call different api like facebook api and twitter api and when the result of both asynchronous operations are ready then you are gonna return something to user.

code: 
-----

const p1 = new Promise((resolve, reject)=>{
    setTimeout(()=>{
        console.log('Async Operation 1...');
        resolve({id: 101, name: 'Adesh'});
    }, 2000)
});

let p2 = new Promise((resolve, reject)=>{
    setTimeout(() => {
        console.log('Async Operation 2...');
        resolve({id: 102, name: "Akshay"});
    }, 2000);
})


Promise
    .all([p1, p2])
    .then((res)=>console.log(res))
    .catch((err)=> console.log(err.message));


Output: 
-------

Async Operation 1...
Async Operation 2...
[ { id: 101, name: 'Adesh' }, { id: 102, name: 'Akshay' } ]


Explanation: 
------------

Promise.all([p1, p2]):
----------------------

-> in this ex we don't have real concurrency .
-> we don't have multi-thread. we are still dealing with single thread.
-> but that single thread is kicking off multiple asynchronous operations almost at the same time not exactly at the same time.
-> first it excute first async opeartion after that thread is release. so immediatly after it start second async operation.
-> we are not waiting for result of first async operation to be ready
-> Both async operation starts almost at the same time.
-> when we get the res, the result is in array. 
-> if one of the promise failed then final promise is considered as a failed.


Promise.race([p1, p2]):
-----------------------
-> when you have to do something as soon as first promise completes then instead of using Promise.all() we have to use 
Promise.race([p1, p2])
-> in this case our first promise completes first so result is : 
Async Operation 1...
{ id: 101, name: 'Adesh' }

-> also result is not in array format.

code: 
------
const p1 = new Promise((resolve, reject)=>{
    setTimeout(()=>{
        console.log('Async Operation 1...');
        resolve({id: 101, name: 'Adesh'});
    }, 2000)
});

let p2 = new Promise((resolve, reject)=>{
    setTimeout(() => {
        console.log('Async Operation 2...');
        // resolve({id: 102, name: "Akshay"});
        reject(new Error('Something failed'))
    }, 2000);
})


Promise
    .race([p1, p2])
    .then((res)=>console.log(res))
    .catch((err)=> console.log(err.message));


output: 
-------

Async Operation 1...
{ id: 101, name: 'Adesh' }



Creating Settled Promises:
--------------------------

-> Sometimes we have to create a promise that is already resolved. this is particularly used while writing unit tests.
-> in your unit test you have to write promise that is already resolved.

code : 
======

const p = Promise.resolve({id: 101, name: "Adesh"});

p.then((res)=> {
    console.log(res);
})

output: 
========
{id: 101, name: 'Adesh'}






















