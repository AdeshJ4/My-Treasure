-> The object you recied from mongoose/mongodb is not plain javascript object rather its a mongoose document, so you hava to convert it into plain js objecty to perform
operastions.
ex: const customer = await Customer.findById(customerId);



2. Using Embedded Documents (DeNormalization)
-> There is another approach instead of having different collection for storing authors and courses we can embedded an author document inside a course document.
-> so basically we are embedding one document inside another document. and this we called demoralization.

ex: 

let course = {
	courseName: 'Node js',
	author: {
		name: 'Mosh'
		contact: '9527370288'
	}
}



ðŸš€ Advantages of Embedded Documents (Denormalization)

1. Single Query: Fetching a course document with its embedded author data requires only one query to the database. Since the data is stored together, it can be retrieved 
and processed more quickly.
2. Atomicity: All related data (e.g., course and author) is stored in a single document, making it easier to ensure data consistency
3.Ideal for Small, Nested Data: Embedding works well when the related data (e.g., author) is small and doesnâ€™t change frequently.



ðŸš« Disadvantages of Embedded Documents (Denormalization)

1. Duplication: If the same author writes multiple courses, their data will be duplicated in each course document.
2. Storage Overhead: This can lead to increased storage requirements.
3. Update Challenges: If the embedded data (e.g., authorâ€™s name) changes, you must update it in all documents where it is embedded. This can be error-prone and inefficient.
4. Document Size Limit: MongoDB has a 16 MB document size limit. If the embedded data grows too large (e.g., many authors or nested documents), it can exceed this limit.
5. Performance Issues: Large embedded documents can slow down read and write operations
6. No Indexing on Embedded Fields: While MongoDB allows indexing on embedded fields, it can be less efficient than indexing top-level fields.
7. Inefficient for Large Data: If the related data (e.g., authors) is large or frequently updated, embedding can become inefficient








code : 

ex. 1:  Using only one author

const mongoose = require("mongoose");
const connectDB = async () => {
  try {
    const connect = await mongoose.connect("mongodb://127.0.0.1/playground");
    console.log("Database Connected");
    console.log("Host : ", connect.connection.host);
    console.log("DB Name : ", connect.connection.name);
  } catch (err) {
    console.log("Database not connected");
    console.log(err.message);
  }
};

connectDB();



const authorSchema = new mongoose.Schema({
  authorName: String,
  phone: Number,
  age: Number,
});

const courseSchema = new mongoose.Schema({
  courseName: String,
  author: {
    type: authorSchema,
    required: true,
  },
});

const Course = new mongoose.model("Course", courseSchema);

const getAllCourses = async () => {
  try {
    const courses = await Course.find();
    console.log(courses);
  } catch (err) {
    console.log(err.message);
  }
};

const createCourse = async (courseName, author) => {
  try {
    const course = await Course.create({
      courseName,
      author,
    });
    console.log(course);
  } catch (err) {
    console.log(err.message);
  }
};

terminal> createCourse("Node js", {authorName: 'Mosh hamedani', phone: '9527370288'});
terminal> createCourse("react js", {authorName: 'Mosh hamedani', phone: '9527370288'});
o/p: 
{
  courseName: 'Node js',
  author: {
    authorName: 'Mosh hamedani',
    phone: 9527370288,
    _id: new ObjectId('67c327a42d939466c9bb18f5')
  },
  _id: new ObjectId('67c327a42d939466c9bb18f4'),
  __v: 0
}
{
  courseName: 'react js',
  author: {
    authorName: 'Mosh hamedani',
    phone: 9527370288,
    _id: new ObjectId('67c328577f937518bf38cae2')
  },
  _id: new ObjectId('67c328577f937518bf38cae1'),
  __v: 0
}

Note : even though both courses have same author, mongodb creates separate object ids for it.





const updateInnerAuthor = async (courseId, authorObj) => {
  try {
    // update only one document.
    const course = await Course.findByIdAndUpdate(
      courseId,
      {
        $set: {
          "author.authorName": authorObj.authorName,
        },
      },
      { new: true }
    );
    console.log(course);
  } catch (err) {
    console.log(err.message);
  }
};

const getAllCoursesOfMoshAndUpdate = async () => {
  try {
    // get all courses of mosh and update phone.
    const courses = await Course.updateMany(
      { "author.authorName": "Mosh Hamedani" },
      {
        $set: {
          "author.phone": 9587963177,
        },
      }
    );
    console.log(courses);
  } catch (err) {
    console.log(err.message);
  }
};

const getAllCoursesOfMosh = async () => {
  try {
    const courses = await Course.find({ "author.authorName": "Mosh Hamedani" });
    console.log(courses);
  } catch (err) {
    console.log(err.message);
  }
};

// createCourse('Express Js', {authorName: 'Code With Harry', age: 30, phone: 7721031355});

// updateInnerAuthor('6560c071c4bed105b3918e4a', {authorName: 'Mosh Hamedani'})

// getAllCoursesOfMoshAndUpdate();

// getAllCourses()









ex. 2 : Using array of authors : Embedding Documents Using an array of sub-documents


const mongoose = require("mongoose");
const connectDB = async () => {
  try {
    const connect = await mongoose.connect("mongodb://127.0.0.1/playground");
    console.log("Database Connected");
    console.log("Host : ", connect.connection.host);
    console.log("DB Name : ", connect.connection.name);
  } catch (err) {
    console.log("Database not connected");
    console.log(err.message);
  }
};
connectDB();

const authorSchema = new mongoose.Schema({
  authorName: String,
  phone: Number,
  age: Number,
});

const courseSchema = new mongoose.Schema({
  courseName: String,
  authors: {
    type: [authorSchema],
    required: true,
  },
});

const Course = new mongoose.model("Course", courseSchema);

const getAllCourses = async () => {
  try {
    const courses = await Course.find();
    console.log(courses);
  } catch (err) {
    console.log(err.message);
  }
};

const createCourseWithMultipleAuthors = async (courseName, authors) => {
  try {
    const course = await Course.create({
      courseName,
      authors,
    });
    console.log(course);
  } catch (err) {
    console.log(err.message);
  }
};

const addAuthor = async (courseId, author) => {
  try {
    const course = await Course.findById(courseId);
    course.authors.push(author);
    await course.save();
    console.log("Author added successfully");
  } catch (err) {
    console.log(err.message);
  }
};

const removeAuthor = async (courseId, authorId) => {
  try {
    const course = await Course.findById(courseId);
    const author = course.authors.id(authorId);

    console.log('course : ', course);
    console.log('author: ', author);

    author.deleteOne();
    await course.save();
    console.log("Author removed successfully");
  } catch (err) {
    console.log(err.message);
  }
};


// addAuthor('6561757b8860b20bab3e9393', {authorName: "Vinod Thapa", phone: 7784521355, age: 22});
// removeAuthor("6561757b8860b20bab3e9393", "65617c9db6e6e3621bf4e5c7");

// createCourseWithMultipleAuthors('Python Course', [
//     {authorName: 'Mosh hamedani', age: 50, phone: 9527370288},
//     {authorName: 'Code With Harry', age: 30, phone: 7721031355},
// ]);
