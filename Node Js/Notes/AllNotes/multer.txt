Multer is a node.js middleware for handling "multipart/form-data", which is primarily used for uploading files. 
You need a middleware that can parse multipart/form-data because express.json() and express.urlencoded() won‚Äôt work with it.
NOTE: Multer will not process any form which is not multipart (multipart/form-data).

When the form is submitted:
The browser splits the request into parts (file content, field names, etc.)
multer parses this multipart content and populates:
req.file (for single file)
req.files (for multiple files)
req.body (for text fields in the form)



Normal File Upload: 

üîπ Allowed File Types with Your Code:
‚úÖ Images (.jpg, .jpeg, .png, .gif, .svg, .webp)
‚úÖ Documents (.pdf, .doc, .docx, .txt)
‚úÖ Spreadsheets (.xls, .xlsx, .csv)
‚úÖ Videos (.mp4, .avi, .mov)
‚úÖ Audio Files (.mp3, .wav)
‚úÖ Other Files (.zip, .rar, .json, .xml)


üöÄ multipart/form-data: 
Multipart/form-data is a content type used when submitting form data that includes files, such as images, videos, or documents, typically through HTML forms.

You need a middleware that can parse multipart/form-data because express.json() and express.urlencoded() won‚Äôt work with it.


üß† When is it used?
When you're sending data from the frontend using a <form> with enctype="multipart/form-data", especially when uploading files:
```
<form action="/upload" method="POST" enctype="multipart/form-data">
  <input type="file" name="myFile" />
  <button type="submit">Upload</button>
</form>
```



Client-Side Form
```
<form action="/upload" method="POST" enctype="multipart/form-data">
  <input type="text" name="username" value="john_doe">
  <input type="file" name="profilePic">
  <button type="submit">Upload</button>
</form>
```

backend-Side Code: 
```
app.post('/upload', upload.single('profilePic'), (req, res) => {
  console.log(req.body);  // Text fields
  console.log(req.file);  // Uploaded file details
  res.send('File uploaded successfully!');
});
```


How to Use multipart/form-data in Postman for File Uploads?
1Ô∏è‚É£ Open Postman and Create a POST Request
Method: POST
URL: http://localhost:3000/customer (or your API endpoint)


2Ô∏è‚É£ Select Body Tab
Click on Body.

Select "form-data".

Now add your fields:

---------------------------------
Key	        Value	        Type
---------------------------------
name	    John Doe	    Text
profilePic	(Select file)	File
---------------------------------

For text fields: Select Text from the dropdown.
For file upload: Select File and choose a file from your system


3Ô∏è‚É£ Send the Request
Click Send.
Your API should receive:
```
req.body: { name: "John Doe" }
req.file: { originalname: "myphoto.jpg", mimetype: "image/jpeg", path: "uploads/myphoto.jpg" }
```


4Ô∏è‚É£ Verify req.body and req.file in Your Express App
If req.body is undefined, make sure you have added:
```
 
```


final example: 
```
app.post('/customer', upload.single('profilePic'), (req, res) => {
    console.log('Body:', req.body); // ‚úÖ Should contain { name: "John Doe" }
    console.log('File:', req.file); // ‚úÖ File details
    res.status(201).json({ message: 'File uploaded successfully!' });
});
```


üöÄ Difference Between application/x-www-form-urlencoded and raw in Postman:

When sending data in Postman, you can choose different formats under the Body tab.
Two common formats are application/x-www-form-urlencoded and raw.

1Ô∏è‚É£ application/x-www-form-urlencoded
üëâ Works like sending form data via an HTML form (<form method="POST">).
application/x-www-form-urlencoded is rarely used in modern applications, especially when working with React, modern APIs, and RESTful services. 
Instead, we primarily use application/json (raw JSON format).
Modern REST APIs and GraphQL Use JSON

99% of modern APIs (including public APIs like Twitter, Stripe, Firebase, etc.) expect JSON.
Even GraphQL uses JSON for requests and responses.
Works Better with React & Redux

React apps use fetch() or Axios, which both work seamlessly with JSON.
Redux actions usually send/receive JSON data.




Data is URL-encoded (special characters are replaced, e.g., spaces become + or %20).
Sent as "key=value" pairs in the request body.
Used when sending form data without files.

üëâHow to Use in Postman:
Go to Body ‚Üí x-www-form-urlencoded.
Add key-value pairs (like a form submission).
Set Headers ‚Üí Content-Type: application/x-www-form-urlencoded.
Example
Postman Request (x-www-form-urlencoded)

-------------------------
Key	    Value
-------------------------
name	John Doe
email	john@example.com
-------------------------

Sent Request Body:
name=John+Doe&email=john%40example.com

Express.js Example
```
app.use(express.urlencoded({ extended: true })); // Required to parse URL-encoded data

app.post('/submit', (req, res) => {
    console.log(req.body); // { name: 'John Doe', email: 'john@example.com' }
    res.send('Form submitted!');
});
```
‚úÖ Use case: Submitting login forms, registration forms, API requests with simple data.



2Ô∏è‚É£ raw
üëâ Sends data as-is (without encoding), in different formats like JSON, text, or XML.
-> application/x-www-form-urlencoded is rarely used in modern applications, especially when working with React, modern APIs, and RESTful services. 
Instead, we primarily use application/json (raw JSON format).
Modern REST APIs and GraphQL Use JSON

99% of modern APIs (including public APIs like Twitter, Stripe, Firebase, etc.) expect JSON.
Even GraphQL uses JSON for requests and responses.
Works Better with React & Redux

React apps use fetch() or Axios, which both work seamlessly with JSON.
Redux actions usually send/receive JSON data.

Supports JSON, text, XML, HTML, etc.
Does not use key-value pairs like x-www-form-urlencoded.
Commonly used for REST APIs that accept JSON payloads.

üëâ How to Use in Postman:
Go to Body ‚Üí raw.
Choose JSON (or another format from the dropdown).
Set Headers ‚Üí Content-Type: application/json.
Example: Postman Request (raw - JSON)
```
{
    "name": "John Doe",
    "email": "john@example.com"
}
```
Express.js Example
```
app.use(express.json()); // Required to parse JSON data
app.post('/submit', (req, res) => {
    console.log(req.body); // { name: 'John Doe', email: 'john@example.com' }
    res.send('JSON received!');
});
```
‚úÖ Use case: Sending structured JSON data to APIs, interacting with modern REST APIs.




üöÄ storage: 
If you want more control over your uploads, you'll want to use the "storage" option instead of "dest".
Multer ships with storage engines "DiskStorage" and "MemoryStorage"; More engines are available from third parties.


### **üéØ When to Use Which?**
|-----------------------------------|-----------------------------------------------|----------------------------------------------------------------------------|
| Storage Engine                    | `diskStorage`                                 | `memoryStorage`                                                            |
|-----------------------------------|-----------------------------------------------|----------------------------------------------------------------------------|
| **Where files are stored?**       | Saves files to disk (filesystem)              | Stores files in memory (RAM) as a `Buffer`                                 |
| **How files are accessed?**       | Stored in a specific directory                | Stored in `req.file.buffer` as binary data                                 |
| **Use Case**                      | When you need to save files permanently       | When you need to process files immediately                                 |
| **Performance**                   | Slightly slower (writes to disk)              | Faster (stored in RAM, no disk I/O)                                        |
| **Example Use Cases**             | Uploading profile pictures, saving documents  | Image processing, sending files to cloud storage (e.g., AWS S3, Cloudinary)|
|-----------------------------------|-----------------------------------------------|----------------------------------------------------------------------------|



1Ô∏è‚É£. DiskStorage
-> The disk storage engine gives you full control on storing files to disk.
code: 
```
const storage = multer.diskStorage({
    destination: function(req, file, cb){
        cb(null, 'uploads/')
    },
    filename: function(req, file, cb){
        cb(null, file.originalname)
    }
})
const upload = multer({ storage: storage })
```

There are two options available, "destination" and "filename". 
They are both functions that determine where the file should be stored.

"destination": destination is used to determine within which folder the uploaded files should be stored. 
This can also be given as a string (e.g. '/tmp/uploads'). If no destination is given, the operating system's default directory for temporary files is used.

"filename": filename is used to determine what the file should be named inside the folder. If no filename is given, each file will be given a random name that 
doesn't include any file extension.
Note: Multer will not append any file extension for you, your function should return a filename complete with an file extension.



2Ô∏è‚É£ MemoryStorage: 
The memory storage engine stores the files in memory as Buffer objects. It doesn't have any options.
```
const storage = multer.memoryStorage()
const upload = multer({ storage: storage })
```
When using memoryStorage, the uploaded file is not saved to disk but stored in RAM as a buffer inside req.file.buffer. 
You can access it and perform operations like processing, uploading to cloud storage, or converting the file.
If you're uploading files to Cloudinary (or any cloud storage like AWS S3, Firebase, etc.), you should use memoryStorage in Multer.





final Example : 

```

const express = require('express');
const app = express();
const multer = require('multer');
// const storage = multer.diskStorage({
//     destination: function(req, file, cb){
//         cb(null, 'uploads/')
//     },
//     filename: function(req, file, cb){
//         cb(null, file.originalname)
//     }
// }); // use it if you want to keep files on server file system
const storage = multer.memoryStorage();  // use it for uploading images on cloudinary, aws
// const upload = multer({ dest: 'uploads/' });  // simple
const upload = multer({ storage: storage });



app.use(express.json()); // Enable JSON parsing (if needed)

// accepting single file from input name 'profilePic'
app.post('/api/upload', upload.single('profilePic'), (req, res) => {
    const file = req.file;
    return res.status(201).json({ file })
});


// accepting multiple file from input name 'photos' with maximum upload limit of 5
app.post('/api/photos/upload', upload.array('photos', 5), (req ,res) => {
    const photos = req.files;
    return res.status(201).json({ photos })
});


// accepting multiple files from different input fields having names ('avatar', 'gallery')
const cpUpload = upload.fields([{ name: 'avatar', maxCount: 1}, { name: 'gallery', maxCount: 5}])
app.post('/cool-profile', cpUpload, (req, res) => {
    const files = req.files;
    return res.status(201).json({ files });
});


// select profileImage along with data.
// go to postman, Select Body Tab, Select form-data, Now add your fields: name, age, profilePic
// For text fields: Select Text from the dropdown. For file upload: Select File and choose a file from your system.
app.post('/api/customer', upload.single('profilePic'), (req, res) => {
    console.log('file', req.file);  // ‚úÖ Works fine
    console.log('body', req.body);  // ‚úÖ Should now contain text fields
    return res.status(201).json({ file: req.file, body: req.body });
});


app.listen(5000, () => {
    console.log(`server listning on port 5000`);
})

```












upload.fields: 

```
import React, { useState } from 'react'
import axios from 'axios';

const App = () => {
  const [formDataFields, setFormDataFields] = useState({
    name: '',
    age: ''
  });

  const [profilePic, setProfilePic] = useState(null);

  const [gallary, setGallary] = useState([]);

  const getFormData = (e) => {
    const { name, value } = e.target;
    setFormDataFields(prev => ({ ...prev, [name]: value }));
  }



  const handleSubmit = async (e) => {
    e.preventDefault()

    const formData = new FormData();
    formData.append('name', formDataFields.name);
    formData.append('age', formData.age);
    formData.append('profilePic', profilePic);
    for(let i=0; i<gallary.length; i++){
      formData.append('gallary', gallary[i])
    }

    try{
      const { data } = await axios.post("http://localhost:5000/api/customers", formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });
      
      console.log(`Upload files`, data.files);
      
    }catch(err){
      console.log(err.message);
      alert("Upload Failed")
    }
    alert("Upload Successful")
  }



  return (
    <div>
      <form onSubmit={handleSubmit}>

      {profilePic && (
          <div style={{ marginTop: '10px' }}>
              <p>Preview:</p>
              <img
                src={URL.createObjectURL(profilePic)}
                alt="Profile Preview"
                style={{ width: '150px', height: '150px', objectFit: 'cover', borderRadius: '8px' }}
              />
          </div>
      )}

        {gallary.length > 0 && (
            <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap', marginTop: '10px' }}>
              {gallary.map((img, index) => (
                <img
                  key={index}
                  src={URL.createObjectURL(img)}
                  alt={`gallery-preview-${index}`}
                  style={{ width: '100px', height: '100px', objectFit: 'cover', borderRadius: '8px' }}
                />
              ))}
            </div>
          )}

        <div>
          <label>Name:</label>
          <input type="text" name="name" value={formDataFields.name} onChange={getFormData} required />
        </div>


        <div>
          <label>Age:</label>
          <input type="number" name="age" value={formDataFields.age} onChange={getFormData} required />
        </div>


        <div>
          <label htmlFor="profilePic">Profile Pic</label>
          <input type="file" accept='image/*' onChange={(e) => setProfilePic(e.target.files[0])} />
        </div>


        <div>
          <label>Gallery (up to 5 files):</label>
          <input type="file" accept="image/*" multiple onChange={(e) => setGallary(Array.from(e.target.files))} />
        </div>


        <button type='submit'>Submit</button>

      </form>
    </div>
  )
}

export default App





backend code: 

const express = require('express');
const app = express();
const multer = require('multer');
const cors = require('cors');

app.use(cors({
    origin: "http://localhost:5173",
    credentials: true
}));


const storage = multer.diskStorage({
    destination: function(req, file, cb){
        cb(null, 'uploads/')
    },
    filename: function(req, file, cb) {
        cb(null, file.originalname);
    }
})


const upload = multer({storage})



app.post('/api/customers', upload.fields([{ name: 'profilePic', maxCount: 1}, { name: 'gallary', maxCount: 5}]), (req, res) => {
    const { name, age } = req.body;
    const files = req.files;

    console.log(name, age);
    console.log(files);
})

app.listen(5000, () => {
    console.log('server is running on port 5000');
    
})
```
```

