Middleware & Request Processing Pipeline:
-----------------------------------------

-> Middleware is basically a function that takes a 'request object' and either returns a response to the client or passes 
control to another middleware function using next()..
-> at runtime, when we receive a request on the server that request goes through a pipeline we call this pipeline "Request Processing 
Pipeline".
-> In this pipeline we have one or more middleware functions. Each middleware function either terminates the request response cycle 
by returning a response object or it will pass control to another function.
-> So every request that we get on the server will go through our middleware function.
-> So an express application is essentially nothing but a bunch of middleware functions
-> Middleware functions are invoked in the order they are defined and are capable of modifying the request and response objects, 
as well as passing control to the next middleware function in the stack.
-> Middleware allow programmer to add functionality to the request response cycle such as authentication, logging, error handling 
and many more.
-> if you use lots of middleware functions inside your request processing pipeline then it will slow down your application.
-> Middleware can be defined globally, for all routes, or can be defined for specific routes or groups of routes. 
-> So an express application is essentially nothing but a bunch of middleware functions
-> app.use() method is used for adding middleware function.



// Define a route handler for the root path ('/')
app.get('/', (req, res)=>{
	res.send("Hello");
});
In the above ex tha callback function passes to route handler is the example of 'middleware function'.
"(req, res)=>{
	res.send("Hello");
}"
-> So in express every route handler function we have is technically a middleware function. because it takes a req object and returns 
res object to client. so it termites req-res cycle.
	







Building Custom Middleware: 
----------------------------


-> Ex. 

const express = require("express");
const app = express();

function middleware(req, res, next) {
  console.log("Front Middleware");
  next();
}

function middleware1(req, res, next) {
  console.log("Middleware 1");
  next();
}

function middleware2(req, res, next) {
  console.log("Middleware 2");
  next();
}

function middleware3(req, res, next) {
  console.log("Last Middleware");
  next();
}

app.use(middleware);
app.get("/part1", [middleware1, middleware2], (req, res, next) => {
  res.send("2 middleware function : [middleware1, middleware2]");
  next();
});
app.get("/part2", middleware1, (req, res) => {
  res.send("1 middleware function: middleware1 -> we terminate req-res cycle");
});
app.use(middleware3);

const port = 5000;
app.listen(port, () => {
  console.log(`Server is listening on port ${port}`);
});



Built in Middleware functions: 
===============================

1. app.use(express.json());

-> In Express.js, the `express.json()` middleware is used to parse incoming JSON data from HTTP requests. 
-> The `express.json()` middleware parses the JSON data and makes it available as a JavaScript object in the `req.body` property. 
so you don't have to manually parse the incoming data using `JSON.parse()`. 
-> it also performs error handling. If the incoming data is not valid JSON, it will catch the parsing error and send an HTTP 400 Bad
Request response, which helps prevent your application from crashing due to malformed JSON.


2. app.use(express.urlencoded({ extended: true }));

-> is used to parse incoming URL-encoded data from the request body.
-> It parses application/x-www-form-urlencoded data (typically from HTML forms) and makes it available in req.body.
-> If you do not use express.urlencoded(), req.body will be undefined for x-www-form-urlencoded data.
-> HTML forms and React forms are different in how they handle user input.
-> If you're submitting a React form to a Node.js + Express backend, you typically send JSON data, not x-www-form-urlencoded. so need to use this middleware but 
make sure to use express.json().



3. app.use(express.static('public'));

-> It is used to serve static files (like HTML, CSS, JavaScript, images, etc.) from the "public" directory.
-> The folder does not have to be named "public". You can name it anything, but you must use the same name in express.static().
for ex: app.use(express.static("assets"));

my-app/
â”‚â”€â”€ server.js
â”‚â”€â”€ public/
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ styles.css
â”‚   â”œâ”€â”€ script.js
â”‚   â”œâ”€â”€ images/
â”‚       â”œâ”€â”€ logo.png

app.use(express.static("public"));   // static file are aserve from root "/"

URL                                     Serves File
--------------------------------------  ------------------------
http://localhost:3000/                  public/index.html
http://localhost:3000/styles.css        public/styles.css
http://localhost:3000/script.js         public/script.js
http://localhost:3000/images/logo.png   public/images/logo.png


ðŸ”¹ What If You Want a Custom Path?
You can serve static files from a custom URL path like /static: 
app.use("/static", express.static("public"));

Now, files must be accessed like this:
http://localhost:3000/static/styles.css
http://localhost:3000/static/images/logo.png





Third-party Middleware: 
=======================

nodemon 
jsonwebtoken
dotenv
express
helmet
compression



1. helmet : Helps secure your app by setting various HTTP Headers.
5. compression: optimizing the performance and efficiency of web applications by reducing the size of data sent between the server 
and clients.improve the speed and reduce the bandwidth.
6.dotenv: is used to load environment variables from a file named .env into process.env




Third-party Middleware:
nodemon: Nodemon is not exactly middleware but a utility that monitors changes in your Node.js application and automatically restarts the server during development. It's often used in development environments to enhance the development workflow.
jsonwebtoken: This library is used for generating and verifying JSON Web Tokens (JWT), which are commonly used for authentication and information exchange between parties.
dotenv: dotenv is a zero-dependency module that loads environment variables from a .env file into process.env. It's commonly used to manage configuration settings in Node.js applications.
helmet: Helmet is a set of middleware functions to help secure Express applications by setting various HTTP headers. It enhances security by mitigating common web vulnerabilities.
compression: The compression middleware is used to compress HTTP responses, reducing the size of data sent over the network and improving application performance.

Libraries/Frameworks:
express: Express.js is a web application framework for Node.js. It provides a robust set of features, including routing, middleware support, and a simplified API for handling HTTP requests and responses.
mongoose: Mongoose is an ODM (Object Data Modeling) library for MongoDB and Node.js. It simplifies interactions with MongoDB by providing a schema-based solution for modeling application data.
debug: The debug library provides a simple debugging utility for Node.js applications. It allows developers to selectively enable or disable debugging messages based on namespaces.
config: The config library is used for managing configuration settings in Node.js applications. It allows developers to define configuration files for different environments and easily access configuration values.

Others:
joi: Joi is a powerful validation library for JavaScript that can be used for validating and sanitizing user input or other data in Node.js applications.





