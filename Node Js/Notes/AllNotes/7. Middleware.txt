Middleware & Request Processing Pipeline:
-----------------------------------------

-> Middleware is basically a function that takes a 'request object' and either returns a response to the client or passes 
control to another middleware function.
-> at runtime, when we receive a request on the server that request goes through a pipeline we call this pipeline "Request Processing 
Pipeline".
-> In this pipeline we have one or more middleware functions. Each middleware function either terminates the request response cycle 
by returning a response object or it will pass control to another function.
-> So every request that we get on the server will go through our middleware function.
-> So an express application is essentially nothing but a bunch of middleware functions
-> Middleware functions are invoked in the order they are defined and are capable of modifying the request and response objects, 
as well as passing control to the next middleware function in the stack.
-> Middleware allow programmer to add functionality to the request response cycle such as authentication, logging, error handling 
and many more.
-> if you use lots of middleware functions inside your request processing pipeline then it will slow down your application.
-> Middleware can be defined globally, for all routes, or can be defined for specific routes or groups of routes. 
-> So an express application is essentially nothing but a bunch of middleware functions
-> app.use() method is used for adding middleware function.



// Define a route handler for the root path ('/')
app.get('/', (req, res)=>{
	res.send("Hello");
});
In the above ex tha callback function passes to route handler is the example of 'middleware function'.
"(req, res)=>{
	res.send("Hello");
}"
-> So in express every route handler function we have is technically a middleware function. because it takes a req object and returns 
res object to client. so it termites req-res cycle.
	







Building Custom Middleware: 
----------------------------


-> Ex. 

const express = require("express");
const app = express();

function middleware(req, res, next) {
  console.log("Front Middleware");
  next();
}

function middleware1(req, res, next) {
  console.log("Middleware 1");
  next();
}

function middleware2(req, res, next) {
  console.log("Middleware 2");
  next();
}

function middleware3(req, res, next) {
  console.log("Last Middleware");
  next();
}

app.use(middleware);
app.get("/part1", [middleware1, middleware2], (req, res, next) => {
  res.send("2 middleware function : [middleware1, middleware2]");
  next();
});
app.get("/part2", middleware1, (req, res) => {
  res.send("1 middleware function: middleware1 -> we terminate req-res cycle");
});
app.use(middleware3);

const port = 5000;
app.listen(port, () => {
  console.log(`Server is listening on port ${port}`);
});



Built in Middleware functions: 
===============================

1. app.use(express.json());

-> In Express.js, the `express.json()` middleware is used to parse incoming JSON data from HTTP requests. 
-> The `express.json()` middleware parses the JSON data and makes it available as a JavaScript object in the `req.body` property. 
so you don't have to manually parse the incoming data using `JSON.parse()`. 
-> it also performs error handling. If the incoming data is not valid JSON, it will catch the parsing error and send an HTTP 400 Bad
Request response, which helps prevent your application from crashing due to malformed JSON.


2. app.use(express.urlencoded({ extended: true }));

-> This middleware function parses incoming requests with URL encoded payloads that is request with body like	this:"key=value&key=value".
-> Now this is more of a traditional approach. Its not something tht we use that often these days.
-> Basically if you have an HTML form with inputs fields and post that form to the server the body of the request will looks 
like this "key=value&key=value".
-> So that's where you have URL encoded payload in the request.
-> Now this middleware parse this body "key=value&key=value" and populates req.body like a json object.
-> ex.
app.use(express.urlencoded({ extended: true }));
app.post('/submit', (req, res) => {
  console.log(req.body); 
  return res.send('Form submitted successfully!');
});


3. app.use(express.static('public'));

-> This middleware is used to serve static files  
-> so we are going to put all our static assets like images, css and so on in this folder.
-> create folder having name "Public" and create a file inside it having name "f1.txt"
-> Then visit localhost:3000/f1.txt



Third-party Middleware: 
=======================

nodemon 
jsonwebtoken
dotenv
express
helmet
compression



1. helmet : Helps secure your app by setting various HTTP Headers.
5. compression: optimizing the performance and efficiency of web applications by reducing the size of data sent between the server 
and clients.improve the speed and reduce the bandwidth.
6.dotenv: is used to load environment variables from a file named .env into process.env




Third-party Middleware:
nodemon: Nodemon is not exactly middleware but a utility that monitors changes in your Node.js application and automatically restarts the server during development. It's often used in development environments to enhance the development workflow.
jsonwebtoken: This library is used for generating and verifying JSON Web Tokens (JWT), which are commonly used for authentication and information exchange between parties.
dotenv: dotenv is a zero-dependency module that loads environment variables from a .env file into process.env. It's commonly used to manage configuration settings in Node.js applications.
helmet: Helmet is a set of middleware functions to help secure Express applications by setting various HTTP headers. It enhances security by mitigating common web vulnerabilities.
compression: The compression middleware is used to compress HTTP responses, reducing the size of data sent over the network and improving application performance.

Libraries/Frameworks:
express: Express.js is a web application framework for Node.js. It provides a robust set of features, including routing, middleware support, and a simplified API for handling HTTP requests and responses.
mongoose: Mongoose is an ODM (Object Data Modeling) library for MongoDB and Node.js. It simplifies interactions with MongoDB by providing a schema-based solution for modeling application data.
debug: The debug library provides a simple debugging utility for Node.js applications. It allows developers to selectively enable or disable debugging messages based on namespaces.
config: The config library is used for managing configuration settings in Node.js applications. It allows developers to define configuration files for different environments and easily access configuration values.

Others:
joi: Joi is a powerful validation library for JavaScript that can be used for validating and sanitizing user input or other data in Node.js applications.





