WebSocket:

-> WebSockets handle thousands of real-time messages without blocking.
-> WebSocket is persistent connection between client and server.
-> Once we established connection between clienrt and server then anytime we can exchange data between client and server.'
Its bidirection full duplex conmnedtion 



============================================================================================================================================================


‚ùì What is an "Events Module" and "EventEmitter"  in Node.js?

visit module file


============================================================================================================================================================



‚ùì Event-Driven Architecture in Node.js:


An event-driven architecture (EDA) is a design pattern where application components communicate via events instead of direct method calls. 
In this model, events trigger specific handlers (listeners) that respond asynchronously.

Event is basically a 'signal' that indicates something has happened in your application and you have to handle that event. 
Like when a connection is made or a file is opened. Every action on a computer is an event. 

Node.js is built on this event-driven, non-blocking architecture, making it highly efficient for handling multiple concurrent operations without creating multiple threads.

üîπ How Does Event-Driven Architecture Work in Node.js?

Node.js uses an "Event Loop" and the "events module" to handle events.

1. Event Emitter (Publisher-Subscriber Model)
A publisher (emitter) generates an event.
A subscriber (listener) waits for that event and executes a callback function when the event occurs.

2. Event Loop
Node.js listens for incoming requests and adds them to the Event Queue.
The Event Loop processes them asynchronously, delegating I/O tasks (like database queries, file reads) to the system.

3. Callbacks & Handlers
Once an operation completes, a callback function executes to handle the response.

Example: Event-Driven Programming in Node.js



============================================================================================================================================================




‚ùì What is Node.js, and how does it work?


üëâ Node is not a programming language nor its a framework it is just a open source, cross platform 'runtime environment' for 
executing js code outside a browser.
üëâ It is built on Google Chrome's V8 engine, which makes it fast and efficient
üëâ we use Node js to build backend services also call APIs.
üëâ Node applications are 'Asynchronous by default'.
üëâ In node we have a 'single thread' to handle 'all requests'.
üëâ Node.js allows developers to build scalable network applications using JavaScript on the server-side, making it ideal for backend development, APIs, and real-time applications.

-> up to 2009 only way to executing js code was inside a browser.  A browser provide a runtime environment for js code.
-> so every browser have "JS Engine" that takes our js code and converts it  into 'machine code' that computer understand.
-> Microsoft edge uses 'chakra', firefox uses 'SpiderMonkey' and chrome uses 'V8' and because of this verities of "JS ENGINE" 
sometimes the js code can behave differently browser to browser.
->In 2009,'Ryan Dahl' the creator of node came up with brilliant idea. He took google v8 engine which is the fastest js engine out 
there and embedded it inside a 'c++ program' and called that  program  'Node.exe' means Node. 
-> so similar to browser, Node became runtime environment for js code. 
-> Node contain js engine, with certain objects which provides an environment for executing our js code.
-> for ex we don't have 'document', 'window' object in a node instead we have 'global' object that gives us 
more interesting capabilities. for ex we can work with file system ,  listen for request like "http.createServer()" 
in a given port. and so on we can't do this kind of stuff inside a browser.
-> In summary Node is a program that contain chrome v8 engine plus some additional modules which gave us some capabilities not 
available inside a browser.
-> we can work with file system , os, network and so on..
-> Both  chrome and node share same V8 engine but they provide different runtime environment for js code to run.



How Does Node.js Work?

Node.js follows a non-blocking, event-driven architecture, which makes it highly efficient for handling multiple concurrent connections. 
Here‚Äôs how it works:

1. Single-Threaded Event Loop:
Unlike traditional web servers (e.g., Apache) that use multiple threads for handling requests, Node.js uses a single thread to process all requests asynchronously.

2. Asynchronous and Non-Blocking I/O:
Instead of waiting for a task (e.g., database query) to complete before handling another request, Node.js uses callbacks, promises, or async/await to continue execution.
This allows Node.js to handle thousands of requests concurrently.

3. Event-Driven Architecture:
Node.js operates on an event loop that listens for events (e.g., HTTP requests, database queries) and processes them using event handlers.
The Node.js "EventEmitter module" is used to trigger and listen to events.

4. V8 Engine for Fast Execution:
Node.js uses Google‚Äôs V8 JavaScript Engine (also used in Chrome) to execute JavaScript code quickly by compiling it into machine code.

5. Built-in Modules & npm (Node Package Manager):
Node.js provides built-in modules (like fs for file handling, http for creating servers, and path for file paths).
npm (Node Package Manager) allows developers to install thousands of libraries and frameworks (like Express.js for building APIs).


Use Cases of Node.js
‚úÖ REST APIs & Microservices
‚úÖ Real-time applications (chat apps, WebSockets)
‚úÖ Server-side rendering (SSR) for React, Next.js
‚úÖ IoT (Internet of Things) applications
‚úÖ File system automation





=====================================================================================================================================================================

‚ùì How do you implement authentication in Node.js?

üëâ Check Autheticartion file

=====================================================================================================================================================================


2. Worker Threads
Definition: Worker threads allow parallel execution within the same process but in separate threads.
Memory: Unlike processes, worker threads share memory with the main thread (via SharedArrayBuffer or message passing).
Communication: Uses message passing, but since they are in the same process, communication is faster than IPC.
Use Case: Suitable for CPU-bound tasks, such as encryption, file processing, or complex calculations.

Example in Node.js: worker_threads module.
```
const { Worker } = require("worker_threads");

const worker = new Worker("./worker.js", { workerData: "Hello from main thread" });

worker.on("message", (msg) => {
    console.log("Message from worker:", msg);
});
```


| ----------------- | -------------------------------------------------------------- | ---------------------------------------------------------- |
| Feature           | Worker Processes                                               | Worker Threads (Worker Threads)                            |
| ----------------- | -------------------------------------------------------------- | ---------------------------------------------------------- |
| **Isolation**     | Completely separate process                                    | Runs in the same process but in a separate thread          |
| **Memory**        | Each process has its own memory                                | Threads share memory (can be an advantage or disadvantage) |
| **Communication** | Uses IPC (slower)                                              | Message passing (faster) or shared memory                  |
| **Performance**   | Higher overhead (process creation and communication)           | Lower overhead (faster execution within the same process)  |
| **Use Case**      | Suitable for CPU-heavy & isolated tasks (e.g., separate users) | Best for parallel computations inside a single process     |
| ----------------- | -------------------------------------------------------------- | ---------------------------------------------------------- |


============================================================================================================================================================

‚ùì What are worker threads in Node.js?


Node.js is single-threaded by default. While this is great for handling I/O operations (like file reading, network requests, or database queries), 
it struggles with CPU-intensive tasks (e.g., large calculations, image processing, or cryptography).

In the "cluster module", we create worker processes, not worker threads. Each worker is a separate process with its own memory space, running independently from the main process (master process).



Worker Threads solve this by enabling true multithreading in Node.js, allowing tasks to run in separate threads without blocking the main event loop.

üöÄ Definition: 

'Worker Threads' in Node.js allow running JavaScript code in parallel threads inside the same process. 
This helps perform CPU-intensive tasks without blocking the main event loop.

üëâ Why use Worker Threads?

Node.js is single-threaded by default.
Heavy computations block the main thread, making the app unresponsive.
Worker Threads allow parallel execution without blocking the main thread.
They are best for CPU-heavy tasks like image processing, ML, and complex calculations.


How Worker Threads Work

Creates 'actual threads' inside a 'single process
Threads share memory, allowing for efficient data processing.
Each worker thread runs in its own V8 execution context.
A worker thread runs in a separate execution context.





‚úÖ Best for: CPU-intensive tasks (e.g., image processing, large computations).
‚ùå Not ideal for: Scaling HTTP servers (since requests are handled in the same process).




=========================================================================================================================================================================

‚ùì What is Node.js Clustering? üöÄ
‚ùìClustering vs. Cluster Module in Node.js


üëâ visit module file

=========================================================================================================================================================================



‚ùì What is the difference between V8 and libuv?


üëâ V8 and libuv are both core parts of Node.js, but they serve different purposes.


1Ô∏è‚É£ V8 executes JavaScript code.
2Ô∏è‚É£ libuv handles async operations (e.g., file reads, network requests).
3Ô∏è‚É£ Once an async task is done, libuv sends the result back to the event loop, which V8 then processes.


Example: How V8 and libuv Work Together

```
console.log("Start"); // V8 executes immediately

setTimeout(() => {
  console.log("Timeout callback"); // Handled by libuv, executes later
}, 1000);

console.log("End"); // V8 executes immediately
```




============================================================================================================================================================


‚ùì How Garbage Collection Works in V8 üöÄ

üëâ Javascript:
-> Garbage collection (GC) is the process of automatically freeing up memory by removing objects that are no longer needed or accessible.
-> The garbage collector identifies and removes objects that are unreachable
-> JavaScript uses an automatic garbage collector, meaning developers don't need to manually manage memory.


example: 
function demo() {
    let obj = {
        name: 'Sample'
    };
    
    obj = null;  // The object "{name: 'Sample'}" is now unreachable
}
Explanation:
Initially, obj holds a reference to an object.
When obj = null; is assigned, the original object becomes unreachable because no variable is referencing it.
The garbage collector will clean up this object during the next GC cyc


üëâ Node js: 

V8 manages 'memory allocation' and 'garbage collection' (GC) automatically. 
It uses a 'generational garbage collection strategy' to efficiently clean up unused memory.

V8 uses two 'main types of garbage collection' based on object lifetime:

‚úÖ Young Generation (Scavenge GC) : 
-> Contains short-lived objects
-> Fast and efficient for short-lived objects.

‚úÖ Old Generation (Mark-Sweep & Mark-Compact GC)
-> Contains long-lived objects that survive multiple Young GC cycles.
-> More expensive than Young GC but necessary for long-lived objects.


V8 divides memory into different heap regions:
| ---------------------------- | -------------------------------- |
| Heap Region                  | Purpose                          |
| ---------------------------- | -------------------------------- |
| New Space (Young Generation) | Stores short-lived objects.      |
| Old Space (Old Generation)   | Stores long-lived objects.       |
| Large Object Space           | Stores large objects separately. |
| Code Space                   | Stores compiled JavaScript code. |
| Map Space                    | Stores metadata about objects.   |
| ---------------------------- | -------------------------------- |





============================================================================================================================================================


 ‚ùìWhat is Deno, and how is it different from Node.js?


Deno is a "modern runtime" for JavaScript and TypeScript, created by "Ryan Dahl" (the original creator of Node.js). It is designed to address some of Node.js's 
shortcomings.

Key Differences Between Deno and Node.js:

Security ‚Äì Deno runs in a sandbox and requires explicit permissions for file, network, and environment access.
Built-in TypeScript Support ‚Äì Deno natively supports TypeScript without needing extra configuration.
Simpler Module System ‚Äì Deno uses "URL-based module imports" instead of node_modules.
Built-in Utilities ‚Äì Deno provides built-in tools like a linter, formatter, and test runner.
Standard Library ‚Äì Deno includes a curated standard library, reducing the need for third-party dependencies.
Deno aims for a more secure and modern developer experience compared to Node.js. üöÄ


============================================================================================================================================================



‚ùì How Node.js Handles Memory Leaks:

A memory leak occurs when a program fails to release unused memory, causing increased memory usage over time. This can lead to performance issues or crashes.


Node.js uses "automatic garbage collection" to free up unused memory. 

However, leaks can still happen due to:
-> Global variables that persist in memory.
-> Event listeners not being removed. Unremoved event listeners that keep references alive.
-> Unclosed timers or intervals (setInterval, setTimeout).
-> Closures and references that prevent garbage collection. Closures holding unnecessary references

How to Prevent Memory Leaks
‚úÖ Use WeakMaps for caching to prevent memory retention.
‚úÖ Remove event listeners when no longer needed. Unremoved event listeners that keep references alive.
‚úÖ Clear timers and intervals using clearTimeout() and clearInterval().
‚úÖ Avoid global variables and use let/const instead of var.
‚úÖ Monitor memory usage with process.memoryUsage() or tools like Chrome DevTools and heapdump.

Proper memory management helps keep Node.js applications efficient and stable. üöÄ



=========================================================================================================================================================================


2Ô∏è‚É£ How do you implement caching in Node.js?

Caching improves performance by storing frequently accessed data in memory, reducing database calls or expensive computations.

Types of Caching in Node.js:

1Ô∏è‚É£ In-Memory Caching

Stores data in the application‚Äôs memory (RAM).
Fastest but not persistent (data is lost on restart).
Best for small datasets or temporary caching.
Example: Using JavaScript objects, Map, or lru-cache.
‚úÖ Use Case: Fast lookups, session data, API responses.


2Ô∏è‚É£ Distributed Caching

Stores cached data in external services like Redis or Memcached.
Can be shared across multiple servers, making it scalable.
Suitable for large-scale applications and persistent caching.
Example: Redis, Memcached.
‚úÖ Use Case: Caching database queries, authentication tokens, real-time data.


3Ô∏è‚É£ Database Caching
Stores cache inside the database to reduce query execution time.
Methods:
Indexing: Speeds up searches.
Query caching: Stores query results.
Materialized views: Precomputed results stored as a table.
‚úÖ Use Case: Repeated database queries, analytics dashboards.


example: 

1Ô∏è‚É£ In-Memory Caching example: 
```
function multiply() {
  let calculationData = {};

  return (num) => {
    if (num in calculationData) {
      console.log(`Data Coming from cache`);
      return calculationData[num];
    }
    else {
      calculationData[num] = num * num;
      return calculationData[num]
    }
  }
}
```


2Ô∏è‚É£ Using Redis for Distributed Caching

'ioredis' is a powerful Redis client for Node.js that provides better performance, scalability, and advanced features compared to the default redis package.
```
const Redis = require('ioredis');
const redis = new Redis();

const cacheMiddleware = (req, res, next) => {
  const { customerId } = req.params;
  if(customerId){
    const cachedCustomer = await redis.get(`customer:${customerId}`);   //customer:1
    if(cachedCustomer)
      return res.status(200).json({ data: cachedCustomer })
  }else{
    const cachedCustomers = await redis.get(`customers`);
    if(cachedCustomers)
      return res.status(200).json({ data: cachedCustomers });
  }

  next();
}


app.get('/', cacheMiddleware, (req, res) => {
  try{
    cost customers = await Customer.find({});
    await redis.set('customers', JSON.stringfy(customers), "EX", 60);  // Cache for 60 seconds
    return res.status(200).json({ data: customers});
  }catch(err){

  }
})

createsimiilar to getCustomer
// await redis.set(`customer:${customerId}`, JSON.stringify(customer), "EX", 60); // Cache for 60 seconds

```




=========================================================================================================================================================================


What is a Load Balancer? ü§î

A load balancer is like a "traffic cop" for your servers. 
It "distributes" incoming requests across multiple servers so that no single server gets overloaded. 
This improves speed, reliability, and scalability of your application.

Why Do We Need a Load Balancer? üö¶
Imagine you have a website or an app with millions of users. If all users send requests to one server, it will crash under heavy traffic. 
Instead, a load balancer will:
‚úÖ Distribute traffic evenly across multiple servers.
‚úÖ Prevent overload & crashes by redirecting requests if a server fails.
‚úÖ Improve speed by sending users to the nearest or least busy server.
‚úÖ Ensure high availability so users always get a response.

How Does a Load Balancer Work? ‚öôÔ∏è
User requests a website (e.g., opening example.com).
The request first goes to the load balancer instead of a direct server.
The load balancer decides which server should handle the request.
The server processes the request and sends a response back to the user.



Types of Load Balancers üèóÔ∏è


1Ô∏è‚É£ NGINX (Software Load Balancer) üñ•Ô∏è

NGINX is an open-source web server that can also work as a load balancer.
Nginx is a 'web server' that can also be used as a 'reverse proxy', 'load balancer', mail proxy and 'HTTP cache'. 
It is installed on a server and distributes traffic to backend servers.
Good for small to medium-sized applications.

üîπ Example: A company has 3 servers running a web app. NGINX balances traffic among them:
```
User  ‚Üí  NGINX Load Balancer  ‚Üí  Server 1 / Server 2 / Server 3
```

2Ô∏è‚É£ AWS ALB (Amazon Application Load Balancer) ‚òÅÔ∏è

AWS ALB is a cloud-based load balancer offered by Amazon Web Services.
It works at the application layer (Layer 7) and routes traffic based on URL paths.
Ideal for large-scale cloud applications.

üîπ Example: An e-commerce app has different servers for products and payments. AWS ALB routes traffic accordingly:
```
User  ‚Üí  AWS ALB  
      ‚Üí  `/products` ‚Üí Product Server  
      ‚Üí  `/checkout` ‚Üí Payment Server 
```


Final Thoughts üöÄ
If you're managing your own servers ‚Üí Use NGINX.
If you're using AWS and need a scalable solution ‚Üí Use AWS ALB.
Both ensure high availability, performance, and reliability for your app.


Reverse Proxy vs. Load Balancer: Are They the Same?
A Reverse Proxy is server that forwards client requests to one or more backend servers.
A Load Balancer can be a dedicated hardware device or software that distributes traffic among multiple servers.

Key Difference:
A reverse proxy can act as a load balancer, but a load balancer is not always a reverse proxy.
A load balancer's main job is distributing traffic, while a reverse proxy provides additional features like security, caching, and SSL termination.

| Feature  | Reverse Proxy üõ°Ô∏è      | Load Balancer ‚öñÔ∏è                      |
| Examples | Nginx, Apache, HAProxy | NGINX Load Balancer, AWS ELB, HAProxy |


=========================================================================================================================================================================

‚ùì What is a reverse proxy, and why would you use one with Node.js?

üëâ A reverse proxy is a 'server' that sits between clients and backend servers, forwarding client requests to the appropriate backend service.

Why Use a Reverse Proxy with Node.js?
‚úÖ Load Balancing ‚Äì Distributes traffic across multiple Node.js instances.
‚úÖ Security ‚Äì Hides internal server details, preventing direct exposure.
‚úÖ SSL Termination ‚Äì Handles HTTPS encryption, offloading SSL processing.
‚úÖ Caching & Compression ‚Äì Improves response time and reduces load.
‚úÖ Rate Limiting & DDoS Protection ‚Äì Filters and blocks malicious requests.


Reverse Proxy vs. Load Balancer: Are They the Same?
A Reverse Proxy is server that forwards client requests to one or more backend servers.
A Load Balancer can be a dedicated hardware device or software that distributes traffic among multiple servers.

Key Difference:
A reverse proxy can act as a load balancer, but a load balancer is not always a reverse proxy.
A load balancer's main job is distributing traffic, while a reverse proxy provides additional features like security, caching, and SSL termination.

| Feature  | Reverse Proxy üõ°Ô∏è       | Load Balancer ‚öñÔ∏è                      |
| Examples | Nginx, Apache, HAProxy | NGINX Load Balancer, AWS ELB, HAProxy |

=========================================================================================================================================================================


üöÄ How can you optimize API response time in a Node.js application?


1Ô∏è‚É£ Implement Caching (Memory & Redis)
Store frequently requested data in memory (Map, lru-cache) or Redis.
Reduces redundant database queries.


2Ô∏è‚É£ Optimize Database Queries
Use Indexing for frequently queried fields.

Use pagination (LIMIT, OFFSET) to fetch only required data.

4Ô∏è‚É£ Use Compression (Gzip, Brotli)
Reduce response payload size to improve speed.
```
const compression = require("compression");
app.use(compression());
```
‚úÖ Result: Smaller response size, faster loading


5Ô∏è‚É£ Optimize Middleware & Reduce Unnecessary Code
Remove unused middleware.
Avoid blocking operations in middleware.

‚úÖ Result: Faster request processing.


6Ô∏è‚É£ Use Load Balancing & Clustering

Use Node.js Clustering to utilize multiple CPU cores.
Deploy load balancers (NGINX, AWS ALB) for distributing traffic.


7Ô∏è‚É£ Reduce Payload Size (Use Proper Response Formats)
Use GraphQL or select only required fields in REST APIs.

Example (Selecting Required Fields in MongoDB):
```
const user = await User.findById(userId).select("name email");
```
‚úÖ Result: Lighter responses, faster API calls.


8Ô∏è‚É£ Use HTTP/2 for Faster Request Handling
HTTP/2 allows multiplexing, reducing the number of requests.
‚úÖ Setup Nginx as a reverse proxy to enable HTTP/2.

9Ô∏è‚É£ Implement Connection Pooling in Databases
"Reuse" database connections instead of "creating" a new one for each request.
```
const connectDB = async () => {
  try {
    await mongoose.connect("mongodb://localhost:27017/myDatabase", {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      maxPoolSize: 10, // Set max connections in the pool
      minPoolSize: 5,  // Maintain at least 5 connections
      serverSelectionTimeoutMS: 5000, // Timeout if the server is unreachable
      socketTimeoutMS: 45000, // Close unused connections after 45s
    });
    console.log("MongoDB Connected with Connection Pooling ‚úÖ");
  } catch (err) {
    console.error("MongoDB Connection Failed ‚ùå", err);
  }
};
```

Key Connection Pooling Settings:
|---------------------------|-----------------------------------------------------------|
| Option                    | Description                                               |
|---------------------------|-----------------------------------------------------------|
| `maxPoolSize`             | Maximum number of connections in the pool (default: 100). |
| `minPoolSize`             | Minimum connections to keep open.                         |
| `serverSelectionTimeoutMS`| Time to wait for a database connection before failing.    |
| `socketTimeoutMS`         | How long to keep an idle connection open before closing.  |
|---------------------------|-----------------------------------------------------------|

Why is Connection Pooling Important?
‚úÖ Prevents excessive database connections (avoids MongoServerError: Too many connections).
‚úÖ Reduces request latency (reuses open connections).
‚úÖ Handles concurrent users better in high-traffic apps.



üîü Monitor & Optimize Performance
Use New Relic, PM2, or Datadog for API performance monitoring.
Identify slow endpoints using console.time() or profiling tools.
‚úÖ Result: Continuous optimization.





=========================================================================================================================================================================



1Ô∏è‚É£ What are the core modules in Node.js?

check module file.



=========================================================================================================================================================================


2Ô∏è‚É£ How do you install Node.js and check its version?

1. Install Node.js:
Download the latest LTS version from Node.js official website.
Run the installer and follow the setup instructions

2. Verify Installation
After installation, open Command Prompt (Windows) or Terminal (macOS/Linux) and run:
```
node -v   # Check Node.js version
npm -v    # Check npm (Node Package Manager) version
```

‚úî If installed correctly, it will display the installed versions, e.g., v18.17.1. üöÄ


Note: 
As of March 24, 2025, the latest Long-Term Support (LTS) version of Node.js is v22.14.0

Node.js v18, which was released on: October 25, 2022 (became LTS)
Node.js v20, which was released on: October 24, 2023 (became LTS)


=========================================================================================================================================================================



3Ô∏è‚É£ What is npm? How does it work?


NPM : 

-> NPM Stands for "Node package manager".
-> npm is the default "package manager" for Node.js. 
-> It installed automatically with Node.js.
-> It helps developers install, manage, and share JavaScript packages (libraries or dependencies) easily.
-> We use NPM to download  3rd-party packages from NPM registry. as well as to create a node application.
-> NPM registry have millions of npm packages that you can download according to your application need.
-> popular npm packages are express, mongoose, nodemon, dotenv, bcrypt, helmet, joi

// Install a package
npm i <packageName>

// Install a specific version of a package 
npm i <packageName>@<version>

// Install a package as a development dependency
npm install <packageName> --save-dev

// Uninstall a package
npm un <packageName>

// List installed packages 
npm list ‚Äîdepth=0

// View outdated packages
npm outdated

// Update packages 
npm update

// bypass peer dependency conflicts
npm i --legacy-peer-deps 

If one package depends on another and you update a package, it can create dependency conflicts when the required versions don‚Äôt match.
This can cause installation failures because npm strictly enforces peer dependencies in v7+. To bypass these conflicts, we use above command.



=========================================================================================================================================================================



3Ô∏è‚É£ several ways to create a Node.js application:

There are several ways to create a Node.js application, depending on your project requirements. Here are the most common methods:

1Ô∏è‚É£ Using npm init (Manual Setup)
The traditional way to start a Node.js application by manually setting up a package.json file.
```
npm init
```

2Ô∏è‚É£ Using npx (Boilerplate Generator)
npx runs CLI tools without installing them globally.
```
npx express-generator my-app
```

3Ô∏è‚É£ Using a Custom JavaScript File (Simple Script)
üëâ You can create a simple Node.js app without npm.
Create a new file, app.js
Write this code:
```
console.log("Hello, Node.js!");
```
RUN > node app.js


4Ô∏è‚É£ Using a Framework (e.g., Express.js)
üëâ If building a web server, Express.js is the most common choice.



=========================================================================================================================================================================



2Ô∏è‚É£ What is the purpose of package.json?

package.json is the "main configuration file" for a Node.js project.
 It contains metadata, dependencies, and scripts for he project.

üîπ Purpose of package.json
Defines the project name, version, and description.
Lists dependencies required to run the project.
Specifies scripts to automate tasks (npm start, npm test, etc.).
Helps in versioning and package management.

üõ† Example of package.json
{
  "name": "my-app",
  "version": "1.0.0",
  "description": "A sample Node.js project",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}



üìå 2. What is package-lock.json?
package-lock.json is automatically generated when you install dependencies using npm install. 
It locks the exact versions of installed packages.

üîπ Purpose of package-lock.json
Ensures the exact same package versions are installed on different systems.
Improves dependency resolution speed in future installations.
Helps team members and CI/CD pipelines install the same dependency tree.
üõ† Example of package-lock.json (Simplified)

‚úÖ Always commit both to Git to maintain a stable project setup! üöÄ




=========================================================================================================================================================================


8Ô∏è‚É£ What are global objects in Node.js?


üëâ In Node.js, global objects are built-in objects that are available in all modules and can be accessed anywhere in the application without importing them.
üëâ The main global object is 'global', similar to 'window' in browsers.
üëâ Useful built-in objects include process, console, setTimeout(), and more.

- **Global objects** are properties of `global` (e.g., `global.process`).  


## üîπ List of Important Global Objects in Node.js
|-----------------------|---------------------------------------------------------------------------|
| Global Object         | Description                                                               |
|-----------------------|---------------------------------------------------------------------------|
| `global`              | The root object that contains all global variables.                       |
| `process`             | Provides information about the **current Node.js process**.               |
| `console`             | Provides methods like `console.log()` for logging messages.               |
| `setTimeout()`        | Executes a function **after a delay**.                                    |
| `setInterval()`       | Executes a function **repeatedly at a fixed interval**.                   |
| `setImmediate()`      | Executes a function **immediately after the current execution cycle**.    |
| `clearTimeout()`      | Cancels a timeout set by `setTimeout()`.                                  |
| `clearInterval()`     | Cancels an interval set by `setInterval()`.                               |
| `clearInterval()`     | Cancels an interval set by `setInterval()`.                               |
|-----------------------|---------------------------------------------------------------------------|


üõ†Ô∏è Examples of Global Objects

1Ô∏è‚É£ global (Root Object)
console.log(global); // Prints all global properties

4Ô∏è‚É£ process (System Info & Environment Variables)
console.log(process.env.NODE_ENV); // Prints the environment (e.g., 'development')
console.log(process.version); // Prints Node.js version
console.log(process.platform); // Prints OS platform (e.g., 'win32', 'linux')


============================================================================================================================================================







process:
The process object is a global object in Node.js that provides information and control over the current Node.js process
It allows interaction with the environment, system, and command-line arguments.


üõ†Ô∏è Main Operations of process

1Ô∏è‚É£ Get Node.js and System Info
console.log("Node Version:", process.version);    // Node Version: v18.16.0
console.log("Platform:", process.platform);         // Platform: win32


2Ô∏è‚É£ Read Environment Variables (process.env)
console.log("NODE_ENV:", process.env.NODE_ENV);
console.log("Custom Variable:", process.env.MY_VAR);


3Ô∏è‚É£ Get Command-Line Arguments (process.argv)
console.log("Arguments:", process.argv);
Running in Terminal > node app.js hello world

5Ô∏è‚É£ Process Events (process.on())

üìå Handle Process Exit
```
process.on("exit", (code) => {
  console.log(`Process exited with code: ${code}`);
});
```
üëâ This event triggers before the process exits, allowing cleanup tasks.

üìå Handle Uncaught Exceptions
```
process.on("uncaughtException", (err) => {
  console.error("Uncaught Error:", err);
});
```
üëâ Prevents the app from crashing immediately due to unhandled errors.


6Ô∏è‚É£ Exit the Process (process.exit())
```
console.log("Exiting process...");
process.exit(0); // 0 means success, any other number means error
```
üëâ Useful when you need to terminate the script manually.




============================================================================================================================================================


1Ô∏è‚É£ How do you import and export modules in Node.js?


In Node.js, we use modules to organize code into reusable files. There are two ways to import/export modules:
1Ô∏è‚É£ CommonJS (require & module.exports) ‚Äì Default in Node.js
2Ô∏è‚É£ ES Modules (import & export) ‚Äì Modern approach


‚úÖ Use import() for lazy-loading modules dynamically.

üìå Which One Should You Use?
Use CommonJS if working with traditional Node.js projects.
Use ES Modules for modern projects and browser compatibility.

Execution:
(CommonJS)Synchronous (loads modules immediately)	
(ES Modules)Asynchronous (supports top-level await)

Browser Support (Where It Works):
CommonJS    :‚ùå No (Node.js only)	
ES Modules  :‚úÖ Yes (Works in both Node.js and Browsers)


File Extension	
CommonJS:       .js	
ES Modules:     .js (with "type": "module") or .mjs


üöÄ Both methods allow you to create modular, reusable code in Node.js!


üîπ 1. Using CommonJS (Default in Node.js)
‚úÖ Exporting with module.exports
```
function add(a, b) {
  return a + b;
}
module.exports = add;
```


‚úÖ Importing with require
```
const add = require("./math");
console.log(add(5, 3)); // Output: 8
```

üîπ Exporting Multiple Values
```
module.exports = {
  add: (a, b) => a + b,
  multiply: (a, b) => a * b,
};
```

üîπ Importing Multiple Values
```
const math = require("./math");
console.log(math.add(5, 3)); // Output: 8
console.log(math.multiply(5, 3)); // Output: 15
```




üîπ 2. Using ES Modules (import/export)
üìù Note: ES Modules require "type": "module" in package.json


‚úÖ Exporting with export
```
export function add(a, b) {
  return a + b;
}
export function multiply(a, b) {
  return a * b;
}
```

‚úÖ Importing with import

import { add, multiply } from "./math.js";   or
import { add } from "./math.js";
console.log(add(5, 3)); // Output: 8
console.log(multiply(5, 3)); // Output: 15


üîπ Exporting a Default Function
```
export default function add(a, b) {
  return a + b;
}
```

üîπ Importing a Default Export
```
import add from "./math.js";
console.log(add(5, 3)); // Output: 8
```


============================================================================================================================================================



1Ô∏è‚É£ How do you create a simple HTTP server in Node.js?


üìå Creating a Simple HTTP Server in Node.js

In Node.js, you can create an HTTP server using the built-in http module.

üîπ Steps to Create an HTTP Server
Import the http module
Create a server with http.createServer()
Define a request handler function
Listen on a specific port using server.listen()


üîπ Handling Different Routes
```
const http = require("http");

const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/html" });

  if (req.url === "/") {
    res.end("<h1>Welcome to Home Page</h1>");
  } else if (req.url === "/about") {
    res.end("<h1>About Page</h1>");
  } else {
    res.writeHead(404);
    res.end("<h1>404 Not Found</h1>");
  }
});

server.listen(3000, () => {
  console.log("Server running on http://localhost:3000");
});

```



============================================================================================================================================================



### **üìå Difference Between `fs.readFileSync()` and `fs.readFile()` in Node.js**  

Both methods are used to **read files** in Node.js but differ in how they handle execution.

|-----------------------------------|-----------------------------------------------|----------------------------------------------------|
| Feature                           | `fs.readFileSync()`                           | `fs.readFile()`                                    |
|-----------------------------------|-----------------------------------------------|----------------------------------------------------|
| **Execution Type**                | Synchronous (Blocking)                        | Asynchronous (Non-Blocking)                        |
| **Blocks Code Execution?**        | ‚úÖ Yes                                        | ‚ùå No                                             |
| **Callback Required?**            | ‚ùå No                                         | ‚úÖ Yes                                            |
| **Performance**                   | üö´ Slower for large files (blocks event loop) | ‚úÖ Faster (does not block event loop)             |
| **Use Case**                      | When immediate file reading is needed         | For better performance, especially in servers      |
|-----------------------------------|-----------------------------------------------|----------------------------------------------------|



‚úÖ Example of fs.readFileSync() (Synchronous)
```
const fs = require("fs");
const data = fs.readFileSync("example.txt", "utf8");
console.log(data);
```
üìù Explanation:
Blocks execution until the file is read.
The next line does not execute until the file reading is complete.


‚úÖ Example of fs.readFile() (Asynchronous)

```
fs.readFile("example.txt", "utf8", (err, data) => {
  if (err) {
    console.error("Error reading file:", err);
    return;
  }
  console.log(data); // Output: File content
});
```

üìù Explanation:
Does not block execution.
Uses a callback function to handle the file content.



üìå When to Use Which?
‚úÖ Use fs.readFileSync()
When reading small files.
When execution must wait for file reading (e.g., configuration files).

‚úÖ Use fs.readFile()
When handling large files or performing multiple tasks.
For better performance, especially in web servers.

üöÄ For high-performance applications, always prefer fs.readFile() to avoid blocking the event loop!

============================================================================================================================================================


8Ô∏è‚É£ What is middleware in Express.js?

üëâ So an express application is essentially nothing but a bunch of middleware functions.
üëâ Middleware is a function that runs before the actual route handler.
üëâ Middleware is basically a function that has access to the request (req), response (res) and either returns a response to the client by terminating req processig 
pipeline or passes control to another middleware function using next().
üëâ at runtime, when we receive a request on the server that request goes through a pipeline called "Request Processing Pipeline". In this pipeline we have one or more 
middleware functions. Each middleware function is capable of terminates the request response cycle.
üëâ Middleware functions are invoked in the order they are defined and are capable of modifying the request and response objects, 
as well as passing control to the next middleware function in the stack.
üëâ Middleware allow programmer to add functionality to the request response cycle such as authentication, logging, error handling and many more.
üëâ if you use lots of middleware functions inside your request processing pipeline then it will slow down your application.
üëâ Middleware can be defined globally, for all routes, or can be defined for specific routes or groups of routes. 
üëâ app.use() method is used for adding middleware function.


üîπ Types of Middleware in Express.js
1Ô∏è‚É£ Built-in Middleware ‚Äì Provided by Express
2Ô∏è‚É£ Third-party Middleware ‚Äì Installed via npm
3Ô∏è‚É£ Custom Middleware ‚Äì Created by developers


üîπ 1. Built-in Middleware
‚úÖ Example: express.json() Middleware
```
app.use(express.json()); // Parses JSON request body
``` 
üöÄ `express.json()` middleware parses 'the JSON data' and makes it available as a 'JavaScript object' in the `req.body` property. so you don't have to manually 
parse the incoming data using `JSON.parse()`. 


‚úÖ Example: app.use(express.urlencoded({ extended: true }))

üëâ is used to parse incoming URL-encoded data from the request body and convert it into js.
üëâ This is used in traditional html pages where react is not used.
üëâ If you're submitting a React form then you typically send JSON data, not x-www-form-urlencoded. so no need to use this middleware but 
make sure to use express.json().


‚úÖ Example: app.use(express.static('public'));

üëâ It is used to serve static files (like HTML, CSS, JavaScript, images, etc.) from the "public" directory.
üëâ The folder does not have to be named "public". You can name it anything, but you must use the same name in express.static().
for ex: app.use(express.static("assets"));

my-app/
‚îÇ‚îÄ‚îÄ server.js
‚îÇ‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ styles.css
‚îÇ   ‚îú‚îÄ‚îÄ script.js
‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ       ‚îú‚îÄ‚îÄ logo.png

app.use(express.static("public"));   // static file are aserve from root "/"

URL                                     Serves File
--------------------------------------  ------------------------
http://localhost:3000/                  public/index.html
http://localhost:3000/styles.css        public/styles.css
http://localhost:3000/script.js         public/script.js
http://localhost:3000/images/logo.png   public/images/logo.png


üîπ What If You Want a Custom Path?
You can serve static files from a custom URL path like /static: 
app.use("/static", express.static("public"));

Now, files must be accessed like this:
http://localhost:3000/static/styles.css
http://localhost:3000/static/images/logo.png



üîπ 2. Third-Party Middleware

You can install middleware via npm

‚úÖ Example: Using morgan for Logging
```
app.use(morgan("tiny")); // Logs request details
```
üöÄ morgan logs every request with useful details.



üîπ 3. Custom Middleware
You can define your own middleware
like authenticatio, logger, error


code:
```
const express = require("express");
const app = express();

function middleware(req, res, next) {
  console.log("Front Middleware");
  next();
}

function middleware1(req, res, next) {
  console.log("Middleware 1");
  next();
}

function middleware2(req, res, next) {
  console.log("Middleware 2");
  next();
}

function middleware3(req, res, next) {
  console.log("Last Middleware");
  next();
}

app.use(middleware);
app.get("/part1", [middleware1, middleware2], (req, res, next) => {
  res.send("2 middleware function : [middleware1, middleware2]");
  next();
});
app.get("/part2", middleware1, (req, res) => {
  res.send("1 middleware function: middleware1 -> we terminate req-res cycle");
});
app.use(middleware3);

const port = 5000;
app.listen(port, () => {
  console.log(`Server is listening on port ${port}`);
});

```

============================================================================================================================================================

6Ô∏è‚É£ How do you handle errors in Node.js?


üîπ 1. Using Try-Catch
```
try {
  let result = JSON.parse("invalid JSON");
} catch (error) {
  console.error("Error parsing JSON:", error.message);
}
```

üîπ 2. Using callback
```
fs.readFile("nonexistent.txt", "utf8", (err, data) => {
  if (err) {
    console.error("File read error:", err.message);
    return;
  }
  console.log(data);
});
```

‚úÖ Using .catch()

```
fs.readFile("nonexistent.txt", "utf8")
  .then((data) => console.log(data))
  .catch((error) => console.error("Promise error:", error.message));
```

üîπ 4. Global Error Handling

‚úÖ Handling Uncaught Exceptions
```
process.on("uncaughtException", (err) => {
  console.error("Uncaught Exception:", err.message);
  process.exit(1); // Exit the process (optional)
});
```

‚úÖ Handling Unhandled Promise Rejections
```
process.on("unhandledRejection", (err, promise) => {
  console.error("Unhandled Rejection:", err.message);
});
```


üîπ Express.js Error Handling Middleware
```
const express = require("express");
const app = express();

// Middleware to simulate an error
app.get("/", (req, res, next) => {
  next(new Error("Something went wrong!"));
});

// Error handling middleware
app.use((err, req, res, next) => {
  res.status(500).json({ error: err.message });
});

app.listen(3000, () => console.log("Server running on port 3000"));
```



============================================================================================================================================================



9Ô∏è‚É£ How can you handle file uploads in Node.js?

üìå Handling File Uploads in Node.js
To handle file uploads in a Node.js application, we typically use multer, a popular middleware for handling multipart/form-data in Express.


Multer is a node.js middleware for handling multipart/form-data, which is primarily used for uploading files. 
NOTE: Multer will not process any form which is not multipart (multipart/form-data).


Normal File Upload: 

üîπ Allowed File Types with Your Code:
‚úÖ Images (.jpg, .jpeg, .png, .gif, .svg, .webp)
‚úÖ Documents (.pdf, .doc, .docx, .txt)
‚úÖ Spreadsheets (.xls, .xlsx, .csv)
‚úÖ Videos (.mp4, .avi, .mov)
‚úÖ Audio Files (.mp3, .wav)
‚úÖ Other Files (.zip, .rar, .json, .xml)


üöÄ storage: 
If you want more control over your uploads, you'll want to use the "storage" option instead of "dest".
Multer ships with storage engines "DiskStorage" and "MemoryStorage"; More engines are available from third parties.


### **üéØ When to Use Which?**
|-----------------------------------|-----------------------------------------------|----------------------------------------------------------------------------|
| Storage Engine                    | `diskStorage`                                 | `memoryStorage`                                                            |
|-----------------------------------|-----------------------------------------------|----------------------------------------------------------------------------|
| **Where files are stored?**       | Saves files to disk (filesystem)              | Stores files in memory (RAM) as a `Buffer`                                 |
| **How files are accessed?**       | Stored in a specific directory                | Stored in `req.file.buffer` as binary data                                 |
| **Use Case**                      | When you need to save files permanently       | When you need to process files immediately                                 |
| **Performance**                   | Slightly slower (writes to disk)              | Faster (stored in RAM, no disk I/O)                                        |
| **Example Use Cases**             | Uploading profile pictures, saving documents  | Image processing, sending files to cloud storage (e.g., AWS S3, Cloudinary)|
|-----------------------------------|-----------------------------------------------|----------------------------------------------------------------------------|



1Ô∏è‚É£. DiskStorage
-> The disk storage engine gives you full control on storing files to disk.
code: 
```
const storage = multer.diskStorage({
    destination: function(req, file, cb){
        cb(null, 'uploads/')
    },
    filename: function(req, file, cb){
        cb(null, file.originalname)
    }
})
const upload = multer({ storage: storage })
```

There are two options available, "destination" and "filename". 
They are both functions that determine where the file should be stored.

"destination": destination is used to determine within which folder the uploaded files should be stored. 
This can also be given as a string (e.g. '/tmp/uploads'). If no destination is given, the operating system's default directory for temporary files is used.

"filename": filename is used to determine what the file should be named inside the folder. If no filename is given, each file will be given a random name that 
doesn't include any file extension.
Note: Multer will not append any file extension for you, your function should return a filename complete with an file extension.



2Ô∏è‚É£ MemoryStorage: 
The memory storage engine stores the files in memory as Buffer objects. It doesn't have any options.
```
const storage = multer.memoryStorage()
const upload = multer({ storage: storage })
```
When using memoryStorage, the uploaded file is not saved to disk but stored in RAM as a buffer inside req.file.buffer. 
You can access it and perform operations like processing, uploading to cloud storage, or converting the file.
If you're uploading files to Cloudinary (or any cloud storage like AWS S3, Firebase, etc.), you should use memoryStorage in Multer.




How to Use multipart/form-data in Postman for File Uploads?
1Ô∏è‚É£ Open Postman and Create a POST Request
Method: POST
URL: http://localhost:3000/customer (or your API endpoint)


2Ô∏è‚É£ Select Body Tab
Click on Body.

Select "form-data".

Now add your fields:

---------------------------------
Key	        Value	        Type
---------------------------------
name	    John Doe	    Text
profilePic	(Select file)	File
---------------------------------

For text fields: Select Text from the dropdown.
For file upload: Select File and choose a file from your system


3Ô∏è‚É£ Send the Request
Click Send.
Your API should receive:
```
req.body: { name: "John Doe" }
req.file: { originalname: "myphoto.jpg", mimetype: "image/jpeg", path: "uploads/myphoto.jpg" }
```


4Ô∏è‚É£ Verify req.body and req.file in Your Express App
If req.body is undefined, make sure you have added:
```
app.use(express.json());
```




final Example : 

```

const express = require('express');
const app = express();
const multer = require('multer');
 const storage = multer.diskStorage({
     destination: function(req, file, cb){
         cb(null, 'uploads/')
     },
     filename: function(req, file, cb){
         cb(null, file.originalname)
     }
 }); // use it if you want to keep files on server file system

const storage = multer.memoryStorage();  // use it for uploading images on cloudinary, aws
// const upload = multer({ dest: 'uploads/' });  // simple
const upload = multer({ storage: storage });



app.use(express.json()); // Enable JSON parsing (if needed)\

// accepting single file from input name 'profilePic'
app.post('/api/upload', upload.single('profilePic'), (req, res) => {
    const file = req.file;
    return res.status(201).json({ file })
});


// accepting multiple file from input name 'photos' with maximum upload limit of 5
app.post('/api/photos/upload', upload.array('photos', 5), (req ,res) => {
    const photos = req.files;
    return res.status(201).json({ photos })
});


// accepting multiple files from different input fields having names ('avatar', 'gallery')
const cpUpload = upload.fields([{ name: 'avatar', maxCount: 1}, { name: 'gallery', maxCount: 5}])
app.post('/cool-profile', cpUpload, (req, res) => {
    const files = req.files;
    return res.status(201).json({ files });
});


// select profileImage along with data.
// go to postman, Select Body Tab, Select form-data, Now add your fields: name, age, profilePic
// For text fields: Select Text from the dropdown. For file upload: Select File and choose a file from your system.
app.post('/api/customer', upload.single('profilePic'), (req, res) => {
    console.log('file', req.file);  // ‚úÖ Works fine
    console.log('body', req.body);  // ‚úÖ Should now contain text fields
    return res.status(201).json({ file: req.file, body: req.body });
});


app.listen(5000, () => {
    console.log(`server listning on port 5000`);
})

```








============================================================================================================================================================


3Ô∏è‚É£ What is Buffer in Node.js?

visit module file.



============================================================================================================================================================


3Ô∏è‚É£ How do you handle command-line arguments in a Node.js script?

üìå Handling Command-Line Arguments in Node.js
In Node.js, you can handle command-line arguments using the "process.argv" array or third-party packages like "yargs" and "commander".

üîπ 1. Using process.argv (Built-in)
The process.argv array contains command-line arguments passed to the Node.js script.

‚úÖ Example
// script.js
console.log(process.argv);
Run the script:

node script.js arg1 arg2
Output:
[
  'C:\\Program Files\\nodejs\\node.exe', // Node.js path
  'C:\\Users\\User\\script.js',         // Script path
  'arg1',                               
  'arg2'
]
üìå The first two elements are always:
1Ô∏è‚É£ Path to the Node.js executable
2Ô∏è‚É£ Path to the script being executed
3Ô∏è‚É£ Arguments start from index 2

‚úÖ Accessing Arguments

const args = process.argv.slice(2); // Remove first two elements
console.log("Arguments:", args);
Run:
```
node script.js hello world
```

Output:
Arguments: [ 'hello', 'world' ]





============================================================================================================================================================


üìå Difference Between __dirname and __filename in Node.js

Both __dirname and __filename are global variables in Node.js that provide information about the current script's location.


## **üîπ Global Variables (NOT Global Objects)**
|-------------------|----------------------------------------------------------------|
| Global Variable   | Description                                                    |
|-------------------|----------------------------------------------------------------|
| `__dirname`       | Returns the **absolute directory path** of the current script. |
| `__filename`      | Returns the **absolute file path** of the current script.      |
|-------------------|----------------------------------------------------------------|




2Ô∏è‚É£ __dirname (Current Directory Path)
console.log(__dirname); // Example: /home/user/project

3Ô∏è‚É£ __filename (Current File Path)
console.log(__filename); // Example: /home/user/project/index.js


============================================================================================================================================================



### **üìå Difference Between Absolute Path and Relative Path**  

|-------------------|----------------------------------------------------------------------------|
| Type              | Description                                                                |   
|-------------------|----------------------------------------------------------------------------|
| **Absolute Path** | The full path from the **root directory** to a file or folder.             |
| **Relative Path** | The path **relative** to the current working directory or script location. |
|-------------------|----------------------------------------------------------------------------|

---

üîπ Absolute Path
‚úÖ Always starts from the root (`/` in Linux/macOS, `C:\` in Windows)  
‚úÖ Same path regardless of where the script is executed  

üîπ Example:
- Windows: `C:\Users\John\Documents\file.txt`

‚úÖ Example in Node.js
```
const path = require("path");

console.log(path.resolve("file.txt"));// Absolute path example
```
Output (depends on where you run it):
```
C:\Users\John\project\file.txt  (Windows)
```

---

üîπ Relative Path
‚úÖ Depends on the current working directory (`cwd`)  
‚úÖ Shorter and flexible  

üîπ Example:  
- `./file.txt` ‚Üí Refers to `file.txt` in the **current folder**  
- `../file.txt` ‚Üí Moves **one directory up** before looking for `file.txt`  

‚úÖ Example in Node.js
```js
const path = require("path");

// Relative path
console.log(path.join(__dirname, "file.txt"));
```
üìå `__dirname` helps resolve relative paths safely.

---

### üìå Key Differences**
|---------------------------|-------------------------------|--------------------|
| Feature                   | Absolute Path                 | Relative Path      |
|---------------------------|-------------------------------|--------------------|
| Starts from?              | Root directory (`C:\`, `/`)   | Current directory  |
| Changes with location?    | ‚ùå No                         | ‚úÖ Yes            |
| Example (Windows)         | `C:\Users\John\file.txt`      | `./file.txt`       |
|---------------------------|-------------------------------|--------------------|

üöÄ **Use absolute paths when you need a fixed location, and relative paths for flexibility!**






============================================================================================================================================================



üìå Debugging a Node.js Application in Development & Production:




üîπ Debugging in Development


1Ô∏è‚É£ Using console.log() (Basic Debugging)

console.log("User Data:", user);


4Ô∏è‚É£ Using VS Code Debugger

Open your project in VS Code.
Go to Run & Debug (Ctrl + Shift + D).
Click "create launch.json file" ‚Üí Select "Node" -> then delete everything inside "configurations" array and type "cmd" and enter first suggestion 
"Run npm start in a debug terminal". then inside "command" property add "npm run dev" then click on "Run npm start" button in top left panal

ex: launch.json file:
{
    "version": "0.2.0",
    "configurations": [
        {
            "command": "npm run dev",
            "name": "Run npm start",
            "request": "launch",
            "type": "node-terminal"
        }
    ]
}





üîπ Debugging in Production:


1Ô∏è‚É£ Using winston for Logging
3Ô∏è‚É£ Using Error Tracking (e.g., Sentry)



============================================================================================================================================================


3Ô∏è‚É£ How do you use environment variables in a Node.js application?


Environment variables store configuration settings (like database credentials, API keys) outside your code, making apps more secure and flexible.


üîπ 1Ô∏è‚É£ Accessing Environment Variables
Node.js provides process.env to access environment variables inside a code.

‚úÖ Example:
console.log(process.env.NODE_ENV); // Output: development (if set)
console.log(process.env.PORT);     // Output: 5000 (if set)


There are multiples ways thjaty you can pass environmental variables.

üîπ 2Ô∏è‚É£ Setting Environment Variables

‚úÖ Temporary (Command Line)

Windows (PowerShell): 
```
PS C:\Users\user\Desktop\ooo> $env:PORT=8000; node .\server.js
```

üìå These are temporary and reset after the terminal closes


3Ô∏è‚É£ Using a .env File (Best Practice)
Using a .env file makes configuration easier.
‚úÖ Step 1: Install dotenv


üîπ 4Ô∏è‚É£ Setting Environment Variables in package.json (Scripts)
Define variables in package.json scripts.
```
"scripts": {
  "start": "NODE_ENV=production node index.js"
}
```


============================================================================================================================================================



1Ô∏è‚É£  Explain the difference between process.nextTick() and setImmediate().

Both process.nextTick() and setImmediate() schedule callbacks to execute asynchronously, but they have key differences in execution order.

üìå process.nextTick() Has higher priority than setImmediate().
üìå process.nextTick() executes before setImmediate().


‚úÖ Example:
```
console.log("Start");

setImmediate(() => console.log("Executed in setImmediate"));
process.nextTick(() => console.log("Executed in process.nextTick"));

console.log("End");
```

üìù Output:
```
Start
End
Executed in process.nextTick
Executed in setImmediate
```


## **üîπ 4Ô∏è‚É£ When to Use?**
|---------------------- |-----------------------------------------------|----------------------------------         |
| Feature               | `process.nextTick()`                          | `setImmediate()`                          |        
|---------------------- |-----------------------------------------------|----------------------------------         |
| **Execution Timing**  | Before the event loop continues               | In the next event loop iteration          |
| **Priority**          | Higher (executes before I/O)                  | Lower (executes after I/O)                |
| **Use Case**          | For critical operations that must run ASAP    | For executing code after I/O operations   |
|---------------------- |-----------------------------------------------|----------------------------------         |



============================================================================================================================================================


‚ùì Streams in Node.js:

visit module file.


============================================================================================================================================================

‚ùì How do you handle large file uploads efficiently in Node.js?

 üëâ
 
 Uploading large files in Node.js can be challenging due to memory constraints. Instead of loading the entire file into memory, we use streaming and chunked uploads to handle large files efficiently.

Best Practices for Handling Large File Uploads
‚úÖ Use Streaming ‚Äì Process files in chunks instead of loading them into memory.
‚úÖ Use Multer or Busboy ‚Äì Middleware for handling file uploads.
‚úÖ Store Files in Cloud Storage ‚Äì Use Cloudinary, AWS S3, or Firebase instead of storing them locally.
‚úÖ Enable Chunked Uploads ‚Äì Upload files in parts and merge them.
‚úÖ Use Nginx as a Reverse Proxy ‚Äì Optimize request handling before reaching Node.js.



1Ô∏è‚É£ Streaming Uploads Using Multer + Streams

```
const express = require('express');
const multer = require('multer');
const fs = require('fs');

const app = express();
const upload = multer({ dest: 'uploads/' }); // Temporary storage

app.post('/upload', upload.single('file'), (req, res) => {
  const file = req.file;
  const readStream = fs.createReadStream(file.path);
  const writeStream = fs.createWriteStream(`uploads/${file.originalname}`);

  readStream.pipe(writeStream);

  writeStream.on('finish', () => {
    res.send({ message: 'File uploaded successfully!' });
  });

  writeStream.on('error', (err) => {
    res.status(500).send({ error: 'File upload failed!' });
  });
});

app.listen(3000, () => console.log('Server running on port 3000'));
```


2Ô∏è‚É£ Uploading Directly to Cloud Storage (e.g., AWS S3)


```
const AWS = require('aws-sdk');
const multer = require('multer');
const multerS3 = require('multer-s3');
const express = require('express');

const app = express();
const s3 = new AWS.S3({ region: 'us-east-1' });

const upload = multer({
  storage: multerS3({
    s3,
    bucket: 'my-bucket-name',
    key: (req, file, cb) => cb(null, file.originalname)
  })
});

app.post('/upload', upload.single('file'), (req, res) => {
  res.send({ message: 'File uploaded to S3 successfully!' });
});

app.listen(3000, () => console.log('Server running on port 3000'));

```
============================================================================================================================================================

üìå What is child_proces

visit module file

============================================================================================================================================================


6Ô∏è‚É£ What is rate limiting, and how do you implement it in Node.js?

Rate limiting is a technique used to control the number of requests a user can make to a server within a specific time period.  

It helps to:  
‚úÖ Prevent API abuse (e.g., bots, DDoS attacks).  
‚úÖ Protect server resources (avoid overload).  
‚úÖ Ensure fair usage (limit per user/IP).  


If they exceed the limit, they get an HTTP 429 Too Many Requests error.


üîπ How to Implement Rate Limiting in Node.js using express-rate-limit package?

1Ô∏è‚É£ Using `express-rate-limit` (for Express.js apps)
However, this doesn't work well in distributed systems where multiple servers handle requests.


üîπ Where is Rate Limiting Used?
‚úÖ Login attempts: Prevent brute-force attacks.  
‚úÖ API requests: Protect backend servers from overload.  
‚úÖ Search queries: Avoid excessive requests from bots.  
‚úÖ File uploads: Control how many files a user can upload in a short time.


üîπ How to Implement Rate Limiting in Node.js using redis?

üí° Redis is the best choice for rate limiting because it is:
‚úÖ Fast (stores data in RAM).
‚úÖ Persistent across multiple servers (unlike in-memory solutions).





============================================================================================================================================================





============================================================================================================================================================



















































































































































































