Indexes: Retrieving data efficently

Note: 

If your collection has only a few thousand documents (5000 to 10000), indexing may not make a noticeable difference.
Indexing shines when dealing with millions of records.



üìå Indexes are most effective when they significantly reduce the number of documents MongoDB needs to retrieve.

In MongoDB, an index is a data structure that improves the speed of data retrieval operations on a collection.
Speeds up queries by reducing the number of documents MongoDB needs to scan
  
Indexes speed up find, update, and delete queries by reducing the number of documents MongoDB needs to scan that means basically 
Index on field Helps find the documents quickly but the Problem: is the actual update/delete operation still takes time.
MongoDB update/delete every matching document individually, which is slow.

Without indexes, MongoDB must scan every document in a collection to return query results
Although indexes improve query performance, adding an index has negative performance impact for write operations. 
For collections with a high write-to-read ratio, indexes are expensive because each insert must also update any indexes.

============================================================================================================================================================

‚ö†Ô∏è When Indexes Don‚Äôt Help (With Examples):

üìù Conclusion:
0-5 indexes per collection ‚Üí ‚úÖ Good
5-10 indexes ‚Üí ‚ö†Ô∏è Monitor performance
10+ indexes ‚Üí üî¥ Likely slowing down writes
Use only necessary indexes and avoid indexing fields with frequent updates.


‚ùå 1Ô∏è‚É£Indexes Won‚Äôt Help If a Query Uses $regex (Without Prefix)
üîπ Example ($regex Without a Prefix)
db.users.find({ name: { $regex: "esh", $options: "i" } });
Scenario: Searching for users where "esh" appears anywhere in the name.
Problem: ‚ùå Index won‚Äôt be used because MongoDB must scan the entire collection to find matches.
Why? Indexes only work well if you search from the beginning (/^pattern/).
‚úÖ Solution:
db.users.find({ name: { $regex: /^Adesh/i } });
‚úî Uses the index because it searches from the start.   

‚ùå 2Ô∏è‚É£ Indexes Won‚Äôt Help When Filtering on a Low-Cardinality Field
üîπ Example (Boolean Fields)
db.users.find({ isActive: true });
Scenario: Index on isActive (true/false).
Problem: ‚ùå If 90% of documents have isActive: true, MongoDB still scans most of the collection.
Why? Indexes are useful only when they significantly reduce the number of scanned documents.
‚úÖ Solution: Use an index on a more selective field (e.g., lastLoginDate).


‚ùå 3Ô∏è‚É£ Indexes Won‚Äôt Help If a Query Uses $or on Unindexed Fields
üîπ Example ($or Without Indexes)
db.orders.find({ 
    $or: [{ status: "shipped" }, { totalPrice: { $gt: 1000 } }] 
});
Scenario: No index on status or totalPrice.
Problem: ‚ùå MongoDB performs a full collection scan.
Why? It can't efficiently use indexes with $or unless both fields are indexed.
‚úÖ Solution:
Create compound index: { status: 1, totalPrice: 1 }
Rewrite query: Use separate indexed queries instead of $or

============================================================================================================================================================


üìå How Indexes Improve Performance:

1Ô∏è‚É£find Queries (Read Operations)

Indexes allow MongoDB to quickly locate documents without scanning the entire collection.
Example:
db.users.createIndex({ name: 1 }); // Index on "name" field
db.users.find({ name: "Adesh" }); // Uses index for fast lookup


MongoDB will use the existing { name: 1 } index for sorting in descending order, but it will scan the index in reverse order instead of creating a separate 
descending index. This process is still optimized, as MongoDB can traverse the index efficiently in both directions
============================================================================================================================================================



In MongoDB, there are three main types of scans** used to retrieve data:  

1. Index Scan (`IXSCAN`) ‚úÖ (Fastest)  
2. Collection Scan (`COLLSCAN`) ‚ùå (Slowest)  
3. Covered Query (`COVEREDIXSCAN`) üî• (Fastest & Most Efficient)  

---

 1Ô∏è‚É£ Index Scan (`IXSCAN`) ‚úÖ (Fast)
- What is 
  - MongoDB uses an index to find the required documents instead of scanning the whole collection.  
- When does it happen?  
  - When you query a **field that has an index.  
- Performance:  
  - Much faster** than a full collection scan.  

üîπ Example:  
db.users.createIndex({ name: 1 }); // Create an index on "name"
db.users.find({ name: "Adesh" });  // Uses index (IXSCAN)
üîπ Query Plan (`explain()` output):  
"stage": "IXSCAN"
‚úÖ Uses the index efficiently to fetch matching documents.  


 2Ô∏è‚É£ Collection Scan (`COLLSCAN`) ‚ùå (Slow)
- What is it?  
  - MongoDB scans every document in the collection **because no suitable index exists**.  
- When does it happen?  
  - When a query doesn‚Äôt use an index.  
- Performance 
  - Very slow for large datasets (not recommended).  
üîπ Example (No Index):  
db.users.find({ age: 25 }); // No index on "age", triggers COLLSCAN
üîπ Query Plan (`explain()` output):  
"stage": "COLLSCAN"
‚ùå Avoid collection scans for large datasets‚Äîthey are slow and inefficient.
‚úÖ Solution: Create an index:  
db.users.createIndex({ age: 1 });


 3Ô∏è‚É£ Covered Query (`COVEREDIXSCAN`) üî• (Fastest & Most Efficient)
- What is it?  
  - A query is fully satisfied** by an index without needing to fetch documents from the collection.
  - all filds are index fileds  
- When does it happen?  
  - When all queried fields (filter + projection) are present in an index**.  
- Performance:  
  - Faster than `IXSCAN`, as it avoids accessing the actual documents**.  
üîπ **Example:  
db.users.createIndex({ name: 1, age: 1 }); // Compound index
db.users.find({ name: "Adesh" }, { age: 1, _id: 0 }); // Covered Query
üîπ Query Plan (`explain()` output):  
"stage": "COVEREDIXSCAN"
‚úÖ Fastest query type! üöÄ




MongoDB will split each email into separate tokens (words) like this:

Email	                          Tokenized Words  
adejad1234@gmail.com	          adejad1234, gmail, com  
jadhavadesh13061@gmail.com	    jadhavadesh13061, gmail, com  
pramod1461@hotmail.com	        pramod1461, hotmail, com  
rohjad@test.com	                rohjad, test, com  

How Searching Works?
Query: { $text: { $search: "gmail" } } ‚Üí Matches the first two documents because gmail is a token.
Query: { $text: { $search: "hotmail" } } ‚Üí Matches only the third document.
Query: { $text: { $search: "com" } } ‚Üí Matches all documents because com is a token in each
============================================================================================================================================================



1. create Index: 
playGround> db.person.createIndex({"dob.age": 1})
> dob.age_1  // name of index
1: ascending order
0: descending order
Note: You can create index on nested field.

2. get Indexes
db.users.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { 'dob.age': 1 }, name: 'dob.age_1' }
]
_id field have by default index on it.

3. drop index
myDB> db.users.dropIndex('dob.age_1')
{ nIndexesWas: 2, ok: 1 } 




============================================================================================================================================================


MongoDB Query Execution Without and With Indexes  

 1Ô∏è‚É£ Query Without an Index (`COLLSCAN`)  
- Query:  
  db.products.find({ seller: "Max" })

- If there is no index on the `seller` field, MongoDB will perform a **Collection Scan (`COLLSCAN`).  
- What happens during a `COLLSCAN`?  
  - MongoDB scans every document in the collection one by one to find matches.  
  - This slows down performanc* if the collection is large.  
- Problem:  
  - Imagine a collection with millions of document*‚Äîthe query would take a long time to execute.  

---

2Ô∏è‚É£ Creating an Index on `seller` Field
- Indexes are an addition, not a replacement for the collection.  
- When you create an index on the `seller` field, MongoDB stores this index separately from the collection.  
- How does an index work?  
  - The index acts like an ordered list of all values in the `seller` field.  
  -Example (Index for `seller` field):  
    Seller Index -> | Anna | Chris | Manu | Max | Max | Zod | .... 
    
  - This index is **sorted** and includes a pointer to each corresponding document.  

‚úÖ Index Creation Example:  
db.products.createIndex({ seller: 1 });

---

3Ô∏è‚É£ Query With an Index (`IXSCAN`)  
- Now, when you run the query:  
  db.products.find({ seller: "Max" })

  MongoDB uses an Index Scan (`IXSCAN`) instead of scanning the entire collection.  
- How does `IXSCAN` work?**  
  - MongoDB jumps directly to the sorted index and quickly finds `"Max"`.  
  - Since the index is already sorted, MongoDB **does not need to scan all documents** before reaching `"Max"`.  
  - Faster lookup compared to `COLLSCAN`.  

‚úÖ Conclusion: 
- Without an index ‚Üí Full collection scan (`COLLSCAN`) ‚Üí Slow for large datasets.  
- With an index ‚Üí Index scan (`IXSCAN`) ‚Üí Faster and more efficient.  


============================================================================================================================================================



‚ö†Ô∏è Avoid Creating Too Many Indexes**  

 1Ô∏è‚É£ Indexes Improve `find` Queries but Slow Down `insert` Operations 
- Indexes **speed up `find` queries**, making searches much faster.  
- However, **they slow down `insert`, `update`, and `delete` operations** because MongoDB needs to **update all relevant indexes** whenever a document is modified.  

---

2Ô∏è‚É£ How Indexes Affect Inserts, Updates & Deletes*
- An index is an ordered list of values with pointers to the documents.  
- Whenever a new document is inserted:  
  - MongoDB must update every index associated with that collection.  
  - This can **increase write operation time** significantly.  
- If you have 10 indexes on a collection:  
  - Each `insert`, `update`, or `delete` operation must update all 10 indexes.  
  - This results in performance overhead and increased storage usage.  

---

3Ô∏è‚É£ Choosing the Right Fields for Indexing 
- Not every field needs an index**‚Äîonly **frequently searched fields** should be indexed.  
- Too many indexes **consume extra disk space** and **slow down write operations**.  
- Best Practice:  
  - Analyze queries with **`explain()`** to see **which fields need indexing**.  
  - Prioritize indexes for **fields used in filtering, sorting, and joins (`$lookup`)**.  

‚úÖ **Conclusion:**  
- **Use indexes wisely**‚Äîdon't index every field.  
- **Too many indexes slow down `insert`, `update`, and `delete`** queries.  
- **Optimize indexing** based on query patterns and performance needs.  



============================================================================================================================================================



explain(): 
====================
MongoDB gives us a tool to analyze how it executed the query and this tool is a simple method we add to our query.
explain() works for find(), update(), delete() and not for insert().

explain() method takes following arguments:
1. queryPlanner: Show summary for Executed Query + Winning Plan
2. executionStats: Show Detailed Summary for Executed Query + Winning Plan + possibly rejected plans
3. allPlansExecution: Show Detailed Summary for Executed Query + Winning Plan + Winning plan Decision Process

playGround> db.person.explain("executionStats").find({"dob.age": {$gt: 60}})

check "executionStats", "winningPlan" field 


without Index: 
db.person.explain("executionStats").find({"dob.age": {$gt: 60}})
>executionStats: {
    executionSuccess: true,
    nReturned: 1222,
    executionTimeMillis: 5,  <--------- Time
    totalKeysExamined: 0,
    totalDocsExamined: 5000,
    executionStages: {
      stage: 'COLLSCAN',  <-------------- Collection Scan
    }
  },

with Index: 
db.person.explain("executionStats").find({"dob.age": {$gt: 60}})
>executionStats: {
    executionSuccess: true,
    nReturned: 1222,
    executionTimeMillis: 3,  <-------------------------Time
    totalKeysExamined: 1222,
    totalDocsExamined: 1222,
    executionStages: {
      stage: 'FETCH',
      nReturned: 1222,
      inputStage: {
        stage: 'IXSCAN',  <---------------------Index scan
      }
    }
}


============================================================================================================================================================



üìå Understanding When Indexes Help & When They Don‚Äôt
1Ô∏è‚É£ How Indexes Work in MongoDB
‚úÖ When an index is used, MongoDB follows these steps:
Scans the index to find matching keys.
Retrieves documents from the collection using pointers.
This process involves an extra step (reading the index first and then fetching documents).
üìå Indexes are most effective when they significantly reduce the number of documents MongoDB needs to retrieve.
Example: If only 5 out of 5000 documents match age > 20, the index drastically reduces the work.

2Ô∏è‚É£ Collection Scan (COLLSCAN) Behavior
‚úÖ COLLSCAN reads data sequentially from disk or memory.
If the entire collection fits in memory, a COLLSCAN can be fast, as MongoDB reads documents directly in sequence.

üìå When Indexes May Be Slower

If a query returns a large portion (or the majority) of the documents, an index can actually slow down the query.
MongoDB first scans the index.
Then, it retrieves all matching documents from the collection.
This adds an extra step, making it inefficient.
Example: If a query returns 90% of the documents, using an index is wasteful‚Äîa direct COLLSCAN would be better.
üìå When Indexes Are Useful

If a query returns only 10‚Äì20% of the dataset, indexes significantly improve performance.
Ideal for targeted searches like:
db.users.find({ age: { $gt: 30 } }) // Small subset of data
3Ô∏è‚É£ Indexing Different Data Types
‚úÖ You can create indexes on fields containing text, numbers, or other searchable values.
‚ùå Boolean fields (true/false) do not benefit much from indexing since they have only two possible values.

‚úÖ Conclusion:

Indexes improve targeted queries but may slow down queries that retrieve most or all of the documents.
Use indexes for selective queries (~10‚Äì20% of the dataset).
For boolean fields, indexing doesn‚Äôt offer much benefit since there are only two possible values.
Would you like a MongoDB explain() query example to analyze index performance? üöÄ


============================================================================================================================================================



compound index: 

-> A compound index in MongoDB is an index that includes multiple fields. It allows you to create an index on more than one field in a 
document, enabling efficient query performance for queries that involve those fields.
-> Compound indexes are larger than single-field indexes
-> The order of fields in a compound index is critical

syntax: 
db.collection.createIndex({ field1: 1, field2: -1 });
field1: 1 means the field is indexed in ascending order.
field2: -1 means the field is indexed in descending order.

EX: 
db.collection.createIndex({ name: 1, age: 1 });
Initial Data:
[
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Alice", age: 35 }
]
With a compound index { name: 1, age: 1 }, the data is ordered as:
[
  { name: "Alice", age: 30 }
  { name: "Alice", age: 35 }
  { name: "Bob", age: 25 }
]

How Does It Work?
A compound index sorts and organizes data by the specified fields in the order defined. 
It essentially acts as a "multi-level" sorting system:
First sorts by the first field (field1).
Then sorts by the second field (field2) for documents with the same field1 value.

Use Cases for Compound Indexes:

1. Multi-Field Queries
If your queries frequently filter or sort by multiple fields, a compound index can optimize performance.
Example: db.collection.createIndex({ age: 1, gender: 1 });
Query:db.collection.find({ age: { $gt: 30 }, gender: "male" });

2. Sorting
Compound indexes can be used to optimize sorting queries.
Example: db.collection.createIndex({ age: 1, salary: -1 });
Query: db.collection.find({}).sort({ age: 1, salary: -1 });
If you are not using indexes and you do a sort on large amount of documents, you can actually timeout because mongodb has a threshold of 
32 megabytes in memory for sorting and if you don't have index mongodb will essentially fetch all your docuemnts into memory and do the 
sort there 


3. Matching a Subset of Fields
A compound index can also be used to optimize queries involving only the first field or a prefix subset of fields.
Example: db.collection.createIndex({ age: 1, gender: 1 });
Optimized: db.collection.find({ age: { $gt: 30 } });
Not optimized: db.collection.find({ gender: "female" });
The query does not use the index fully because gender is not the first field in the compound index.


Queries That Benefit

1. Only contain age field
2. Both Fields in Query


Using Indexes for Sorting : 
==========================
available Indexes: 
  {
    v: 2,
    key: { 'dob.age': 1, gender: 1 },
    name: 'dob.age_1_gender_1'
  }

db.person.explain().find({"dob.age": 35}).sort({gender: 1})


If you are not using indexes and you do a sort on large amount of documents, you can actually timeout because mongodb has a threshold of 
32 megabytes in memory for sorting and if you don't have index mongodb will essentially fetch all your docuemnts into memory and do the 
sort there 

if you have millions of documents, you fetch so many documents that an in-memory sort is just not possible and
you need an index which is alredy sorted so that mongodb doesn't have to sort in memory but can just take the order you have in the index.


indexes are not only for searching but also for sorting.

because we have sorted list of elements of index.

mongoDB can utilized in case of you want to sort in the same way that index list is sorted.

Now this is another cool feature of indexes, since we  have an ordered list of values alredy, mongoDB can utilize that to quickly give
us back the order of documents we need.


So sometimes you also need an index not just to speed up the query but also to be able to sort at all.



============================================================================================================================================================



Default Index: 
==============
this is derfault Index: 
{ v: 2, key: { _id: 1 }, name: '_id_' },



============================================================================================================================================================


unique: true
============


When you create an index with "unique: true", MongoDB enforces uniqueness on that field across all documents in the collection. 
This means:
No two documents can have the same value for that indexed field.
If you try to insert or update a document with a duplicate value, MongoDB will throw an error.

üìå Example 1: Enforcing Unique User Emails
Let‚Äôs say we have a users collection, and we want to ensure that email addresses are unique.

‚úÖ Creating a Unique Index on email Field
db.users.createIndex({ email: 1 }, { unique: true });
This ensures no two users can have the same email.


üìå Example 2: Unique Index on Multiple Fields (Compound Index)
We can create a unique compound index to ensure that a combination of two fields is unique.

‚úÖ Ensuring Each Seller Can Have Only One Product with the Same Name
db.products.createIndex({ seller: 1, productName: 1 }, { unique: true });
A seller cannot add two products with the same name.
But different sellers can add products with the same name.

‚úÖ Valid Inserts
db.products.insertMany([
  { seller: "Max", productName: "Laptop" },  // ‚úÖ Allowed
  { seller: "John", productName: "Laptop" }  // ‚úÖ Allowed (different seller)
]);

‚ùå Invalid Insert (Duplicate Seller & Product Name)
db.products.insertOne({ seller: "Max", productName: "Laptop" });
üí• Error: "E11000 duplicate key error" ‚Üí Max already has a "Laptop".


üìå Things to Keep in Mind
1Ô∏è‚É£ unique: true works only if there are no duplicate values already.
If duplicates exist, MongoDB won‚Äôt allow the index creation unless you remove duplicates first.
2Ô∏è‚É£ null values are treated as the same value when using unique: true.
If a field is null, MongoDB allows only one document with null.
Example:
db.users.createIndex({ phoneNumber: 1 }, { unique: true });

{ name: "Alice", phoneNumber: null } ‚úÖ Allowed
{ name: "Bob", phoneNumber: null } ‚ùå Error!



============================================================================================================================================================



Partial Filter: 
================

‚û°Ô∏è In a partial filter, we define a condition, and the index is applied only to the documents that meet/pass this condition, instead of indexing the entire field.

-> It reducing the index size and improving query performance for specific queries.

for example i have 1 millions of documents and i want to do something for employees whose service_age is more than 50 years then 
is it more correct/optimised way to create index on only those documents where service_age > 50  rather than whole age fileld.

db.senwell.createIndex({ service_age: 1 }, { partialFilterExpression: { service_age: { $gte: 50 } } })

Query Not Using the Index: 
db.senwell.find({ service_age : { $lt: 50 }});
This query will not use the index because documents with service_age < 50 are not included in the index

Example 2: Index Only Non-Null Fields
[
  { _id: 1, status: "active", age: 25 },
  { _id: 2, status: "inactive", age: 30 },
  { _id: 3, status: "active", age: null },
  { _id: 4, status: "inactive", age: null }
]
Question: Create index on documents which contain age field.
Query : db.tb.createIndex({ age: 1 }, { partialFilterExpression: { age: { $exists: true } } });  // _id 3 and 4 not included
supported Query : db.tb.find({ age: { $gt: 20 } });

Question: create index on score field but include only documnets where status is active
db.tb.createIndex({ score: 1 }, { partialFilterExpression: { status: "active" } });
supported Query :db.tb.find({ score: { $gte: 85 }, status: "active" });
Not Supported :  db.tb.find({score: 20});  // here it perform COLLSCAN instaed of IXSCAN because you didn't mention status of document.
Note: while seaching for documents make sure you have added correct filelds so that index will applied correctly.

compound Index + Partial Filter:
db.tb1.createIndex({age: 1, gender: 1}, { partialFilterExpression: { age:{ $gte: 31 }, gender: { $exists: true } } } );



============================================================================================================================================================



TTL Index (Time to Live Index):
============================
A TTL (Time to Live) index is a special type of index that "automatically removes documents from a collection after a specified period". 
This is particularly useful for managing data that becomes irrelevant or obsolete after a certain time, such as:


‚úÖ Good For:
User sessions (e.g., auto-delete login sessions after 30 minutes).
Temporary data (like cache or logs)
Logs (e.g., store error logs for 7 days and delete old ones).
OTP verification codes (e.g., delete unused OTPs after 5 minutes).
Temporary notifications (e.g., clear expired alerts).
Expiring tokens.


Key Points to Remember:

1. Field Type: The TTL index must be on a field with a Date type.
2. Partial Expiration: TTL index does not expire a portion of a document‚Äîeither the entire document is removed or it stays.
3. Background Process: Expiration is handled by a background thread, so it may not happen exactly at the second the document expires.
4. No Manual Control: You cannot use TTL to "manually" delete documents on demand‚Äîit works based solely on the time value.
5. Compound Indexes: TTL indexes cannot be compound indexes; they must be single-field indexes.
TTL indexes delete entire documents, not just data from the index.

How TTL Index Works
You create a TTL index on a date field in a document.
MongoDB automatically deletes documents when the indexed field's value is older than the specified expiration time.
Deletion occurs in the background at regular intervals (every 60 seconds by default).

Example:

1. Scenario
You have a collection named "sessions" that stores user session data. 
You want sessions to expire 1 hour (3600 seconds) after their creation.

Query:  db.sessions.createIndex( { createdAt: 1 },  { expireAfterSeconds: 3600 } );  // 1 hour
> [
  {
    "v": 2,
    "key": { "createdAt": 1 },
    "name": "createdAt_1",
    "expireAfterSeconds": 3600
  }
]
createdAt: The field storing the document's creation date (must be a valid Date object).
expireAfterSeconds: Specifies the TTL duration (in seconds).
Query: db.sessions.insertOne({ sessionId: "abc123", userId: 1, createdAt: new Date() });
After 3600 seconds, MongoDB will automatically delete this document


Query: db.logs.createIndex({ timestamp: 1 }, { expireAfterSeconds: 604800 });  // Automatically delete logs after 7 days.
Query: db.cache.createIndex({ cachedAt: 1 }, { expireAfterSeconds: 86400 });  // Cache data for 24 hours.



üîç TTL Index vs. Capped Collection ‚Äì When to Use?

Feature                  TTL Index                          Capped Collection
---------------------------------------------------------------------------------
Purpose                  Delete expired data               Store only recent data
How It Works?            Removes documents based on time  Keeps a fixed number of documents
Use Case                 Session data, OTPs, logs         Real-time logs, chat messages, sensor data
Data Deletion            Deletes documents permanently    Overwrites oldest data
Storage Control          No size control                  Fixed storage size




============================================================================================================================================================



Covered Query in MongoDB: 
=========================

-> A covered query is a query in MongoDB that is fully satisfied using an index without needing to examine the actual documents (totalDocsExamined) in the collection. 
This significantly improves query performance because it avoids disk I/O and document retrieval.
also since we don't have examine the documents (totalDocsExamined) the time is 0 milliseconds.

Conditions for a Covered Query: 
------------------------------
For a query to be considered covered:

1. All Fields in the Query Must Be Indexed.
2. The fields used in the "query filter" must be part of an index.
3. All Fields in the "Projection" Must Be Indexed:
4. No "fetch" or "scan" of the collection's documents is required:
MongoDB does not access the actual documents everything is resolved from the index.
b
Input Data: 
db.people.insertMany([
  { "_id": 1, "name": "Alice", "age": 30, "city": "New York" },
  { "_id": 2, "name": "Bob", "age": 25, "city": "Los Angeles" },
  { "_id": 3, "name": "Charlie", "age": 35, "city": "Chicago" }
])

Index Creation: 
db.people.createIndex({ name: 1, age: 1 });

Covered Query Example:
db.people.find({ name: "Alice" }, { name: 1, age: 1, _id: 0 });
Filter: { name: "Alice" } is covered by the index { name: 1, age: 1 }.
Projection: { name: 1, age: 1, _id: 0 } retrieves fields present in the index only.


You can use the explain() method to verify whether a query is covered. 
If the FETCH stage is absent in the winningPlan, the query is covered also if "totalDocsExamined" is 0 then also its covered query.
db.people.explain("executionStats").find({ name: "Alice" }, { name: 1, age: 1, _id: 0 });

Benefits of Covered Queries:
0. Covered queries are ideal for read-heavy applications where specific fields are queried often
1. Improved Performance
2. Avoids reading actual documents from the collection as the (totalDocsExamined) are 0.
3. Reduces Disk I/O
4. Works entirely from the index, which is faster
5. Efficient Use of Resources
6. Minimizes memory and CPU usage for query execution


Limitations: 

1. All Required Fields Must Be Indexed, If any queried or projected field is not in the index, the query won't be covered
2. If documents are frequently updated, maintaining indexes for covered queries can add overhead





How mongodb rejects a plan: 
==============================

db.users.insertMany([
  { name: "Adesh", age: 23, sex: "male" },
  { name: "Akshay", age: 25, sex: "male" },
  { name: "Rahul", age: 24, sex: "male" },
  { name: "Sneha", age: 23, sex: "female" },
  { name: "Riya", age: 26, sex: "female" },
  { name: "Mohit", age: 27, sex: "male" }
]);




============================================================================================================================================================


Multi Key Index

-> A multi key index is an index that created on an array field.
-> MongoDB will create separate index for each value of array element.
-> Since arrays can store multiple values, a multi-key index "indexes each element" in the array separately, making queries on array fields much faster
-> Space will be more compared to normal index.
-> Keep in mind that using multikey indexes comes with certain considerations, such as increased index size 
and potential performance impacts during updates to the array field.


When you create an index on an array field, MongoDB "creates a separate index entry for each value inside the array".
This allows MongoDB to efficiently search for documents where any of the array values match the query.

üîπ Example: Let's say we have a products collection:

db.products.insertMany([
  { _id: 1, name: "Laptop", tags: ["electronics", "gadgets", "computers"] },
  { _id: 2, name: "Smartphone", tags: ["electronics", "mobile"] },
  { _id: 3, name: "Headphones", tags: ["electronics", "audio"] }
]);

The tags field contains an array of values.
If we create a multi-key index on tags:

db.products.createIndex({ tags: 1 });

MongoDB will index each value separately, meaning:

electronics ‚Üí points to Laptop, Smartphone, Headphones
gadgets ‚Üí points to Laptop
computers ‚Üí points to Laptop
mobile ‚Üí points to Smartphone
audio ‚Üí points to Headphones

Now, if we search for all products with "electronics" in tags:
db.products.find({ tags: "electronics" });
‚úÖ MongoDB will use the multi-key index and return all matching products without scanning the entire collection.



üö´  Limitations of Multi-Key Indexes
No Compound Index on Multiple Multi-Key Fields

You cannot create a compound index where two or more fields are arrays.
Example: This is not allowed:
db.products.createIndex({ tags: 1, categories: 1 }); // ‚ùå ERROR if both are arrays
Instead, you can create separate indexes on tags and categories.

üö´ Index Size Can Grow Quickly
Since each array element is indexed separately, multi-key indexes can consume more storage than regular indexes.
Be cautious when indexing very large arrays.


When to Use Multi-Key Indexes?
‚úÖ When searching within arrays (e.g., tags, categories, skills).
‚úÖ When documents have fields that store multiple values.
‚úÖ When filtering based on multiple choices (e.g., movies with multiple genres).



example 2: 
{ "genres": [ { "name": "Action" }, { "name": "Sci-Fi" } ] }
you can create a multi-key index on the genres field, but there are some limitations when using an embedded schema (customeGenreSchema inside movieSchema).

‚úÖ What is a Multi-Key Index?
A multi-key index allows MongoDB to index array fields, meaning each value inside the array is indexed separately.

üìå Example:
If a document contains:
```
{ "genres": [ { "name": "Action" }, { "name": "Sci-Fi" } ] }
```
A multi-key index on genres.name would index both "Action" and "Sci-Fi" separately.


üö® Issue with Your Schema
Currently, your genres field is an array of subdocuments (customeGenreSchema).

MongoDB does allow creating a multi-key index on genres.name, but not on the entire subdocument.
üí° Solution:
‚úÖ You can create a multi-key index only on genres.name, but not on genres itself.

‚úÖ Correct Way to Create a Multi-Key Index
Modify your schema like this:

movieSchema.index({ "genres.name": 1 });  // Multi-key index on genres.name
This will allow efficient querying on genres.name, for example:

Movie.find({ "genres.name": "Action" }) // Efficient search using the multi-key index
‚ùå What You Cannot Do
MongoDB does not allow indexing an array of full objects directly.
For example, this would not work:

movieSchema.index({ genres: 1 });  // ‚ùå This is NOT allowed
This is because genres is an array of objects, and MongoDB does not support indexing full objects within arrays.

‚úÖ Final Answer
Yes, you can create a multi-key index on genres.name, but not on genres itself.
Use this:

movieSchema.index({ "genres.name": 1 });
This ensures efficient searching when filtering by genre name. üöÄ

Let me know if you need further clarifications! üòä




=============================================================================================================



üìå Text Index:
==============

-> You can't create text index on number.
-> A Text Index in MongoDB allows you to perform "full-text search" on string fields within a collection. This is useful for searching words, phrases, or matching 
text efficiently even in the middle of a string.
-> You need to create both a text index and a normal index on the name field, if you want to:
Perform text search on the name field.
Sort the name field.

db.articles.createIndex({ title: "text" });
db.articles.createIndex({ title: "text", description: "text" });



üö´ MongoDB's text index does not support partial word matching, meaning it only searches for whole words and does not match substrings within a word.
suppose you have a products collection and have text index on title.
products: [
  { _id: 1, title: "Smartphone", description: "Latest 5G smartphone with AI camera" },
]
‚ùå Example: Searching for a Partial Word
> db.products.find({ $text: { $search: "phone" } });
üõë No Results!
‚úÖ This query will NOT return the Smartphone document because "phone" is a substring of "smartphone", and MongoDB text search only matches whole words.

‚ö†Ô∏è Alternative: Using Regex for Partial Matches  (costly)
If you must search for substrings (e.g., "phone" in "smartphone"), use regex instead of a text index:
db.products.find({ title: { $regex: "phone", $options: "i" } });
‚úÖ This will return the Smartphone document but is slower than text search.



üîç How MongoDB Text Index Works?

When you create a text index, MongoDB performs the following steps:

1Ô∏è‚É£ Tokenization

Breaks the text into words (tokens).
Example: "MongoDB is amazing" ‚Üí ["mongodb", "is", "amazing"].
2Ô∏è‚É£ Stemming

Reduces words to their root form based on the language.
Example: "running", "runs", "run" ‚Üí "run".
3Ô∏è‚É£ Stop Words Removal

Common words like "is", "the", "and" are ignored.
Example: "MongoDB is amazing" ‚Üí ["mongodb", "amazing"].
4Ô∏è‚É£ Index Storage

Stores the words in a special inverted index with pointers to documents.
This allows quick lookup when searching for words.


Practical : 

1Ô∏è‚É£ How to Create a Text Index?
By default, MongoDB does not create text indexes. You must create them manually.

üîπ Example ‚Äì Creating a Text Index on the title Field
db.articles.createIndex({ title: "text" });  // single field index
db.articles.createIndex({ title: "text", bio: 'text' });  // compound index


2Ô∏è‚É£ Basic Full-Text Search ($text)
Once a text index is created, you can search using $text and $search.
üîπ Query ‚Äì Find Articles Containing the Word "MongoDB"
db.articles.find({ $text: { $search: "MongoDB" } });
‚úÖ Matches documents where title contains "MongoDB" anywhere in string.


3Ô∏è‚É£ Searching for Multiple Words
MongoDB treats multiple words as an OR condition by default.
üîπ Query ‚Äì Find Articles Containing "MongoDB" OR "Index"
db.articles.find({ $text: { $search: "MongoDB Index" } });
‚úÖ Matches documents that contain either "MongoDB" OR "Index".


4Ô∏è‚É£ Exact Phrase Search
Use double quotes (" ") for exact phrase matching.
üîπ Query ‚Äì Find Articles Containing the Exact Phrase "MongoDB Index"
db.articles.find({ $text: { $search: "\"MongoDB Index\"" } });
‚úÖ Matches documents where "MongoDB Index" appears exactly in that order.


5Ô∏è‚É£ Exclude Words (Negative Search)
Use a - (minus sign) to exclude words from search results.
üîπ Query ‚Äì Find Articles Containing "MongoDB" but NOT "Index"
db.articles.find({ $text: { $search: "MongoDB -Index" } });
‚úÖ Matches documents with "MongoDB" but excludes those with "Index".


6Ô∏è‚É£ Text Index on Multiple Fields
You can create a compound text index on multiple fields.
üîπ Example ‚Äì Create a Text Index on title and description Fields
db.articles.createIndex({ title: "text", description: "text" });
‚úÖ Now, searches will match text in either title or description.


7Ô∏è‚É£ Sorting by Relevance ($meta: "textScore")
can i omit "score" from projection.
db.movies.find({ $text: { $search: "cat"}}, { score: { $meta: "textScore"}}).sort({score: { $meta: "textScore"}})
ans> Yes, you can omit the score from the projection in your MongoDB query. However, if you omit the score, you won‚Äôt be able to sort the results by the text search relevance score (textScore). 


The relevance score (often referred to as textScore in MongoDB) is a numerical value that indicates how well a document matches a search query when using MongoDB's 
text search feature.
It does not consider user behavior like how often a document is searched or viewed
üîπ Query ‚Äì Find and Sort Articles by Relevance
db.articles.find({ $text: { $search: "MongoDB" } },{ score: { $meta: "textScore" } }).sort({ score: { $meta: "textScore" } }); // Sort by highest relevance, 2nd object is projection object
‚úÖ Documents with the highest relevance appear first.
ex: 2
in bellow example we serach for "awesome t-shirt" and it return two documents one with only one keyword "awesome" and another have both keywords "awesome t-shirt".
so document with only one keyword have lower score than the document who have both keywords.

> db.products.find({$text: {$search: "awesome t-shirt"}})
{
    "title": "A Book",
    "description": "This is an awesome book about a young artist!"
}
{
    "title": "Red T-Shirt",
    "description": "This T-Shirt is red and it's pretty awesome!"
}

> db.products.find({$text: {$search: "awesome t-shirt"}}, {score: {$meta: "textScore"}}).sort({ score: { $meta: "textScore" }}) // highest matching result be on top
{
    "title": "Red T-Shirt",
    "description": "This T-Shirt is red and it's pretty awesome!",
    "score": 1.7999999999999998
}
{
    "title": "A Book",
    "description": "This is an awesome book about a young artist!",
    "score": 0.625
}





üöÄ Advantages of `$text` Search:**
  - **Much faster** than regex.
  - **Uses indexes** instead of scanning the whole collection.
  - **Supports multiple fields** (e.g., name, description).
  - **Finds words even in the middle** of a string.



üö´ Limitations of Text Index

‚ùå Only one text index per collection (but it can include multiple fields).
‚ùå MongoDB's text index does not support partial word matching, meaning it only searches for whole words and does not match substrings within a word.
‚ùå Not case-sensitive, but language-specific stemming applies (e.g., "run" and "running" may match).
‚ùå Cannot be used for sorting directly, except with $meta: "textScore".
‚ùå Does not support wildcard (*) searches.


data to pr5actise: 
db.products.insertMany([
  { _id: 1, title: "Gaming Laptop", description: "A powerful laptop for gaming and work", category: "Electronics" },
  { _id: 2, title: "Wireless Headphones", description: "Noise-canceling headphones with deep bass", category: "Audio" },
  { _id: 3, title: "Mechanical Keyboard", description: "RGB backlit keyboard for gaming and coding", category: "Accessories" },
  { _id: 4, title: "Smartphone", description: "Latest 5G smartphone with AI camera", category: "Mobile" },
  { _id: 5, title: "Gaming Mouse", description: "Ergonomic gaming mouse with programmable buttons", category: "Accessories" },
  { _id: 6, title: "Bluetooth Speaker", description: "Portable speaker with crystal-clear sound", category: "Audio" },
  { _id: 7, title: "4K Monitor", description: "Ultra HD monitor with stunning display", category: "Electronics" },
  { _id: 8, title: "Fitness Tracker", description: "Track your health and fitness goals", category: "Wearables" }
]);


‚ùå MongoDB's text index does not support partial word matching, meaning it only searches for whole words and does not match substrings within a word.



============================================================================================================================================================




### **Creating Indexes in MongoDB ‚Äì Foreground vs. Background**  

MongoDB provides two ways to create indexes:  

1Ô∏è‚É£ **Foreground Indexing**  
   - When you create an index in the **foreground**, it **locks the collection**.  
   - No other operations (insert, update, delete) can be performed on the collection while the index is being built.  
   - If the indexing process takes time, all read and write operations on that collection are blocked until the index is created.  
   - **Example:**  
     ```js
     db.collection.createIndex({ field: 1 })  // Foreground index by default
     ```
   - **Best for:** Small datasets where indexing completes quickly.  

2Ô∏è‚É£ **Background Indexing** (Deprecated since MongoDB 4.2)  
   - Allows you to **create an index while the collection is still writable**.  
   - Other operations (insert, update, delete) **can continue** while the index is being built.  
   - Used when you need minimal downtime.  
   - **Example (before MongoDB 4.2):**  
     ```js
     db.collection.createIndex({ field: 1 }, { background: true })  
     ```
   - **Note:** In **MongoDB 4.2+, all indexes are created in the foreground**, but the **default behavior is optimized** for minimal impact.  

### **Key Differences**  

| Feature            | Foreground Indexing | Background Indexing (Deprecated) |
|--------------------|--------------------|--------------------------------|
| Collection Locking | **Yes** (blocks operations) | **No** (other operations continue) |
| Performance Impact | High (especially for large datasets) | Low (less impact on running queries) |
| Use Case | Small datasets or when downtime is acceptable | Large collections needing continuous access |

### **Which One to Use?**  
- If using **MongoDB 4.2+**, background indexing is no longer an option‚Äî**use default index creation**.  
- If using an **older version**, background indexing is useful for large datasets where operations must continue during indexing.  

Let me know if you need further clarification! üöÄ