Indexes: Retrieving data efficently

What are indexes ?
Different types of indexes.
Using and Optimizing Indexes.


what are indexes and why do we use them ?

-> speed up find, update, delete query 

db.products.find({ seller: "Max" })
if i don't have index on seller field then mongodb will use "COLLSCAN". This is default approach mongodb takes when you don't have any index.
That means mongodb will go through entire collection one by one documents to find seller max. 
just imagine what will happen if collection is big.


now you can create index, index is not replacement for a collection but addition you could say.

so you would create an index for the seller field of the products collection and that index then exists additionally to the 
collection like extra column at the end of the collection and the index is an ordered list of all the values that are store in the seller 
field for all the documents.
its not just an ordered list of the values of course every value in the index has a pointer to the documentit belongs to.
ex: 
Seller field Index column -> | Anna | Chris | Manu | Max | Max | Zod |.... // orderd data and not document

Now this allows mongodb to do a so called index scan  "IXSCAN".
for seller field, such an index exits and it therfore simply goes to that seller index and can quickly jump to right value because it knows
values are already sorted. so it don't have to look first 10 documents if record start with M.  

Don't use Too many indexes:
===========================
if you create index for each field it will boost your find query but not insert query, because that extra index that has to be maintain 
needs to be updated with every insert because we have ordered list of elements with pointers to the documents.
so if you add a new document you also have to add a new element to the index and that might sound simple and it won't take super long 
but if you have got 10 indexes for your Documents in your collection then you have to update all 10 indexes for every insert as well as 
update and delete query, thats will take lots time.

thats why you have to find which field can have index or which one not.

explain(): 
====================
MongoDB gives us a tool to analyze how it executed the query and this tool is a simple method we add to our query.
explain() works for find(), update(), delete() and not for insert().


explain() method takes following arguments:
1. queryPlanner: Show summary for Executed Query + Winning Plan
2. executionStats: Show Detailed Summary for Executed Query + Winning Plan + possibly rejected plans
3. allPlansExecution: Show Detailed Summary for Executed Query + Winning Plan + Winning plan Decision Process

1. Should be as close as possible OR # of Documents should be 0
-> "# of keys (in index ) examined" <--->  "# of documents examined"

2.  Should be as close as possible OR # of Documents should be 0
-> "# of documents examined"  <--->   "# of Documents returned"



playGround> db.person.explain("executionStats").find({"dob.age": {$gt: 60}})

check "executionStats", "winningPlan" field 


mongodb thinks in so-called plans and plans are simply alternatives it considered for executing that query in the end it will find "winning
plan". 
"winning plan" is essential what it did to get our results it have which scan mongodb uses.
    winningPlan: {
      stage: 'COLLSCAN',
      filter: { 'dob.age': { '$gt': 60 } },
      direction: 'forward'
    },


1. create Index: 
playGround> db.person.createIndex({"dob.age": 1})
> dob.age_1  // name of index
1: ascending order
0: descending order
Note: You can create index on nested field.

2. get Indexes
db.users.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { 'dob.age': 1 }, name: 'dob.age_1' }
]
_id field have by default index on it.

3. drop index
myDB> db.users.dropIndex('dob.age_1')
{ nIndexesWas: 2, ok: 1 } 





without Index: 
db.person.explain("executionStats").find({"dob.age": {$gt: 60}})
>executionStats: {
    executionSuccess: true,
    nReturned: 1222,
    executionTimeMillis: 5,  <--------- Time
    totalKeysExamined: 0,
    totalDocsExamined: 5000,
    executionStages: {
      stage: 'COLLSCAN',  <-------------- Collection Scan
    }
  },

with Index: 
db.person.explain("executionStats").find({"dob.age": {$gt: 60}})
>executionStats: {
    executionSuccess: true,
    nReturned: 1222,
    executionTimeMillis: 3,  <-------------------------Time
    totalKeysExamined: 1222,
    totalDocsExamined: 1222,
    executionStages: {
      stage: 'FETCH',
      nReturned: 1222,
      inputStage: {
        stage: 'IXSCAN',  <---------------------Index scan
      }
    }
}




when you run this query : 
db.person.explain("executionStats").find({"dob.age": {$gt: 20}});  // Note all 5000 documents have age > 20

then you can notice that with index it took 20 to 300 milliseconds to find those docuemnts but if you don't use index then it took 2 to 10 
milliseconds.

why this ?

-> When an index is used, MongoDB performs the following:
Scans the index to find matching keys.
Retrieves the corresponding documents from the collection using pointers.
This involves extra steps (reading the index and then fetching the documents).
-> Indexes shine when they narrow down the number of documents that need to be retrieved. 
For example, if only 5 out of 5000 documents matched age > 20, the index would drastically reduce the work.
-> COLLSCAN reads data sequentially from disk or memory, benefiting from linear reads.
If the collection is small enough to fit entirely in memory, a COLLSCAN becomes much faster because MongoDB can read documents directly 
from memory in sequence.
-> if you have a query that will return a large portion or the majority of your documents, an index can actually slower because you then just 
have an extra step to go through your almost entire index list and then you have to go to the colllection and get all these documents, so
thats a extra step.
-> on the other hand if you do "COLLSCAN" then you alredy have all the documents in memory 
-> so if you have queries that regularly return the majority or all of your documents, an index will not really help you.
-> if your query return 10 to 20 % of dataset then  indexes will help.


You can create index on a field which have text, number value.
but for boolean it will speed up your query.





compound index: 

-> A compound index in MongoDB is an index that includes multiple fields. It allows you to create an index on more than one field in a 
document, enabling efficient query performance for queries that involve those fields.
-> Compound indexes are larger than single-field indexes
-> The order of fields in a compound index is critical

syntax: 
db.collection.createIndex({ field1: 1, field2: -1 });
field1: 1 means the field is indexed in ascending order.
field2: -1 means the field is indexed in descending order.

EX: 
db.collection.createIndex({ name: 1, age: 1 });
Initial Data:
[
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Alice", age: 35 }
]
With a compound index { name: 1, age: 1 }, the data is ordered as:
[
  { name: "Alice", age: 30 }
  { name: "Alice", age: 35 }
  { name: "Bob", age: 25 }
]

How Does It Work?
A compound index sorts and organizes data by the specified fields in the order defined. 
It essentially acts as a "multi-level" sorting system:
First sorts by the first field (field1).
Then sorts by the second field (field2) for documents with the same field1 value.

Use Cases for Compound Indexes:

1. Multi-Field Queries
If your queries frequently filter or sort by multiple fields, a compound index can optimize performance.
Example: db.collection.createIndex({ age: 1, gender: 1 });
Query:db.collection.find({ age: { $gt: 30 }, gender: "male" });

2. Sorting
Compound indexes can be used to optimize sorting queries.
Example: db.collection.createIndex({ age: 1, salary: -1 });
Query: db.collection.find({}).sort({ age: 1, salary: -1 });
If you are not using indexes and you do a sort on large amount of documents, you can actually timeout because mongodb has a threshold of 
32 megabytes in memory for sorting and if you don't have index mongodb will essentially fetch all your docuemnts into memory and do the 
sort there 


3. Matching a Subset of Fields
A compound index can also be used to optimize queries involving only the first field or a prefix subset of fields.
Example: db.collection.createIndex({ age: 1, gender: 1 });
Optimized: db.collection.find({ age: { $gt: 30 } });
Not optimized: db.collection.find({ gender: "female" });
The query does not use the index fully because gender is not the first field in the compound index.


Queries That Benefit

1. Only contain age field
2. Both Fields in Query


Using Indexes for Sorting : 
==========================
available Indexes: 
  {
    v: 2,
    key: { 'dob.age': 1, gender: 1 },
    name: 'dob.age_1_gender_1'
  }

db.person.explain().find({"dob.age": 35}).sort({gender: 1})


If you are not using indexes and you do a sort on large amount of documents, you can actually timeout because mongodb has a threshold of 
32 megabytes in memory for sorting and if you don't have index mongodb will essentially fetch all your docuemnts into memory and do the 
sort there 

if you have millions of documents, you fetch so many documents that an in-memory sort is just not possible and
you need an index which is alredy sorted so that mongodb doesn't have to sort in memory but can just take the order you have in the index.


indexes are not only for searching but also for sorting.

because we have sorted list of elements of index.

mongoDB can utilized in case of you want to sort in the same way that index list is sorted.

Now this is another cool feature of indexes, since we  have an ordered list of values alredy, mongoDB can utilize that to quickly give
us back the order of documents we need.

If you are not using indexes and you do a sort on large amount of documents, you can actually timeout because mongodb has a threshold of 
32 megabytes in memory for sorting and if you don't have index mongodb will essentially fetch all your docuemnts into memory and do the 
sort there 

So sometimes you also need an index not just to speed up the query but also to be able to sort at all.





Default Index: 
==============
this is derfault Index: 
{ v: 2, key: { _id: 1 }, name: '_id_' },







Configuring Indexes: 
=====================


db.person.createIndex({"login.uuid": 1}, {unique: 1})
> login.uuid_1

db.tb1.getIndexes()
>   {
    v: 2,
    key: { 'login.uuid': 1 },
    name: 'login.uuid_1',
    unique: true
  }






Partial Filter: 
================

-> A partial index is an index that only includes documents that meet a specified filter condition. 
-> It allows you to create indexes on a documents which passes the filter condition, reducing the index size and improving query 
performance for specific queries.

for example i have 1 millions of documents and i want to do something for employees whose service_age is more than 50 years then 
is it more correct/optimised way to create index on only those documents where service_age > 50  rather than whole age fileld.

db.senwell.createIndex({ service_age: 1 }, { partialFilterExpression: { service_age: { $gte: 50 } } })

Query Not Using the Index: 
db.senwell.find({ service_age : { $lt: 50 }});
This query will not use the index because documents with service_age < 50 are not included in the index

Example 2: Index Only Non-Null Fields
[
  { _id: 1, status: "active", age: 25 },
  { _id: 2, status: "inactive", age: 30 },
  { _id: 3, status: "active", age: null },
  { _id: 4, status: "inactive", age: null }
]
Question: Create index on documents which contain age field.
Query : db.tb.createIndex({ age: 1 }, { partialFilterExpression: { age: { $exists: true } } });  // _id 3 and 4 not included
supported Query : db.tb.find({ age: { $gt: 20 } });


Question: create index on score field but include only documnets where status is active
db.tb.createIndex({ score: 1 }, { partialFilterExpression: { status: "active" } });
supported Query :db.tb.find({ score: { $gte: 85 }, status: "active" });
Not Supported :  db.tb.find({score: 20});  // here it perform COLLSCAN instaed of IXSCAN because you didn't mention status of document.
Note: while seaching for documents make sure you have added correct filelds so that index will applied correctly.

compound Index + Partial Filter:
db.tb1.createIndex({age: 1, gender: 1}, { partialFilterExpression: { age:{ $gte: 31 }, gender: { $exists: true } } } );



TTL Index (Time to Live Index):
============================
A TTL (Time to Live) index is a special type of index that automatically removes documents from a collection after a specified period. 
This is particularly useful for managing data that becomes irrelevant or obsolete after a certain time, such as:

Session data
Temporary data (like cache or logs)
Expiring tokens

TTL indexes are an efficient way to automatically manage and clean up data without needing manual intervention, saving resources and 
simplifying application logic.


Key Points to Remember:

1. Field Type: The TTL index must be on a field with a Date type.
2. Partial Expiration: TTL index does not expire a portion of a document—either the entire document is removed or it stays.
3. Background Process: Expiration is handled by a background thread, so it may not happen exactly at the second the document expires.
4. No Manual Control: You cannot use TTL to "manually" delete documents on demand—it works based solely on the time value.
5. Compound Indexes: TTL indexes cannot be compound indexes; they must be single-field indexes.


How TTL Index Works
You create a TTL index on a date field in a document.
MongoDB automatically deletes documents when the indexed field's value is older than the specified expiration time.
Deletion occurs in the background at regular intervals (every 60 seconds by default).

Example:

1. Scenario
You have a collection named "sessions" that stores user session data. 
You want sessions to expire 1 hour (3600 seconds) after their creation.

Query:  db.sessions.createIndex( { createdAt: 1 },  { expireAfterSeconds: 3600 } );
> [
  {
    "v": 2,
    "key": { "createdAt": 1 },
    "name": "createdAt_1",
    "expireAfterSeconds": 3600
  }
]
createdAt: The field storing the document's creation date (must be a valid Date object).
expireAfterSeconds: Specifies the TTL duration (in seconds).
Query: db.sessions.insertOne({ sessionId: "abc123", userId: 1, createdAt: new Date() });
After 3600 seconds, MongoDB will automatically delete this document


Query: db.logs.createIndex({ timestamp: 1 }, { expireAfterSeconds: 604800 });  // Automatically delete logs after 7 days.
Query: db.cache.createIndex({ cachedAt: 1 }, { expireAfterSeconds: 86400 });  // Cache data for 24 hours.







Covered Query in MongoDB: 
=========================================

-> A covered query is a query in MongoDB that is fully satisfied using an index without needing to examine the actual documents
(totalDocsExamined) in the collection. This significantly improves query performance because it avoids disk I/O and document retrieval.
also since we don't have examine the documents (totalDocsExamined) the time is 0 milliseconds.

Conditions for a Covered Query: 
------------------------------
For a query to be considered covered:

1. All Fields in the Query Must Be Indexed.
2. The fields used in the "query filter" must be part of an index.
3. All Fields in the "Projection" Must Be Indexed:
4. No "fetch" or "scan" of the collection's documents is required:
MongoDB does not access the actual documents everything is resolved from the index.

Input Data: 
db.people.insertMany([
  { "_id": 1, "name": "Alice", "age": 30, "city": "New York" },
  { "_id": 2, "name": "Bob", "age": 25, "city": "Los Angeles" },
  { "_id": 3, "name": "Charlie", "age": 35, "city": "Chicago" }
])

Index Creation: 
db.people.createIndex({ name: 1, age: 1 });

Covered Query Example:
db.people.find({ name: "Alice" }, { name: 1, age: 1, _id: 0 });
Filter: { name: "Alice" } is covered by the index { name: 1, age: 1 }.
Projection: { name: 1, age: 1, _id: 0 } retrieves fields present in the index only.


You can use the explain() method to verify whether a query is covered. 
If the FETCH stage is absent in the winningPlan, the query is covered also if "totalDocsExamined" is 0 then also its covered query.
db.people.explain("executionStats").find({ name: "Alice" }, { name: 1, age: 1, _id: 0 });

Benefits of Covered Queries:
0. Covered queries are ideal for read-heavy applications where specific fields are queried often
1. Improved Performance
2. Avoids reading actual documents from the collection as the (totalDocsExamined) are 0.
3. Reduces Disk I/O
4. Works entirely from the index, which is faster
5. Efficient Use of Resources
6. Minimizes memory and CPU usage for query execution


Limitations: 

1. All Required Fields Must Be Indexed, If any queried or projected field is not in the index, the query won't be covered
2. If documents are frequently updated, maintaining indexes for covered queries can add overhead





How mongodb rejects a plan: 
==============================

db.users.insertMany([
  { name: "Adesh", age: 23, sex: "male" },
  { name: "Akshay", age: 25, sex: "male" },
  { name: "Rahul", age: 24, sex: "male" },
  { name: "Sneha", age: 23, sex: "female" },
  { name: "Riya", age: 26, sex: "female" },
  { name: "Mohit", age: 27, sex: "male" }
]);















































































Collscan -> scan like linear search means search document one by one.
IXScan -> Indexing scan -> Fast -> 

When you create an index on a field, MongoDB stores a 'data structure' that contains the indexed values along 
with references to the corresponding documents. The index does not store complete documents; instead, it 
stores the values of the indexed field in a sorted order, and each value is associated with a reference 
(or pointer) to the document that contains that value.

Specifically, for a single-field index on the "age" field, MongoDB will store the distinct age values in 
sorted order, and for each unique age value, it will maintain references to the documents in the collection 
where that age value is present.

Here's a simplified example to illustrate the concept:

Suppose you have the following documents in your "users" collection:

{ "_id": 1, "name": "Alice", "age": 25 }
{ "_id": 2, "name": "Bob", "age": 30 }
{ "_id": 3, "name": "Charlie", "age": 25 }

If you create an index on the "age" field, MongoDB's index data structure might look like this:

Age Index:
25 -> [1, 3]   // References to documents with age=25   [1, 3] are _id numbers
30 -> [2]      // Reference to the document with age=30


In this example, the "Age Index" is sorted by age values, and each age value is associated with references to the documents that have 
that age value. 
When you query for a specific age, MongoDB can use this index to quickly locate the relevant documents without having to scan the entire 
collection.

Keep in mind that the actual data structures used by MongoDB for indexing are more sophisticated, and the example above is simplified 
for illustrative purposes. 
MongoDB uses B-tree or hashed indexes, depending on the type of index and other factors, to efficiently support a wide range of query 
patterns.


if you create a index on a field like 'name' then it create a separate data structure where we stored all 
sorted values of name field. then if you search for a given name then index scan will be done not a collscan.
mongodb will search that name inside special data structure.   
-> Index scan apply binary search because data is already sorted.

-> Indexing also helps in sorting.
because of index data is already sorted so $sort operator will not sort data from starting instead it will
take of that sorted data.

-> Indexes are stored in a B-tree data structure.
-> It stores 
    1. Index keys
    2. Pointers to the documents in the collection.


The trade off: 

Storage space: 
-> jitna jyada Indexes tayar karoge utna jyada space lagega.
-> If you create multiple indexes then space required to store that index will also increases.

write performance:
-> write means when you insert document inside a collection.
-> when you insert a new document in a collections that document goes inside our collection as well as it also
goes inside B-tree which stored sorted data according to index.  
B-Tree has to perform sorting again to place that new document which takes time.
-> if your operation is read then its ok.
-> If there is collect where insert/write operations are more then creating more indexes will be dangerous.




db.collection.find({}).explain()
db.collection.find({}).explain('executionStats')

without index:
db.collection.find({}).explain('executionStats')
myDB> db.users.find({age: {$gt: 20}}).explain('executionStats')
{
  explainVersion: '1',
  queryPlanner: {
    winningPlan: {
      stage: 'COLLSCAN',
      filter: { age: { '$gt': 20 } },
      direction: 'forward'
    },
    rejectedPlans: []
  },
  executionStats: 
    nReturned: 954,                     <--------------
    totalDocsExamined: 1000,            <--------------
    executionTimeMillis: 0,
    executionStages: {
      stage: 'COLLSCAN',                <--------------
      filter: { age: { '$gt': 20 } },
      direction: 'forward',
    }
},

after applying index : 
myDB> db.users.find({age: {$gt: 20}}).explain('executionStats')
{
  explainVersion: '1',
  queryPlanner: {
    winningPlan: {
      stage: 'FETCH',               <--------------------------
      inputStage: {
        stage: 'IXSCAN',            <--------------------------
        keyPattern: { age: 1 },     <--------------------------
        indexName: 'age_1',         <--------------------------
        isMultiKey: false,
        multiKeyPaths: { age: [] },
        indexVersion: 2,
        direction: 'forward',
      }
    },
    rejectedPlans: []
  },
  executionStats: {
    nReturned: 954,             <--------------------------
    totalDocsExamined: 954,     <--------------------------
    executionTimeMillis: 1,
    executionStages: {
      stage: 'FETCH',           <--------------------------
      nReturned: 954,
      inputStage: {
        stage: 'IXSCAN'         <--------------------------,
        direction: 'forward',
      }
    }
  },
  command: { find: 'users', filter: { age: { '$gt': 20 } }, '$db': 'myDB' },
}


1. create index
myDB> db.users.createIndex({age: 1})
age_1
Note: You can create multiple indexes on the same field.
db.users.createIndex({age: -1});  // descending 30-20-10
db.users.createIndex({age: 1});   // ascending order 10-20-30
db.users.getIndexes()
[
    {v:2, key:{_id: 1}, name: '_id_'},
    {v:2, key:{age: -1}, name: 'age_-1'},
    {v:2, key:{age: 1}, name: 'age_1'},
]

2. get Index
myDB> db.users.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { age: 1 }, name: 'age_1' }
]
_id field have by default index on it.

3. drop index
myDB> db.users.dropIndex('age_1')
{ nIndexesWas: 2, ok: 1 }







when not to use indexing in mongodb?

1. When the collection is small
2. When the collection is frequently updated (write operation are more)
3. When the queries are complex (complex queries contain multiple fields -> multiple indexes - more storage)
4. When the collection is large ( more documents -> will take more space in index )







Types of indexes: 

1. Single field index
2. Compound indexes
3. Text indexes


1. Single field index: 
db.users.createIndex({age: 1})  // field_Name: order(1: ascending, -1: descending)



2. Compound Indexes: 
db.users.createIndex({age: 1, gender: 1})   // order matters
age_1_gender_1
db.users.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { age: 1, gender: 1 }, name: 'age_1_gender_1' }
]
first data will be sorted according to age then by gender.
all documents having age=30 will be sorted by gender. 'F' comes first than 'M'
then documents having age=31 will be sorted by gender. and this goes on
data: 
[
    {age: 31, gender: 'M'},
    {age: 31, gender: 'F'},
    {age: 30, gender: 'M'},
    {age: 30, gender: 'F'},
    {age: 30, gender: 'F'},
    {age: 29, gender: 'F'},
    {age: 29, gender: 'F'},
]
after applying index: 
[
    {age: 29, gender: 'F'},
    {age: 29, gender: 'F'},
    {age: 30, gender: 'F'},
    {age: 30, gender: 'F'},
    {age: 30, gender: 'M'},
    {age: 31, gender: 'F'},
    {age: 31, gender: 'M'},
]

db.users.createIndex({gender: 1, age: 1});  // order matters
gender_1_age_1
first data will be sorted according to gender then by age.
all documents having gender='F' will be sorted by age.
then documents having gender='M' will be sorted by age.
data: 
[
    {age: 31, gender: 'M'},
    {age: 31, gender: 'F'},
    {age: 30, gender: 'M'},
    {age: 30, gender: 'F'},
    {age: 30, gender: 'F'},
    {age: 29, gender: 'M'},
    {age: 29, gender: 'F'},
]
after applying index: 
[
    {age: 29, gender: 'F'},  // F = 29-30-31
    {age: 30, gender: 'F'},
    {age: 30, gender: 'F'},
    {age: 31, gender: 'F'},
    {age: 29, gender: 'M'},  // M = 29-30-31
    {age: 30, gender: 'M'},
    {age: 31, gender: 'M'},
]


myDB> db.users.find({age: {$gt: 39}, gender: 'male'}).count()
21
myDB> db.users.find({gender: 'male', age: {$gt: 39}}).count()
21
myDB> db.users.find({age: {$gt: 38}}).count()
103
myDB> db.users.find({gender: 'male'}).count()
493

without indexing
myDB> db.users.find({age: {$gt: 39}, gender: 'male'}).explain('executionStats')
{
  executionStats: {
    stage: 'COLLSCAN',
    nReturned: 21,
    totalDocsExamined: 1000,
  },
}

with indexing : age_1_gender_1
myDB> db.users.find({age: {$gt: 39}, gender: 'male'}).explain('executionStats')
{
  executionStats: {
    stage: 'IXSCAN',
    nReturned: 21,
    totalDocsExamined: 21,
    indexName: 'age_1_gender_1'
    }
}

with indexing : age_1_gender_1
myDB> db.users.find({gender: 'male', age: {$gt: 39}}).explain('executionStats')
{
  executionStats: {
    stage: 'IXSCAN',
    nReturned: 21,
    totalDocsExamined: 21,
    indexName: 'age_1_gender_1'
  }
}

with indexing : age_1_gender_1
myDB> db.users.find({age: {$gt: 38}}).explain('executionStats')
{
    executionStages: {        
        stage: 'IXSCAN',
        nReturned: 103,
        docsExamined: 103,
        indexName: 'age_1_gender_1',
    }
}

with indexing : age_1_gender_1
myDB> db.users.find({gender: 'male'}).explain('executionStats')
{
  executionStats: {
        stage: 'COLLSCAN',
        nReturned: 493,
        totalDocsExamined: 1000
  }
}

Note: here MongoDB applied 'COLLSCAN' even though we have index. 
because first data is sorted according to age then according to gender.
gender did its sorting in each age group, like in 'age=30 group' 'gender sorting' is done. in 'age=31 group'
'gender sorting' is done.
so there is no use of index.
data with index: age_1_gender_1: 
[
    {age: 29, gender: 'F'},
    {age: 29, gender: 'F'},
    {age: 30, gender: 'F'},
    {age: 30, gender: 'F'},
    {age: 30, gender: 'M'},
    {age: 31, gender: 'F'},
    {age: 31, gender: 'M'},
]







unique constraint: 
==================
db.users.createIndex({email: 1}, {unique: true})
-> this stores unique email.
-> It will not store duplicate email data or null values.
-> if you try to add document without email field then it will give you error.
Not Supported:: db.tb1.insertOne({name: "Adesh"})
Supported:: db.tb1.insertOne({name: "Adesh", email: "adejad1234@gmail.com"})




partial indexing: 
================
ex.1
-> db.users.createIndex({age: 1}, {partialFilterExpression: {age: {$gt: 22}}})
-> the given query creates an index on the "age" field and it includes only documents in the ascending order 
inside index where the "age" field has a value greater than 22.

ex.2
-> db.users.createIndex({name: 1}, {partialFilterExpression: {gender: {$exists: true}}});
-> the given query creates an index on the "name" field but only includes documents in the ascending order
inside index where the "gender" field exists. 








Delete index after given time: 
===============================
only works on date field and on single field index
db.users.createIndex({dob: 1}, {expireAfterSeconds: 3600})










What is covered query: 
=========================
->  A covered query is a query in which 
    1. All the fields in the query(inside query object) are part of an index.
    2. All the fields returned in the query are in the are in the same index.
    3. that means required data is present in the index
-> Covered queries are faster than other queries.

db.tb1.find({name: 'Adesh'}, {_id: 0, name: 1})

in this query we have index on 'name' field also we are returning only 'name'.
so it will not check associated reference document to that index.
we all know that inside a index we stored index value[10,20,30] as well as reference document to that index.
if we write query like this: 
db.users.find({name: 'Adesh'});
even we have index on a name field, we have to go in our collection to return all other fields related to that
name field. but if we write query like in 1st example then we don't have go inside collections to return all
fields of that name.
the data retrieval can be accomplished solely from index without the need to access the actual documents in 
the collection. In other words, all the information required to satisfy the query is present in the index 
itself.

age field have index store on it. age_1.
here i am returning only age. so we have 'covered query'
myDB> db.users.find({age: {$gt: 39}}, {_id: 0, age:1}).explain('executionStats')
{
    winningPlan: {
      stage: 'PROJECTION_COVERED',    <-------------------------------
      transformBy: { _id: 0, age: 1 },
      inputStage: {
        stage: 'IXSCAN',        <--------------------------------------
      }
    },
}

age field have index store on it. age_1
here i am returning all fields. so we don't have covered query
myDB> db.users.find({age: {$gt: 39}}).explain('executionStats')
{
    winningPlan: {
      stage: 'FETCH',   <-------------------------------
      inputStage: {
        stage: 'IXSCAN', <-------------------------------
      }
      }
}










Winning Plan : 

In MongoDB, when you execute a query, the database engine generates an execution plan to determine how to 
retrieve the requested data most efficiently. The "winning plan" refers to the selected execution plan that 
MongoDB chooses based on its query planner's analysis of available indexes, statistics, and other factors.

To view the winning plan for a query, you can use the explain method. 
The explain method provides information about the query execution, including the selected plan, index usage, 
and other details.
db.collection.find({ age: 25 }).explain("executionStats");

ex: 
which index will be used for same query.
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { age: 1 }, name: 'age_1' }
  { v: 2, key: { age: 1, name: 1}, name: 'age_1_name_1' }
]

here we have two indexes on the same field. 
1. age_1
2. age_1_name_1

so which index will be applied on bellow query: 
db.users.find({age: 21})

so for this scenarios mongodb : 

if we have multiple indexes corresponding to given query as show on above examples, then mongodb will collect
some random documents before the execution of the query and perform performance testing related to that indexes.
which index is giving best performance? that index is going to be stored inside a winning plan and rejected 
index will be goes inside a rejected plan.

It stores that winning plan in cache.
if second time this query executed then mongodb will not check performance again, instead it checks cache.

myDB> db.users.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { age: 1, gender: 1 }, name: 'age_1_gender_1' },
  { v: 2, key: { age: 1 }, name: 'age_1' }
]
myDB> db.users.find({age: {$gt: 38}}).explain('executionStats')
{
    winningPlan: {
      stage: 'FETCH',
      inputStage: {
        stage: 'IXSCAN',
        indexName: 'age_1_gender_1',  <--------------------------
      }
    },
    rejectedPlans: [
      {
        stage: 'FETCH',
        inputStage: {
          stage: 'IXSCAN',
          indexName: 'age_1',  <-------------------------------
        }
    }
    ]
}











Multi Key Index

-> A multi key index is an index that can be created on an array field.
-> MongoDB will create separate index for each value of array element.
-> so it can quickly look up document that match a specific value.
-> Space will be more compared to normal index.
-> Keep in mind that using multikey indexes comes with certain considerations, such as increased index size 
and potential performance impacts during updates to the array field.

db.movies.insertMany([
    {_id: 1, name: 'A', hobbies: ['Drama', 'Romance']},
    {_id: 2, name: 'B', hobbies: ['Anime']},
    {_id: 3, name: 'C', hobbies: ['Hentai', 'Anime']},
    {_id: 4, name: 'D', hobbies: ['Drama', 'Romance', 'Thriller']}
]);

so if i create a index on 'hobbies' then mongodb will create index entry on 'Drama', 'Romance' and so on..

myDB> db.movies.createIndex({hobbies: 1})
hobbies_1

myDB> db.movies.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { hobbies: 1 }, name: 'hobbies_1' }
]

myDB> db.movies.find({hobbies: 'Anime'}).explain('executionStats')
{
    executionStages: {
      stage: 'FETCH',
        stage: 'IXSCAN',
        nReturned: 2,
        indexName: 'hobbies_1',  <-----------------------------
      }
}






=============================================================================================================







Text Index: 
============


-> Single Text Index per collection.
-> Tokenization and stemming
-> Relevance score

db.bio.insert([
    {_id: 1, name: 'Adesh', bio: 'I am youtuber'},
    {_id: 2, name: 'Akshay', bio: 'I am youtuber and actor'},
    {_id: 3, name: 'Manoj', bio: 'student'},
    {_id: 4, name: 'Ram', bio: 'swimmer'},
    {_id: 5, name: 'Swarali', bio: 'youtuber'}
])

db.users.createIndex({name: "text"})  -> name_text
db.users.createIndex({name: 'text', bio: 'text'})  -> name_text_bio_text

myDB> db.bio.createIndex({name: 'text', bio: 'text'})
name_text_bio_text
myDB> db.bio.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  {
    v: 2,
    key: { _fts: 'text', _ftsx: 1 },
    name: 'name_text_bio_text',
    weights: { bio: 1, name: 1 },
    default_language: 'english',
    language_override: 'language',
    textIndexVersion: 3
  }
]

myDB> db.bio.find({$text: {$search: 'youtube'}})
[
  { _id: 5, name: 'Swarali', bio: 'youtuber' },
  { _id: 1, name: 'Adesh', bio: 'I am youtuber' },
  { _id: 2, name: 'Akshay', bio: 'I am youtuber and actor' }
]


myDB> db.bio.find({$text: {$search: 'youtube and actor'}})
[
  { _id: 2, name: 'Akshay', bio: 'I am youtuber and actor' },
  { _id: 5, name: 'Swarali', bio: 'youtuber' },
  { _id: 1, name: 'Adesh', bio: 'I am youtuber' }
]

// exclude actor
myDB> db.bio.find({$text: {$search: 'youtube -actor'}})
[
  { _id: 5, name: 'Swarali', bio: 'youtuber' },
  { _id: 1, name: 'Adesh', bio: 'I am youtuber' }
]

myDB> db.bio.find({$text: {$search: 'student Ram'}})
[
  { _id: 4, name: 'Ram', bio: 'swimmer' },
  { _id: 3, name: 'Manoj', bio: 'student' }
]


// check score of query
db.bio.find({$text: {$search: 'student Adesh'}}, {hamaraScore: {$meta: 'textScore'}})
[
  { _id: 1, name: 'Adesh', bio: 'I am youtuber', hamaraScore: 1.1 },
  { _id: 3, name: 'Manoj', bio: 'student', hamaraScore: 1.1 }
]