The MongoDB Aggregation Pipeline
--------------------------------

An 'aggregation pipeline' consists of 'one or more stages' that 'process documents':

'Each stage' 'performs an operation' on the 'input documents'. 
For example, a stage can 'filter documents', 'group documents', and 'calculate values'.

The documents that are 'output from a stage' are passed as a 'input to the next stage'.

An aggregation pipeline can return results for groups of documents. For example, return the total, average, 
maximum, and minimum values.

Note: 
Aggregation pipelines run with the db.collection.aggregate() method do not modify documents in a collection, 
unless the pipeline contains a '$merge or $out stage.'

why we use aggregation pipeline: 
1. The MongoDB aggregation framework provides a powerful way to 'process and analyze data' also offers several advantages when it 
comes to complex data manipulation and analysis tasks:
2. Performance is better than normal queries.
3. Data Transformation & data manipulation



‚úÖ Purpose:

Used mostly for querying, transforming, and analyzing data
Helps group, filter, project, and calculate results
Doesn't modify the original documents (unless $merge or $out is used)

‚úÖ Common Aggregation Stages:

$match ‚Üí Filters documents (like find)
$group ‚Üí Groups data (like SQL GROUP BY)
$project ‚Üí Selects/reshapes fields
$sort ‚Üí Sorts results
$lookup ‚Üí Performs joins (foreign key-like relations)
$limit



üöÄ Note: use aggregation for analysis & transformation, and use traditional methods for direct CRUD operations.



üöÄ Pro Interview Tips
1Ô∏è‚É£ Master $sum, $avg, $max, $min, $addToSet, and $push.
2Ô∏è‚É£ Use date functions ($year, $month, $week) for time-based grouping.
3Ô∏è‚É£ Use $switch for custom groupings (like age ranges).
4Ô∏è‚É£ Combine $group with $project and $match for powerful filtering.
5Ô∏è‚É£ Practice performance optimization with indexes and $unwind (if needed).





Popular Stages: 
===============

$match (aggregation): 

-> The `$match` stage 'filters documents' based on specified condition(s), allowing only matching documents to 
proceed to the next pipeline stage.
-> To optimize the pipeline place $match as early in the aggregation Pipeline
-> The $match query syntax is identical to the read operation query syntax;

1. Match documents where status is "active":
db.users.aggregate([
  {
    $match: { status: "active" }
  },
  {
    $count: 'total'
  }
]);

2. Match documents with an age greater than 25:
db.users.aggregate([
  {
    $match: { age: { $gt: 25 } }
  }
]);

3. Match documents with multiple conditions (AND condition):
db.orders.aggregate([
  {
    $match: { 
      status: "shipped",
      totalAmount: { $gt: 100 }
    }
  }
]);

4. Match documents with an OR condition using $or
db.orders.aggregate([
  {
    $match: { 
      status: "shipped",
      totalAmount: { $gt: 100 }
    }
  }
]);


db.users.aggregate([
    {
        $match: {age: {$in: [20, 30, 40]}}
    }
])

db.users.aggregate([
  {
      $match: {
          _id: 1  or _id: ObjectId("454365465463456345")
      }
  }
])



üîç Basic $match Queries
{ $match: { genre: "Action" } }

{ $match: { rating: { $gt: 8 } } }

{ $match: { releaseYear: 2020 } }

{ $match: { duration: { $lte: 120 } } }

{ $match: { language: "Hindi" } }

{ $match: { director: "James Cameron" } }

{ $match: { isAvailable: true } }

{ $match: { title: "Titanic" } }

{ $match: { awards: { $gte: 5 } } }

{ $match: { "cast": "Tom Hanks" } }

üîÅ Logical Operators
{ $match: { $or: [{ genre: "Drama" }, { genre: "Romance" }] } }

{ $match: { $and: [{ rating: { $gt: 7 } }, { releaseYear: { $gt: 2010 } }] } }

{ $match: { $nor: [{ language: "English" }, { rating: { $lt: 6 } }] } }

{ $match: { $not: { rating: { $lte: 5 } } } }

{ $match: { $and: [{ isAvailable: true }, { genre: { $ne: "Horror" } }] } }

üìÖ Date & Range Filters
{ $match: { releaseYear: { $gte: 2000, $lte: 2010 } } }

{ $match: { releaseYear: { $in: [1990, 1995, 2000] } } }

{ $match: { releaseYear: { $nin: [2020, 2021, 2022] } } }

{ $match: { rating: { $gte: 7.5, $lte: 9.5 } } }

`{ $match: { awards: { $mod: [2, 0] } } } // Even number of awards

üìö Array Queries
{ $match: { cast: { $all: ["Robert Downey Jr.", "Chris Evans"] } } }

{ $match: { cast: { $size: 3 } } }

{ $match: { cast: { $elemMatch: { $eq: "Leonardo DiCaprio" } } } }

{ $match: { cast: { $in: ["Brad Pitt", "Matt Damon"] } } }

{ $match: { cast: { $nin: ["Shahrukh Khan", "Salman Khan"] } } }

üìÑ Text & String Queries
{ $match: { title: { $regex: "^The", $options: "i" } } }

{ $match: { title: { $regex: "man$", $options: "i" } } }

{ $match: { director: { $regex: "Nolan", $options: "i" } } }

{ $match: { title: { $regex: "war", $options: "i" } } }

{ $match: { title: { $regex: "^[A-Z]" } } }

üß† Field Comparisons
{ $match: { $expr: { $gt: ["$rating", 8] } } }

{ $match: { $expr: { $lt: ["$awards", "$rating"] } } }

{ $match: { $expr: { $gte: ["$duration", 120] } } }

{ $match: { $expr: { $ne: ["$director", "Steven Spielberg"] } } }

üìä Conditional Operators
{ $match: { $expr: { $cond: [{ $gt: ["$rating", 8] }, true, false] } } }

{ $match: { $expr: { $and: [{ $gt: ["$rating", 7] }, { $lt: ["$awards", 10] }] } } }

{ $match: { $expr: { $eq: [{ $strLenCP: "$title" }, 10] } } }

{ $match: { $expr: { $gt: [{ $size: "$cast" }, 2] } } }

{ $match: { "ratings.imdb": { $gte: 8 } } }

{ $match: { "ratings.rottenTomatoes": { $gte: 90 } } }

{ $match: { "ratings.imdb": { $lt: 7 } } }

{ $match: { "ratings.imdb": { $ne: 10 } } }

{ $match: { "ratings.imdb": { $exists: true } } }

üß™ Other Operators
{ $match: { awards: { $exists: true } } }

{ $match: { awards: { $type: "int" } } }

{ $match: { title: { $not: { $regex: "Love" } } } }

{ $match: { rating: { $in: [7.8, 8.5, 9.0] } } }

{ $match: { isAvailable: { $eq: true } } }


==================================================================

$group (aggregation)

-> $group stage, 'Groups documents together' based on a 'specified key' and allows you to perform 'aggregate functions'(count, sum, 
max, min, avg) on the grouped data.
-> A 'group key 'is often a field, or group of fields. The group key can also be the result of an expression. 
-> Use the '_id' field in the $group pipeline stage to set the group key.
-> In $group, when you use '_id: null' within the $group stage, it means that you are grouping all the 
documents in the collection together, treating them as a single group.

Aggregate Functions:
MIN() - returns the smallest value within the selected column
MAX() - returns the largest value within the selected column
COUNT() - returns the number of rows in a set
SUM() - returns the total sum of a numerical column
AVG() - returns the average value of a numerical column


Sample Data: 
[
  { "_id": 1, "category": "Electronics", "amount": 500 },
  { "_id": 2, "category": "Clothing", "amount": 200 },
  { "_id": 3, "category": "Electronics", "amount": 700 },
  { "_id": 4, "category": "Furniture", "amount": 1000 },
  { "_id": 5, "category": "Clothing", "amount": 300 },
  { "_id": 6, "category": "Electronics", "amount": 400 },
  { "_id": 7, "category": "Furniture", "amount": 500 }
]


--------------


1Ô∏è‚É£ group category: 
````
db.orders.aggregate([
    {
        $group: {
          _id: '$category'
        }
    }
])
````

output: 
[ { _id: 'Electronics' }, { _id: 'Clothing' }, { _id: 'Furniture' } ]


--------------


1Ô∏è‚É£ Counting Documents in Each Group
```
db.orders.aggregate([
      {
            $group: {
                _id: '$category',
                totalDocuments: { $count: {}}
            }
      }
])
```
üëâ
[
  { _id: 'Electronics', totalDocuments: 3 },
  { _id: 'Clothing', totalDocuments: 2 },
  { _id: 'Furniture', totalDocuments: 2 }
]

--------------



1Ô∏è‚É£ Count All Documents: 
Query>
db.orders.aggregate([
      {
            $group: {
                  _id: null,
                  totDoc: { $count: {}}
            }
      }
])
üëâ
[ { _id: null, totDoc: 7 } ]


--------------


1Ô∏è‚É£ calculate Total Amount in each Category: 
Query> 
db.orders.aggregate([
    {
        $group: {
            _id: '$category',
            totAmou: { $sum: '$amount' }
        }
    }
])
üëâ
[
  { _id: 'Furniture', totalSum: 1500 },
  { _id: 'Clothing', totalSum: 500 },
  { _id: 'Electronics', totalSum: 1600 }
]

--------------


1Ô∏è‚É£ Find Minimum Number from each category: 

Query>
db.orders.aggregate([
        {
            $group: {
                _id: '$category',
                minAmount: { $min: '$amount' }
            } 
        }
])
üëâ
[
  { _id: 'Furniture', minAmount: 500 },
  { _id: 'Electronics', minAmount: 400 },
  { _id: 'Clothing', minAmount: 200 }
]


--------------


1Ô∏è‚É£ Find Maximum Number from each category: 
Query>
db.orders.aggregate([
    {
        $group: {
            _id: '$category',
            maxAmount: { $max: '$amount' }
        }
    }
])
üëâ 
[
  { _id: 'Electronics', maxAmount: 700 },
  { _id: 'Clothing', maxAmount: 300 },
  { _id: 'Furniture', maxAmount: 1000 }
]


--------------

1Ô∏è‚É£ Calculate Average of each field:
Query>
db.orders.aggregate([
    {
        $group: {
            _id: '$category',
            avgAmount: { $avg: '$amount' }
        }
    }
])
üëâ
[
  { _id: 'Electronics', avgAmount: 533.3333333333334 },
  { _id: 'Clothing', avgAmount: 250 },
  { _id: 'Furniture', avgAmount: 750 }
]

--------------


sample data: 
[
  { "_id": 1, "name": "Alice", "location": { "city": "New York", "country": "USA" } },
  { "_id": 2, "name": "Bob", "location": { "city": "Los Angeles", "country": "USA" } },
  { "_id": 3, "name": "Charlie", "location": { "city": "New York", "country": "USA" } },
  { "_id": 4, "name": "David", "location": { "city": "Chicago", "country": "USA" } },
  { "_id": 5, "name": "Eve", "location": { "city": "Los Angeles", "country": "USA" } },
  { "_id": 6, "name": "Frank", "location": { "city": "San Francisco", "country": "USA" } }
]
1Ô∏è‚É£ nested object as a group key:
db.users.aggregate([
  {
      $group: {
          _id: '$location.city'
      }
  }
])
üëâ
[
  { _id: 'Los Angeles' },
  { _id: 'San Francisco' },
  { _id: 'Chicago' },
  { _id: 'New York' }
]


-------------

sample data:
[
  { "_id": 1, "category": "Electronics", "year": 2023, "amount": 500 },
  { "_id": 2, "category": "Clothing", "year": 2023, "amount": 200 },
  { "_id": 3, "category": "Electronics", "year": 2024, "amount": 700 },
  { "_id": 4, "category": "Furniture", "year": 2023, "amount": 1000 },
  { "_id": 5, "category": "Clothing", "year": 2024, "amount": 300 },
  { "_id": 6, "category": "Electronics", "year": 2023, "amount": 400 },
  { "_id": 7, "category": "Furniture", "year": 2024, "amount": 500 },
  { "_id": 8, "category": "Clothing", "year": 2023, "amount": 100 }
]

2Ô∏è‚É£. Grouping by Multiple Fields
db.orders.aggregate([
  {
    $group: {
      _id: { cat: "$category", ye: "$year" }, // Group by category and year
      totalSales: { $sum: "$amount" },
      totalDocs: { $count: {}},
      minSale: { $min: '$amount' },
      maxSale: { $max: '$amount' },
      avgSale: { $avg: '$amount' }
    } 
  }
]);
o/p
[
  {
    _id: { cat: 'Clothing', ye: 2023 },
    totalSales: 300,
    totalDocs: 2,
    minSale: 100,
    maxSale: 200,
    avgSale: 150
  },
  {
    _id: { cat: 'Electronics', ye: 2024 },
    totalSales: 700,
    totalDocs: 1,
    minSale: 700,
    maxSale: 700,
    avgSale: 700
  },
  {
    _id: { cat: 'Clothing', ye: 2024 },
    totalSales: 300,
    totalDocs: 1,
    minSale: 300,
    maxSale: 300,
    avgSale: 300
  },
  {
    _id: { cat: 'Electronics', ye: 2023 },
    totalSales: 900,
    totalDocs: 2,
    minSale: 400,
    maxSale: 500,
    avgSale: 450
  },
  {
    _id: { cat: 'Furniture', ye: 2023 },
    totalSales: 1000,
    totalDocs: 1,
    minSale: 1000,
    maxSale: 1000,
    avgSale: 1000
  },
  {
    _id: { cat: 'Furniture', ye: 2024 },
    totalSales: 500,
    totalDocs: 1,
    minSale: 500,
    maxSale: 500,
    avgSale: 500
  }
]

---------------

3Ô∏è‚É£. Grouping Users by First Letter of Their Name

sample Data:
[
  { "_id": 1, "name": "Alice", "age": 25 },
  { "_id": 2, "name": "Alex", "age": 30 },
  { "_id": 3, "name": "Bob", "age": 22 },
  { "_id": 4, "name": "Charlie", "age": 28 },
  { "_id": 5, "name": "Chris", "age": 35 },
  { "_id": 6, "name": "David", "age": 40 },
  { "_id": 7, "name": "Diana", "age": 33 }
]

Query>
db.users.aggregate([
  {
      $group: {
          _id: { $substr: ["$name", 0, 1] }, // Extract first letter of the name
          totalUsers: { $sum: 1 }  
      }
  }
])
üëâ 
[
  { _id: 'A', totalUsers: 2 },
  { _id: 'B', totalUsers: 1 },
  { _id: 'C', totalUsers: 2 },
  { _id: 'D', totalUsers: 2 }
]


-------------

1Ô∏è‚É£ Group by 'item' and count the number of unique 'customers' who bought that item.
[
  { "item": "apple", "customer": "John" },
  { "item": "banana", "customer": "Alice" },
  { "item": "apple", "customer": "John" },
  { "item": "banana", "customer": "Bob" },
  { "item": "orange", "customer": "John" },
  { "item": "banana", "customer": "Alice" },
  { "item": "apple", "customer": "Alice" }
]
o:
[
  { "_id": "apple", "uniqueCustomerCount": 2 },
  { "_id": "banana", "uniqueCustomerCount": 2 },
  { "_id": "orange", "uniqueCustomerCount": 1 }
]

Query>
db.products.aggregate([
  {
    $group: {
      _id: '$item',
      uniCus: { $addToSet: '$customer'}
    }
  }
])

if you want to calculate total numbers: 
db.products.aggregate([
  {
    $group: {
      _id: '$item',
      uniCus: { $addToSet: '$customer' }  
    }
  },
  {
    $project: {
      _id: 1,
      uniCusCount: { $size: '$uniCus'} 
    }
  }
])

o: 
[
  { _id: 'orange', uniCusCount: 1 },
  { _id: 'apple', uniCusCount: 2 },
  { _id: 'banana', uniCusCount: 2 }
]

-------------

2Ô∏è‚É£ Find the Total Sales for Each Product Category

db.orders.aggregate([
  {
    $group: {
      _id: "$category",
      totalSales: { $sum: "$amount" }
    }
  }
]);

-------------



3Ô∏è‚É£ Find the Average Age of Users per City

db.users.aggregate([
  {
    $group: {
      _id: "$city",
      averageAge: { $avg: "$age" }
    }
  }
]);


-------------


5Ô∏è‚É£ Find the Highest and Lowest Order Amount per Category


db.orders.aggregate([
  {
    $group: {
      _id: "$category",
      maxAmount: { $max: "$amount" },
      minAmount: { $min: "$amount" }
    }
  }
]);


-------------

6Ô∏è‚É£ Group Orders by Month and Find Total Sales

sample data: 
[
  { "_id": 1, "date": ISODate("2024-01-15T00:00:00Z"), "amount": 500 },
  { "_id": 2, "date": ISODate("2024-02-20T00:00:00Z"), "amount": 700 },
  { "_id": 3, "date": ISODate("2024-01-30T00:00:00Z"), "amount": 300 },
  { "_id": 4, "date": ISODate("2024-03-10T00:00:00Z"), "amount": 900 }
]
Expected Output:
[
  { "_id": 1, "totalSales": 800 },  // January
  { "_id": 2, "totalSales": 700 },  // February
  { "_id": 3, "totalSales": 900 }   // March
]
Query>
db.orders.aggregate([
  {
    $group: {
      _id: { $month: "$date" }, // Extract the month
      totalSales: { $sum: "$amount" }
    }
  }
]);


-------------

1Ô∏è‚É£ Write a query to calculate the average order amount for each year

[
  { "_id": 1, "date": ISODate("2023-06-15T00:00:00Z"), "amount": 500 },
  { "_id": 2, "date": ISODate("2023-11-20T00:00:00Z"), "amount": 700 },
  { "_id": 3, "date": ISODate("2024-03-10T00:00:00Z"), "amount": 400 }
]
Expected Output:
[
  { "_id": 2023, "avgOrderAmount": 600 },
  { "_id": 2024, "avgOrderAmount": 400 }
]
Query> 
db.orders.aggregate([
  {
    $group: {
      _id: { $year: "$date" },
      avgOrderAmount: { $avg: "$amount" }
    }
  }
]);

-------------


7Ô∏è‚É£ count the number of "unique products" each customer has bought

sample data: 
[
  { "_id": 1, "customer": "Alice", "product": "Laptop" },
  { "_id": 2, "customer": "Alice", "product": "Mouse" },
  { "_id": 3, "customer": "Alice", "product": "Laptop" },
  { "_id": 4, "customer": "Bob", "product": "Keyboard" },
  { "_id": 5, "customer": "Bob", "product": "Mouse" }
]

Expected Output:
[
  { "_id": "Alice", "uniqueProducts": 2 },
  { "_id": "Bob", "uniqueProducts": 2 }
]

Query>
db.orders.aggregate([
  {
      $group: {
          _id: '$customer',
          uniqueProducts: { $addToSet: '$product' }
      }
  },
  {
    $project: {
      _id: 1, 
      countProducts: { $size: '$uniqueProducts'}
    }
  }
])



-----------

üîü Write a query to group users into age ranges and count how many users fall into each range.

[
  { "_id": 1, "name": "Alice", "age": 22 },
  { "_id": 2, "name": "Bob", "age": 34 },
  { "_id": 3, "name": "Charlie", "age": 29 },
  { "_id": 4, "name": "David", "age": 42 },
  { "_id": 5, "name": "Eve", "age": 50 }
]
Expected Output:
[
  { "_id": "20-30", "count": 2 },
  { "_id": "30-40", "count": 1 },
  { "_id": "40-50", "count": 1 },
  { "_id": "50+", "count": 1 }
]
Query> 
db.users.aggregate([
  {
      $group: {
        _id: {
          $switch: {
              branches: [
                { case: { $lte: ["$age", 30] }, then: "20-30" },
                { case: { $lte: ["$age", 40] } , then: "31-40" },
                { case: { $lte: ["$age", 50] } , then: '41-50'}
              ],
              default: "50+"
          }
        },
        count: { $count: {}}
      }
  }
])



-----------



üü¢ 1. Write a query to find the most frequently purchased product by customers

[
  { "_id": 1, "product": "Laptop", "quantity": 2 },
  { "_id": 2, "product": "Mouse", "quantity": 5 },
  { "_id": 3, "product": "Laptop", "quantity": 3 },
  { "_id": 4, "product": "Keyboard", "quantity": 4 },
  { "_id": 5, "product": "Laptop", "quantity": 1 }
]
Expected Output:
[
  { "_id": "Laptop", "totalQuantity": 6 },
  { "_id": "Mouse", "totalQuantity": 5 },
  { "_id": "Keyboard", "totalQuantity": 4 }
]
Query>
db.orders.aggregate([
  {
    $group: {
      _id: "$product",
      totalQuantity: { $sum: "$quantity" }
    }
  },
  { $sort: { totalQuantity: -1 } }, // Sort in descending order
  { $limit: 1 } // Get the most frequently purchased product
]);



-----------


üü¢ Write a query to calculate total revenue for each product.

[
  { "_id": 1, "product": "Laptop", "price": 1000, "quantity": 3 },
  { "_id": 2, "product": "Phone", "price": 500, "quantity": 5 },
  { "_id": 3, "product": "Tablet", "price": 300, "quantity": 2 },
  { "_id": 4, "product": "Laptop", "price": 1000, "quantity": 2 },
  { "_id": 5, "product": "Phone", "price": 500, "quantity": 1 }
]

Expected Output:
[
  { "_id": "Laptop", "totalRevenue": 5000 },  // (1000*3) + (1000*2) = 5000
  { "_id": "Phone", "totalRevenue": 3000 },   // (500*5) + (500*1) = 3000
  { "_id": "Tablet", "totalRevenue": 600 }    // (300*2) = 600
]


db.orders.aggregate([
  {
    $group: {
      _id: "$product",
      totalRevenue: { $sum: { $multiply: ["$price", "$quantity"] } }
    }
  }
]);


========================================================================================================================

üü¢ 3. Write a query to find the user who has spent the most money on orders.

[
  { "_id": 1, "customer": "Alice", "amount": 500 },
  { "_id": 2, "customer": "Bob", "amount": 700 },
  { "_id": 3, "customer": "Alice", "amount": 300 },
  { "_id": 4, "customer": "Charlie", "amount": 900 }
]
Expected Output:
[
  { "_id": "Charlie", "totalSpent": 900 },
  { "_id": "Bob", "totalSpent": 700 },
  { "_id": "Alice", "totalSpent": 800 }
]
Query>
db.orders.aggregate([
  {
    $group: {
      _id: "$customer",
      totalSpent: { $sum: "$amount" }
    }
  },
  { $sort: { totalSpent: -1 } }, // Sort in descending order
  { $limit: 1 } // Get the top spender
]);



========================================================================================================================


üü¢ 4. Find the Average Order Value Per Customer

db.orders.aggregate([
  {
    $group: {
      _id: "$customer",
      avgOrderValue: { $avg: "$amount" }
    }
  }
]);


========================================================================================================================


üü¢ 5. Count Orders Per Day

[
  { "_id": 1, "product": "Laptop", "price": 1000, "quantity": 3, "date": ISODate("2024-03-01T10:00:00Z") },
  { "_id": 2, "product": "Phone", "price": 500, "quantity": 5, "date": ISODate("2024-03-01T14:30:00Z") },
  { "_id": 3, "product": "Tablet", "price": 300, "quantity": 2, "date": ISODate("2024-03-02T09:15:00Z") },
  { "_id": 4, "product": "Laptop", "price": 1000, "quantity": 2, "date": ISODate("2024-03-02T18:45:00Z") },
  { "_id": 5, "product": "Phone", "price": 500, "quantity": 1, "date": ISODate("2024-03-03T12:00:00Z") }
]
output:
[
  { "_id": 1, "totalOrders": 2 },  // Two orders on March 1st
  { "_id": 2, "totalOrders": 2 },  // Two orders on March 2nd
  { "_id": 3, "totalOrders": 1 }   // One order on March 3rd
]
Query>
db.orders.aggregate([
  {
      $group: {
          _id: { $dayOfMonth: '$date'},
          totOrders: { $count: {}}
      }
  }
])

Hint: $dayOfMonth is a date operator in MongoDB's aggregation pipeline that extracts the day of the month (1‚Äì31) from a given date.


========================================================================================================================


üü¢ 6. Write a query to find the most popular product category (based on the number of orders)


db.orders.aggregate([
  {
    $group: {
      _id: "$category",
      totalOrders: { $sum: 1 }
    }
  },
  { $sort: { totalOrders: -1 } },
  { $limit: 1 }
]);


========================================================================================================================


üü¢ 7. Find the First Order Date Per Customer

[
  { "_id": 1, "customer": "Alice",   "product": "Laptop",  "price": 1000,  "quantity": 1, "date": ISODate("2024-03-05T10:00:00Z") },
  { "_id": 2, "customer": "Bob",     "product": "Phone",   "price": 500,   "quantity": 2, "date": ISODate("2024-03-02T14:30:00Z") },
  { "_id": 3, "customer": "Alice",   "product": "Tablet",  "price": 300,   "quantity": 1, "date": ISODate("2024-03-01T09:15:00Z") },
  { "_id": 4, "customer": "Charlie", "product": "Laptop",  "price": 1000,  "quantity": 1, "date": ISODate("2024-03-07T18:45:00Z") },
  { "_id": 5, "customer": "Bob",     "product": "Monitor", "price": 700,   "quantity": 1, "date": ISODate("2024-03-04T12:00:00Z") }
]
Expected Output:
[
  { "_id": "Alice", "firstOrderDate": ISODate("2024-03-01T09:15:00Z") },  // Alice's first order was on March 1st
  { "_id": "Bob", "firstOrderDate": ISODate("2024-03-02T14:30:00Z") },    // Bob's first order was on March 2nd
  { "_id": "Charlie", "firstOrderDate": ISODate("2024-03-07T18:45:00Z") } // Charlie's first order was on March 7th
]

Query>
db.orders.aggregate([
  {
    $group: {
      _id: "$customer",
      firstOrderDate: { $min: "$date" }
    }
  }
]);



========================================================================================================================


üü¢ 8. Calculate Total Sales Per Year


db.orders.aggregate([
  {
    $group: {
      _id: { $year: "$date" },
      totalSales: { $sum: "$amount" }
    }
  }
]);



========================================================================================================================


üü¢ 9. Find Customers Who Made More Than 5 Orders:

[
  { "_id": 1, "customer": "Alice", "product": "Laptop", "price": 1000, "quantity": 1, "date": ISODate("2024-03-01T10:00:00Z") },
  { "_id": 2, "customer": "Alice", "product": "Phone", "price": 500, "quantity": 2, "date": ISODate("2024-03-02T14:30:00Z") },
  { "_id": 3, "customer": "Alice", "product": "Tablet", "price": 300, "quantity": 1, "date": ISODate("2024-03-03T09:15:00Z") },
  { "_id": 4, "customer": "Alice", "product": "Monitor", "price": 700, "quantity": 1, "date": ISODate("2024-03-04T18:45:00Z") },
  { "_id": 5, "customer": "Alice", "product": "Keyboard", "price": 100, "quantity": 1, "date": ISODate("2024-03-05T12:00:00Z") },
  { "_id": 6, "customer": "Alice", "product": "Mouse", "price": 50, "quantity": 1, "date": ISODate("2024-03-06T15:30:00Z") },
  { "_id": 7, "customer": "Bob", "product": "Laptop", "price": 1000, "quantity": 1, "date": ISODate("2024-03-01T10:00:00Z") },
  { "_id": 8, "customer": "Bob", "product": "Phone", "price": 500, "quantity": 1, "date": ISODate("2024-03-02T14:30:00Z") },
  { "_id": 9, "customer": "Charlie", "product": "Tablet", "price": 300, "quantity": 1, "date": ISODate("2024-03-03T09:15:00Z") },
  { "_id": 10, "customer": "Charlie", "product": "Monitor", "price": 700, "quantity": 1, "date": ISODate("2024-03-04T18:45:00Z") }
]
expected: 
[
  { "_id": "Alice", "totalOrders": 6 }
]

Query>
db.orders.aggregate([
  {
    $group: {
      _id: "$customer",
      totalOrders: { $sum: 1 }
    }
  },
  { $match: { totalOrders: { $gt: 5 } } }
]);


============================================================================================================================================================


üü¢ üîü Find the Top 3 Selling Products

db.orders.aggregate([
  {
    $group: {
      _id: "$product",
      totalSold: { $sum: "$quantity" }
    }
  },
  { $sort: { totalSold: -1 } },
  { $limit: 3 }
]);

============================================================================================================================================================


üü¢ Find the total number of active users per country

db.users.aggregate([
  {
    $match: {
      status: 'active'
    }
  },
  {
      $group: {
        _id: '$country',
        totUsers: { $sum: 1 }
      }
  }
])


========================================================================================================================

üü¢ Find the month with the highest revenue

db.orders.aggregate([
  {
    $group: {
      _id: { $month: "$date" },  // Extract month from date
      totalRevenue: { $sum: { $multiply: ["$price", "$quantity"] } }  // Calculate total revenue per month
    }
  },
  { $sort: { totalRevenue: -1 } },  // Sort by revenue in descending order
  { $limit: 1 }  // Get the top month with the highest revenue
]);


========================================================================================================================

üü¢ Group orders by day of the week (Monday, Tuesday, etc.)

[
  { "orderId": 101, "orderDate": "2025-03-17", "dayOfWeek": "Monday", "amount": 250 },
  { "orderId": 102, "orderDate": "2025-03-18", "dayOfWeek": "Tuesday", "amount": 180 },
  { "orderId": 103, "orderDate": "2025-03-19", "dayOfWeek": "Wednesday", "amount": 300 },
  { "orderId": 104, "orderDate": "2025-03-17", "dayOfWeek": "Monday", "amount": 150 },
  { "orderId": 105, "orderDate": "2025-03-20", "dayOfWeek": "Thursday", "amount": 400 },
  { "orderId": 106, "orderDate": "2025-03-21", "dayOfWeek": "Friday", "amount": 220 },
  { "orderId": 107, "orderDate": "2025-03-22", "dayOfWeek": "Saturday", "amount": 310 },
  { "orderId": 108, "orderDate": "2025-03-23", "dayOfWeek": "Sunday", "amount": 275 },
  { "orderId": 109, "orderDate": "2025-03-18", "dayOfWeek": "Tuesday", "amount": 190 },
  { "orderId": 110, "orderDate": "2025-03-19", "dayOfWeek": "Wednesday", "amount": 260 }
]
output:
[
  { "_id": 2, "totOrders": 15 }, // Monday
  { "_id": 3, "totOrders": 10 }, // Tuesday
  { "_id": 4, "totOrders": 8 },  // Wednesday
  { "_id": 5, "totOrders": 12 }, // Thursday
  { "_id": 6, "totOrders": 20 }, // Friday
  { "_id": 7, "totOrders": 18 }, // Saturday
  { "_id": 1, "totOrders": 9 }   // Sunday
]







========================================================================================================================


$project :
-> Reshapes the documents by including/excluding fields, or renaming fields.

1Ô∏è‚É£
playGround> db.users.aggregate([
    {
        $project: {
                    _id: 0,  // exclude
                    gender: 1, // include
                    email: 1
        }
     }
])
[
  { gender: 'male', email: 'victor.pedersen@example.com' },
  { gender: 'male', email: 'carl.jacobs@example.com' }
]


2Ô∏è‚É£. Rename a Field (it will not rename field in real documents, its just for the next stage)
db.users.aggregate([
  {
    $project: {
      _id: 0,
      fullName: "$name",  // Rename `name` to `fullName`
      age: 1
    }
  }
]);


3Ô∏è‚É£ Add a New Computed Field / new field
db.users.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      age: 1,
      isAdult: { $gte: ["$age", 18] }  // Add `isAdult` field
    }
  }
]);
same as : db.users.find({}, {_id: 0, firstName: '$name.first',  'dob.age': 1, isAdult: { $gte: ["$dob.age", 18]}})


4Ô∏è‚É£ Concatenate Fields:
db.users.aggregate([
  {
    $project: {
      _id: 0,
      fullName: { $concat: ["$name", " - ", "$city"] } // Merge name & city
    }
  }
]);
same as : db.users.find({}, {_id: 0, fullName: { $concat: ["$name.first", " - ", "$location.city"]}})
o/p
[
  { "fullName": "Adesh - Mumbai" },
  { "fullName": "Shubham - Delhi" },
  { "fullName": "Swar - Pune" }
]


========================================================================================================================

$sort: 
-> Sorts the documents based on specified criteria

db.students.aggregate([
    $sort: {
        totalCount: -1  // descending order
    }
])

========================================================================================================================

$limit:
-> Limits the number of documents passed to the next stage in the pipeline.
eg> 
db.students.aggregate([
  {
    $limit: 3 
  }
])

========================================================================================================================

$skip:
-> Skips a specified number of documents in the pipeline and returns the rest
-> This is often used in conjunction with $limit to implement pagination.

db.students.aggregate([
  {
    $skip: 2  // skip first two documents
  }
])


========================================================================================================================


4. $unwind 

-> The $unwind stage in MongoDB's aggregation pipeline is used to deconstruct an array field, creating a separate document 
for each element in the array. This is useful when you need to work with individual array elements rather than the entire array.
-> By default, $unwind removes documents where the array is empty or null.

0Ô∏è‚É£. 
Input: 
[
    {_id: 1, age: 21, tags: [10, 20]},
    {_id: 2, age: 22, tags: [10, 20, 30]},
    {_id: 3, age: 23, tags: [10, 20, 30, 40, 50]},
    {_id: 4, age: 24, tags: [10, 20]},
    {_id: 5, age: 25, tags: [10]},
]
Query> db.users.aggregate([
  {
    $unwind: '$tags'
  }
]);
output: 
[
  { _id: 1, age: 21, tags: 10 },
  { _id: 1, age: 21, tags: 20 },
  { _id: 2, age: 22, tags: 10 },
  { _id: 2, age: 22, tags: 20 },
  { _id: 2, age: 22, tags: 30 },
  { _id: 3, age: 23, tags: 10 },
  { _id: 3, age: 23, tags: 20 },
  { _id: 3, age: 23, tags: 30 },
  { _id: 3, age: 23, tags: 40 },
  { _id: 3, age: 23, tags: 50 },
  { _id: 4, age: 24, tags: 10 },
  { _id: 4, age: 24, tags: 20 },
  { _id: 5, age: 25, tags: 10 }
]


1Ô∏è‚É£
input: 
[
  { "_id": 1, "customer": "Alice", "items": ["Laptop", "Mouse"] },
  { "_id": 2, "customer": "Bob", "items": ["Keyboard"] },
  { "_id": 3, "customer": "Charlie", "items": [] }
]

Query> db.orders.aggregate([
  { $unwind: "$items" }
]);

Output: 
[
  { "_id": 1, "customer": "Alice", "items": "Laptop" },
  { "_id": 1, "customer": "Alice", "items": "Mouse" },
  { "_id": 2, "customer": "Bob", "items": "Keyboard" }
]



2Ô∏è‚É£. By default, $unwind removes documents where the array is empty or null.but if you want them then use:
input: 
[
  { "_id": 1, "customer": "Alice", "items": ["Laptop", "Mouse"] },
  { "_id": 2, "customer": "Bob", "items": ["Keyboard"] },
  { "_id": 3, "customer": "Charlie", "items": [] }
]
output:
[
  { _id: 1, customer: 'Alice', items: 'Laptop' },
  { _id: 1, customer: 'Alice', items: 'Mouse' },
  { _id: 2, customer: 'Bob', items: 'Keyboard' },
  { _id: 3, customer: 'Charlie' }
]
Query> db.users.aggregate([
  { $unwind: { path: "$items", preserveNullAndEmptyArrays: true } }
]);


3Ô∏è‚É£. Include Array Index: 
db.orders.aggregate([
  { $unwind: { path: "$items", includeArrayIndex: "itemIndex" } }
]);
output: 
[
  { "_id": 1, "customer": "Alice", "items": "Laptop", "itemIndex": 0 },
  { "_id": 1, "customer": "Alice", "items": "Mouse", "itemIndex": 1 },
  { "_id": 2, "customer": "Bob", "items": "Keyboard", "itemIndex": 0 }
]



4Ô∏è‚É£. Count Total Sum of tags  Per Customer:

[
  { "_id": 1, "name": "Alice", "tags": [2, 6, 8] },
  { "_id": 2, "name": "Bob", "tags": [3, 4, 5] },
  { "_id": 3, "name": "Charlie", "tags": [7, 10, 12] },
  { "_id": 4, "name": "David", "tags": [1, 2, 3] }
]
Output:
[
  { "_id": 1, "name": "Alice", "tags": 6 },
  { "_id": 1, "name": "Alice", "tags": 8 },
  { "_id": 3, "name": "Charlie", "tags": 7 },
  { "_id": 3, "name": "Charlie", "tags": 10 },
  { "_id": 3, "name": "Charlie", "tags": 12 }
]


db.collection.aggregate([
  {
    $project: {
      name: 1,
      totalTagSum: { $sum: "$tags" }
    }
  }
])


‚ùì find the total number of elements in an array field like tags:
Query>
db.collection.aggregate([
  {
    $project: {
      name: 1,
      tagCount: { $size: "$tags" }
    }
  }
])



========================================================================================================================


$addFields:

-> $addFields is used to update the value of an existing field or to add a new field


1Ô∏è‚É£ add 'active' field in all documents.
[
  { _id: 1, name: 'Alice', age: 22 },
  { _id: 2, name: 'Bob', age: 34 },
  { _id: 3, name: 'Charlie', age: 29 }
]
output: 
[
  { _id: 1, name: 'Alice', age: 22, status: 'active' },
  { _id: 2, name: 'Bob', age: 34, status: 'active' },
  { _id: 3, name: 'Charlie', age: 29, status: 'active' }
]
Query>
db.users.aggregate([
  {
    $addFields: {
      status: 'active'
    }
  }
])



2Ô∏è‚É£ Adding a Nested Field
[
  { _id: 1, name: 'Alice', age: 22 },
  { _id: 2, name: 'Bob', age: 34 },
  { _id: 3, name: 'Charlie', age: 29 }
]
output: 
[
  {
    _id: 1,
    name: 'Alice',
    age: 22,
    address: { city: 'Pune', village: 'Lohegaon' }
  },
  {
    _id: 2,
    name: 'Bob',
    age: 34,
    address: { city: 'Pune', village: 'Lohegaon' }
  },
  {
    _id: 3,
    name: 'Charlie',
    age: 29,
    address: { city: 'Pune', village: 'Lohegaon' }
  }
]
Query>
db.users.aggregate([
  {
    $addFields: {
      address: { city: 'Pune', village: 'Lohegaon' }
    }
  }
])


1Ô∏è‚É£. add 'isAdult field':
[
  { _id: 1, name: 'Alice', age: 22 },
  { _id: 2, name: 'Bob', age: 34 },
  { _id: 3, name: 'Charlie', age: 29 }
]
output: 
[
  { _id: 1, name: 'Alice', age: 22, isAdult: false },
  { _id: 2, name: 'Bob', age: 34, isAdult: true },
  { _id: 3, name: 'Charlie', age: 29, isAdult: false }
]
Query> 
db.users.aggregate([
  {
    $addFields: {
      isAdult: { $gte: ["$age", 30] }
    }
  }
])



2Ô∏è‚É£ update the value of an existing field:
[
  { _id: 1, name: 'Alice', age: 22 },
  { _id: 2, name: 'Bob', age: 34 },
  { _id: 3, name: 'Charlie', age: 29 }
]
output:
[
  { _id: 1, name: 'Alice', age: 44 },
  { _id: 2, name: 'Bob', age: 68 },
  { _id: 3, name: 'Charlie', age: 58 }
]
Query>
db.users.aggregate([
  {
    $addFields: {
      age: { $multiply: ['$age', 2]}
    }
  }
])


2Ô∏è‚É£ Query: Creating a fullName Field

db.users.aggregate([
  {
    $addFields: {
      fullName: { $concat: ["$fname", "$lname"] }
    }
  }
])



1Ô∏è‚É£ add new field called "totalCost" by multiplying two fields of same collection.

db.users.aggregate([
  {
    $addFields: {
        totalCost: {  $multiply: ["$age", "$amount"] }
    }
  }
])


========================================================================================================================

$first: 

-> The $first operator is used inside aggregation stages like $group or $project or $addFields to return the "first element of an array" or the "first document in a 
group".

1Ô∏è‚É£ returns the first order for each customer
db.orders.insertMany([
  { "_id": 1, "customer": "Alice", "orderDate": "2001-12-22", "amount": 300 },
  { "_id": 2, "customer": "Alice", "orderDate": "2025-03-01", "amount": 200 },
  { "_id": 3, "customer": "Bob", "orderDate": "2025-03-02", "amount": 300 },
  { "_id": 4, "customer": "Bob", "orderDate": "1999-01-30", "amount": 1000 }
])
Output:
[
  { "_id": 1, "customer": "Alice", "orderDate": "2001-12-22", "amount": 300 },
  { "_id": 3, "customer": "Bob", "orderDate": "2025-03-02", "amount": 300 },
]
Query>
db.users.aggregate([
  {
    $group: {
      _id: '$customer',
      firstOrder: { $first: '$orderDate' }  
    }
  }
])


2Ô∏è‚É£  Using $first in $project with Arrays

raisoni> db.products.find()
[
  { _id: 1, name: 'Laptop', reviews: [ 'Great', 'Good', 'Decent' ] },
  { _id: 2, name: 'Phone', reviews: [ 'Awesome', 'Okay', 'Not bad' ] }
]
output: 
[
  { _id: 1, name: 'Laptop', reviews: 'Great' },
  { _id: 2, name: 'Phone', reviews: 'Awesome' }
]
Query>
db.products.aggregate([
  {
    $project: {
      name: 1, 
      reviews: { $first: '$reviews'}
    }
  }
])


========================================================================================================================



$lookup:

-> Performs a 'left outer join' to 'another collection' in the same database to combine documents from two 
collections based on a 'common field'.
-> LEFT (OUTER) JOIN: Returns 'all records' from the 'left table', and the 'matched records' from the 'right table'

‚ùì Query: Write a MongoDB aggregation query to fetch orders along with customer details.
customers:
[
  {
    "_id": ObjectId("65a1b2c3d4e5f67890123456"),
    "name": "John Doe",
    "email": "john.doe@example.com"
  },
  {
    "_id": ObjectId("65a1b2c3d4e5f67890123457"),
    "name": "Alice Smith",
    "email": "alice.smith@example.com"
  }
]

orders:
[
  {
    _id: ObjectId("67e560a5093897fb285ca506"),
    customerId: ObjectId("65a1b2c3d4e5f67890123456"),
    totalAmount: 150,
    items: [ 'Laptop', 'Mouse' ]
  },
  {
    _id: ObjectId("67e560a5093897fb285ca507"),
    customerId: ObjectId("65a1b2c3d4e5f67890123457"),
    totalAmount: 200,
    items: [ 'Monitor', 'Keyboard' ]
  }
]
output: 
[
  {
    "_id": ObjectId("70b1c2d3e4f5g67890123456"),
    "customerId": ObjectId("65a1b2c3d4e5f67890123456"),
    "totalAmount": 150,
    "items": ["Laptop", "Mouse"],
    "customerDetails": {
        "_id": ObjectId("65a1b2c3d4e5f67890123456"),
        "name": "John Doe",
        "email": "john.doe@example.com"
      }
  },
  {
    "_id": ObjectId("70b1c2d3e4f5g67890123457"),
    "customerId": ObjectId("65a1b2c3d4e5f67890123457"),
    "totalAmount": 200,
    "items": ["Monitor", "Keyboard"],
    "customerDetails": {
        "_id": ObjectId("65a1b2c3d4e5f67890123457"),
        "name": "Alice Smith",
        "email": "alice.smith@example.com"
      }
  }
]
Query>
db.orders.aggregate([
  {
    $lookup: {
      from: 'customers',
      localField: 'customerId',
      foreignField: '_id',
      as: 'customerDetails'
    }
  },
  {
      $addFields:{
          customerDetails: { $first: '$customerDetails' }
      } 
  }
])






‚ùì To find customers who haven‚Äôt placed any orders, we need to compare two collections:  
---------------------------------------------------------------------------------------
customers:
[
  { "_id": 1, "name": "Alice", "email": "alice@example.com" },
  { "_id": 2, "name": "Bob", "email": "bob@example.com" },
  { "_id": 3, "name": "Charlie", "email": "charlie@example.com" },
  { "_id": 4, "name": "David", "email": "david@example.com" }
]
orders:
[
  { "_id": 101, "customerId": 1, "product": "Laptop", "price": 1000 },
  { "_id": 102, "customerId": 3, "product": "Phone", "price": 500 }
]
Output:
[
  { "_id": 2, "name": "Bob", "email": "bob@example.com" },
  { "_id": 4, "name": "David", "email": "david@example.com" }
]
Query>
db.customers.aggregate([
  {
    $lookup: {
      from: 'orders',
      localField: '_id',
      foreignField: 'customerId',
      as: 'orderDetail'
    }
  },
  {
    $match: {
      orderDetail: { $size: 0 }
    }
  }
])


or: 
---


  db.customers.aggregate([
    {
        $lookup: {
            from: 'orders',
            localField: '_id',
            foreignField: 'customerId',
            as: "orderDetails"
        }
    },
    {
        $match: {
                $expr: {
                    $lt: [{ $size: "$orderDetails"}, 1]
                }
        }
    }
  ]);





‚ùì customers whoplaces orders (take above sample data): 
-------------------------------------------------------
  db.orders.aggregate([
    {
        $lookup: {
            from: 'customers',
            localField: 'customerId',
            foreignField: '_id',
            as: "customerDetails"
        }
    }
  ])





  ============================================================================================================================================================



Example: Joining More Than Two Collections


students (contains student details)
enrollments (links students to courses)
courses (contains course details)


Query> We want to retrieve each student's details, their enrollments, and the course details they are enrolled in.

students:
db.students.insertMany([
  {
    "_id": 1,
    "name": "Alice Johnson",
    "email": "alice.johnson@example.com"
  },
  {
    "_id": 2,
    "name": "Bob Williams",
    "email": "bob.williams@example.com"
  }
]);


db.enrollments.insertMany([
  {
    "_id": 1,
    "studentId": 1,
    "courseId": 1,
    "enrollmentDate": "2024-03-25"
  },
  {
    "_id": 2,
    "studentId": 2,
    "courseId": 2,
    "enrollmentDate": "2024-03-20"
  }
]);

db.courses.insertMany([
  {
    "_id": 1,
    "courseName": "Mathematics",
    "instructor": "Dr. John Smith"
  },
  {
    "_id": 2,
    "courseName": "Physics",
    "instructor": "Dr. Emily Davis"
  }
]);

Output: 
[
  {
    "_id": 1,
    "name": "Alice Johnson",
    "email": "alice.johnson@example.com",
    "enrollments": {
      "enrollmentDate": "2024-03-25"
    },
    "courseDetails": {
      "courseName": "Mathematics",
      "instructor": "Dr. John Smith"
    }
  },
  {
    "_id": 2,
    "name": "Bob Williams",
    "email": "bob.williams@example.com",
    "enrollments": {
      "enrollmentDate": "2024-03-20"
    },
    "courseDetails": {
      "courseName": "Physics",
      "instructor": "Dr. Emily Davis"
    }
  }
]



Query>
db.students.aggregate([
  {
    $lookup: {
      from: 'enrollments',
      localField: '_id',
      foreignField: 'studentId',
      as: 'enrollments'
    }
  },
  {
    $unwind: {
      path: '$enrollments',
      preserveNullAndEmptyArrays: true
    }
  },
  {
    $lookup: {
      from: 'courses',
      localField: 'enrollments.courseId',
      foreignField: '_id',
      as: 'courseDetails'
    }
  },
  {
    $addFields: {
      courseDetails: { $first: '$courseDetails' }
    }
  }
])





















Basic Level
Write an aggregation query to find the total number of documents in a collection.

Find the total number of movies released after 2015 in a movies collection.

Retrieve the total sales amount from an orders collection where each order has an amount field.

Group customers by country and count how many customers belong to each country.

Find all orders placed by a specific customer using $match and $lookup.

Intermediate Level
Find the top 5 most rented movies from a rentals collection.

Calculate the average price of products in each category from a products collection.

Find the most popular product category based on total sales amount.

List the customers who have rented more than 5 movies.

Perform a $lookup to join orders with customers, and display only customers who have placed an order.

Find the total revenue generated per month from the orders collection.

Find all users whose last login date is more than 30 days ago using $match and $dateSubtract.

Count the number of products in each category and exclude categories that have fewer than 10 products.

Find the highest-priced product in each category.

Sort orders by total price in descending order and return only the top 10.

Advanced Level
Find the percentage of movies rented by premium vs. regular customers using $group and $facet.

List the top 3 customers who have spent the most money on rentals in the last year.

Perform a multi-level $lookup to join orders ‚Üí customers ‚Üí addresses to get customer addresses along with orders.

Calculate the average movie rating per genre from a movies collection.

Find customers who have placed an order but never rented a movie (using $lookup and $match).

Find the top-selling products for each month in the last year using $group and $dateToString.

Find the customer who rented the highest number of different movie genres.

Find duplicate customer emails in a users collection using $group and $count.

Calculate customer retention by counting how many customers placed orders in both the current and previous year.

Write an aggregation query to paginate orders (limit + skip) and sort them by date.

