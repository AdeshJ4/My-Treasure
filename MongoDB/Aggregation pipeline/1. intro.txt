The MongoDB Aggregation Pipeline
--------------------------------

An 'aggregation pipeline' consists of 'one or more stages' that 'process documents':

'Each stage' 'performs an operation' on the 'input documents'. 
For example, a stage can 'filter documents', 'group documents', and 'calculate values'.

The documents that are 'output from a stage' are passed as a 'input to the next stage'.

An aggregation pipeline can return results for groups of documents. For example, return the total, average, 
maximum, and minimum values.

Note: 
Aggregation pipelines run with the db.collection.aggregate() method do not modify documents in a collection, 
unless the pipeline contains a '$merge or $out stage.'

why we use aggregation pipeline: 
1. The MongoDB aggregation framework provides a powerful way to 'process and analyze data' also offers several advantages when it 
comes to complex data manipulation and analysis tasks:
2. Performance is better than normal queries.
3. Data Transformation & data manipulation




Popular Stages: 
===============

$match (aggregation): 

-> The `$match` stage 'filters documents' based on specified condition(s), allowing only matching documents to 
proceed to the next pipeline stage.
-> To optimize the pipeline place $match as early in the aggregation Pipeline
-> The $match query syntax is identical to the read operation query syntax;

1. Match documents where status is "active":
db.users.aggregate([
  {
    $match: { status: "active" }
  }
]);

2. Match documents with an age greater than 25:
db.users.aggregate([
  {
    $match: { age: { $gt: 25 } }
  }
]);

3. Match documents with multiple conditions (AND condition):
db.orders.aggregate([
  {
    $match: { 
      status: "shipped",
      totalAmount: { $gt: 100 }
    }
  }
]);

4. Match documents with an OR condition using $or
db.orders.aggregate([
  {
    $match: { 
      status: "shipped",
      totalAmount: { $gt: 100 }
    }
  }
]);


db.users.aggregate([
    {
        $match: {age: {$in: [20, 30, 40]}}
    }
])


==================================================================

$group (aggregation)

-> $group stage, 'Groups documents together' based on a 'specified key' and allows you to perform 'aggregate functions'(count, sum, 
max, min, avg) on the grouped data.
-> A 'group key 'is often a field, or group of fields. The group key can also be the result of an expression. 
-> Use the '_id' field in the $group pipeline stage to set the group key.
-> In $group, when you use '_id: null' within the $group stage, it means that you are grouping all the 
documents in the collection together, treating them as a single group.



1️⃣ Grouping by a Single Field and calculting total Sales
db.orders.aggregate([
  {
    $group: {
      _id: "$category",         // Group by category
      totalSales: { $sum: "$amount" }
    }
  }
]);


2️⃣. Grouping by Multiple Fields
db.orders.aggregate([
  {
    $group: {
      _id: { cat: "$category", ye: "$year" }, // Group by category and year
      totalSales: { $sum: "$amount" }
    }
  }
]);
o/p
[
  { "_id": { "cat": "Electronics", "ye": 2024 }, "totalSales": 100 },
  { "_id": { "cat": "Electronics", "ye": 2023 }, "totalSales": 200 },
  { "_id": { "cat": "Clothing", "ye": 2024 }, "totalSales": 150 },
  { "_id": { "cat": "Clothing", "ye": 2023 }, "totalSales": 250 }
]


3️⃣. Using Expressions in _id

db.orders.aggregate([
  {
    $group: {
      _id: { decade: { $subtract: ["$year", "$amount"] } },
      totalSales: { $sum: "$amount" }
    }
  }
]);


4️⃣. Counting Documents in Each Group

db.orders.aggregate([
  {
    $group: {
      _id: "$category",
      orderCount: { $sum: 1 }
    }
  }
]);

5️⃣. Count the total number of documents in the aggregation pipeline:

db.users.aggregate([
    {
        $group:{_id: null, totalCount: {$sum: 1}}   // each time increment document by 1 number
    }
]);
o/p: [ { _id: null, totalCount: 5000 } ]



6️⃣ group based on city:
db.users.aggregate([ { $group: { _id: '$location.city' } }])
o/p: 
[
  { _id: 'Pune' },
  { _id: 'Mumbai' },
  { _id: 'Ratnagiri' }
]


7️⃣ Grouping and Finding Min, Max, Avg

playGround> db.shops.aggregate([ 
  { $group: { 
    _id: '$category', 
    totDocuments: {$sum: 1}, 
    totalSum: { $sum: '$amount' }, 
    average: { $avg: '$amount' }, 
    minAmount: { $min: '$amount' }, 
    maxAmout: { $max: '$amount' } } 
    }
]);
o/p: 

[
  {
    _id: 'Electronics',
    totDocuments: 5,
    totalSum: 1500,
    average: 300,
    minAmount: 100,
    maxAmout: 500
  },
  {
    _id: 'Clothing',
    totDocuments: 5,
    totalSum: 1750,
    average: 350,
    minAmount: 150,
    maxAmout: 550
  },
  {
    _id: 'Home Appliances',
    totDocuments: 5,
    totalSum: 2500,
    average: 500,
    minAmount: 300,
    maxAmout: 700
  },
  {
    _id: 'Books',
    totDocuments: 5,
    totalSum: 750,
    average: 150,
    minAmount: 50,
    maxAmout: 250
  }
]








multi stage pipeline

db.users.aggregate([
    {
        $match: {
            isActive: true
        }
    },
    {
        $group: {
            _id: '$company.location.country',
            totalCount: {$count: {}} 
        }
    },
    {
        $sort: {
            totalCount: -1
        }
    },
    {
        $limit: 3
    },
    {
        $project: {
            _id: 0
        }
    }
])


========================================================================================================================


$project :
-> Reshapes the documents by including/excluding fields, or renaming fields.

1️⃣
playGround> db.users.aggregate([
    {
        $project: {
                    _id: 0,  // exclude
                    gender: 1, // include
                    email: 1
        }
     }
])
[
  { gender: 'male', email: 'victor.pedersen@example.com' },
  { gender: 'male', email: 'carl.jacobs@example.com' }
]


2️⃣. Rename a Field (it will not rename field in real documents, its just for the next stage)
db.users.aggregate([
  {
    $project: {
      _id: 0,
      fullName: "$name",  // Rename `name` to `fullName`
      age: 1
    }
  }
]);


3️⃣ Add a New Computed Field / new field
db.users.aggregate([
  {
    $project: {
      _id: 0,
      name: 1,
      age: 1,
      isAdult: { $gte: ["$age", 18] }  // Add `isAdult` field
    }
  }
]);
same as : db.users.find({}, {_id: 0, firstName: '$name.first',  'dob.age': 1, isAdult: { $gte: ["$dob.age", 18]}})


4️⃣ Concatenate Fields:
db.users.aggregate([
  {
    $project: {
      _id: 0,
      fullName: { $concat: ["$name", " - ", "$city"] } // Merge name & city
    }
  }
]);
same as : db.users.find({}, {_id: 0, fullName: { $concat: ["$name.first", " - ", "$location.city"]}})
o/p
[
  { "fullName": "Adesh - Mumbai" },
  { "fullName": "Shubham - Delhi" },
  { "fullName": "Swar - Pune" }
]



========================================================================================================================

$sort: 
-> Sorts the documents based on specified criteria
$sort: {
    totalCount: -1  // descending order
}

========================================================================================================================

$limit:
-> Limits the number of documents passed to the next stage in the pipeline.
eg> $limit: 3

========================================================================================================================

$skip:
-> Skips a specified number of documents in the pipeline and returns the rest
-> This is often used in conjunction with $limit to implement pagination.

db.students.aggregate([
  {
    $skip: 2  // skip first two documents
  }
])


========================================================================================================================


4. $unwind 

-> The $unwind stage in MongoDB's aggregation pipeline is used to deconstruct an array field, creating a separate document 
for each element in the array. This is useful when you need to work with individual array elements rather than the entire array.
-> By default, $unwind removes documents where the array is empty or null.

0️⃣. 
Input: 
[
    {_id: 1, age: 21, tags: [10, 20]},
    {_id: 2, age: 22, tags: [10, 20, 30]},
    {_id: 3, age: 23, tags: [10, 20, 30, 40, 50]},
    {_id: 4, age: 24, tags: [10, 20]},
    {_id: 5, age: 25, tags: [10]},
]
Query> db.users.aggregate([
  {
    $unwind: '$tags'
  }
]);
output: 
[
  { _id: 1, age: 21, tags: 10 },
  { _id: 1, age: 21, tags: 20 },
  { _id: 2, age: 22, tags: 10 },
  { _id: 2, age: 22, tags: 20 },
  { _id: 2, age: 22, tags: 30 },
  { _id: 3, age: 23, tags: 10 },
  { _id: 3, age: 23, tags: 20 },
  { _id: 3, age: 23, tags: 30 },
  { _id: 3, age: 23, tags: 40 },
  { _id: 3, age: 23, tags: 50 },
  { _id: 4, age: 24, tags: 10 },
  { _id: 4, age: 24, tags: 20 },
  { _id: 5, age: 25, tags: 10 }
]


1️⃣
input: 
[
  { "_id": 1, "customer": "Alice", "items": ["Laptop", "Mouse"] },
  { "_id": 2, "customer": "Bob", "items": ["Keyboard"] },
  { "_id": 3, "customer": "Charlie", "items": [] }
]

Query> db.orders.aggregate([
  { $unwind: "$items" }
]);

Output: 
[
  { "_id": 1, "customer": "Alice", "items": "Laptop" },
  { "_id": 1, "customer": "Alice", "items": "Mouse" },
  { "_id": 2, "customer": "Bob", "items": "Keyboard" }
]



2️⃣. By default, $unwind removes documents where the array is empty or null.but if you want them then use:
input: 
[
  { "_id": 1, "customer": "Alice", "items": ["Laptop", "Mouse"] },
  { "_id": 2, "customer": "Bob", "items": ["Keyboard"] },
  { "_id": 3, "customer": "Charlie", "items": [] }
]

Query> db.users.aggregate([
  { $unwind: { path: "$items", preserveNullAndEmptyArrays: true } }
]);

output:
[
  { _id: 1, customer: 'Alice', items: 'Laptop' },
  { _id: 1, customer: 'Alice', items: 'Mouse' },
  { _id: 2, customer: 'Bob', items: 'Keyboard' },
  { _id: 3, customer: 'Charlie' }
]

3️⃣. Include Array Index: 
db.orders.aggregate([
  { $unwind: { path: "$items", includeArrayIndex: "itemIndex" } }
]);
output: 
[
  { "_id": 1, "customer": "Alice", "items": "Laptop", "itemIndex": 0 },
  { "_id": 1, "customer": "Alice", "items": "Mouse", "itemIndex": 1 },
  { "_id": 2, "customer": "Bob", "items": "Keyboard", "itemIndex": 0 }
]



4️⃣. Count Total Items Sold Per Customer:
db.users.aggregate([
  {
    $unwind: '$tags'
  },
  {
    $match: {
      'tags': {
        $gt: 5
      }
    }
  }
]);


========================================================================================================================


$addFields:

-> $addFields is used to update the value of an existing field or to add a new field


ex: add 'active' field in all documents.
db.tb1.aggregate([ { $addFields: { active: true } }])
[
  { _id: 1, age: 21, tags: [ 10, 20 ], active: true },
  { _id: 6, age: 26, active: true }
]


ex: Adding a Nested Field
[
  { "_id": 1, "name": "Alice", "age": 25},
  { "_id": 2, "name": "Bob", "age": 30}
]

db.users.aggregate([
  {
    $addFields: {
      contact: { email: "example@example.com", phone: "1234567890" }
    }
  }
])

[
  { "_id": 1, "name": "Alice", "age": 25, "contact": { "email": "example@example.com", "phone": "1234567890" } },
  { "_id": 2, "name": "Bob", "age": 30, "contact": { "email": "example@example.com", "phone": "1234567890" } }
]




1️⃣. add 'isAdult field':
Input: 
[
  { "_id": 1, "name": "Alice", "age": 25 },
  { "_id": 2, "name": "Bob", "age": 30 }
]

Query> db.users.aggregate([
  {
    $addFields: {
      isAdult: { $gte: ["$age", 18] }
    }
  }
])

Output:
[
  { "_id": 1, "name": "Alice", "age": 25, "isAdult": true },
  { "_id": 2, "name": "Bob", "age": 30, "isAdult": true }
]


2️⃣ update the value of an existing field:
Input: 
[
  { "_id": 1, "name": "Alice", "salary": 5000 },
  { "_id": 2, "name": "Bob", "salary": 7000 }
]

Query> db.users.aggregate([
  {
    $addFields: {
      salary: { $multiply: ["$salary", 1.10] } // Increases salary by 10%
    }
  }
])

Output:
[
  { "_id": 1, "name": "Alice", "salary": 5500 },
  { "_id": 2, "name": "Bob", "salary": 7700 }
]



========================================================================================================================

$first: 

-> $first is an accumulator in the MongoDB aggregation pipeline that returns the first value of a specified field within a group. 
-> It is commonly used in the $group stage to retrieve the first occurrence of a field when documents are grouped.
-> $first cannot be used as a "standalone stage" in the aggregation pipeline. It is an accumulator operator, meaning it must be 
used within a stage like $group, $setWindowFields, or $project (inside an expression).
When to Use $first?
-> To get the earliest record in a grouped dataset
-> When flattening arrays using $unwind, and you only need the first value
-> To extract first occurring values after a $sort.

example: 
Input:
[
  { "_id": 1, "category": "Electronics", "item": "Laptop", "price": 1000 },
  { "_id": 2, "category": "Electronics", "item": "Phone", "price": 500 },
  { "_id": 3, "category": "Furniture", "item": "Table", "price": 200 },
  { "_id": 4, "category": "Furniture", "item": "Chair", "price": 100 }
]

Query> db.orders.aggregate([
  { $sort: { _id: 1 } }, // Ensuring order before grouping
  {
    $group: {
      _id: "$category",
      firstItem: { $first: "$item" }, // Get the first item per category
      firstPrice: { $first: "$price" } // Get the first price per category
    }
  }
])

Output:
[
  { "_id": "Electronics", "firstItem": "Laptop", "firstPrice": 1000 },
  { "_id": "Furniture", "firstItem": "Table", "firstPrice": 200 }
]


2️⃣ Example 2: Using $first After $unwind
[
  { "_id": 1, "name": "Alice", "scores": [90, 85, 80] },
  { "_id": 2, "name": "Bob", "scores": [88, 92, 79] }
]

Query> db.students.aggregate([
  { $unwind: "$scores" }, // Flatten scores array
  {
    $group: {
      _id: "$name",
      firstScore: { $first: "$scores" } // Get the first score per student
    }
  }
])

Output>
[
  { "_id": "Alice", "firstScore": 90 },
  { "_id": "Bob", "firstScore": 88 }
]



========================================================================================================================

$lookup:

-> Performs a 'left outer join' to 'another collection' in the same database to combine documents from two 
collections based on a 'common field'.
-> LEFT (OUTER) JOIN: Returns 'all records' from the 'left table', and the 'matched records' from the 'right table'

authors
[
  { _id: 100, name: 'F. Scott Fitzgerald', birth_year: 1896 },
  { _id: 101, name: 'George Orwell', birth_year: 1903 },
  { _id: 102, name: 'Harper Lee', birth_year: 1926 }
]
books
[
  {
    _id: 1,
    title: 'The Great Gatsby',
    author_id: 100,
    genre: 'Classic'
  },
  {
    _id: 2,
    author_id: 101,
    genre: 'Dystopian'
  },
  {
    _id: 3,
    title: 'To Kill a Mockingbird',
    author_id: 102,
    genre: 'Classic'
  }
]
Query> db.books.aggregate([
    {
        $lookup: {
            from: 'authors',
            localField: "author_id",
            foreignField: "_id",
            as: "author_details"
        }
    }
])
output: 
[
  {
    _id: 1,
    title: 'The Great Gatsby',
    author_id: 100,
    genre: 'Classic',
    author_details: [ { _id: 100, name: 'F. Scott Fitzgerald', birth_year: 1896 } ]
  },
  {
    _id: 2,
    title: 'Nineteen Eighty-Four',
    author_id: 101,
    genre: 'Dystopian',
    author_details: [ { _id: 101, name: 'George Orwell', birth_year: 1903 } ]
  },
  {
    _id: 3,
    title: 'To Kill a Mockingbird',
    author_id: 102,
    genre: 'Classic',
    author_details: [ { _id: 102, name: 'Harper Lee', birth_year: 1926 } ]
  }
]


db.books.aggregate([
    {
        $lookup:{
            from: 'authors',
            localField: "author_id",
            foreignField: "_id",
            as: "author_details"
        }
    },
    {
        $addFields: {
            author_details: {
                $first: "$author_details"
            }
        }
    }
])




