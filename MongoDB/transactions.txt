ðŸ” ACID stands for:

A - Atomicity
All or nothing: A transaction either completes fully or doesn't happen at all.
Example: In a bank transfer, both debit and credit must succeed â€” or neither.


C - Consistency

Ensures the database stays in a valid state before and after the transaction.
Consistency ensures rules are enforced automatically by the database or application logic â€” preventing corrupt data.
Letâ€™s say your bank requires that account balances never be negative.
Now imagine a transaction where:
A user tries to withdraw â‚¹10,000 from an account with only â‚¹5,000.
If the transaction were processed without checking the balance, the account would become -â‚¹5,000, violating the rule.

âŒ Without Consistency:

UPDATE accounts SET balance = balance - 10000 WHERE id = 1;
âœ… With Consistency:

IF (balance >= 10000) {
  balance -= 10000;
  // commit
} else {
  // reject
}
So, Consistency ensures this type of rule is enforced automatically by the database or application logic â€” preventing corrupt data.



I - Isolation

Isolation ensures that concurrent transactions do not interfere with each other, and each runs as if it were the only transaction running.
ðŸ• Real-World Example (Ordering System):
Imagine two customers placing an order for the last pizza in stock at the same time.
Without proper isolation, both transactions might:
Check stock â†’ sees 1 pizza
Place the order â†’ both succeed
Final stock = -1 âŒ (data corruption)
This is known as a race condition.

âœ… With Isolation (e.g., using locks or isolation levels):
Transaction A starts, locks the row, places the order, updates stock to 0, commits.
Transaction B must wait for A to finish, then it sees stock = 0 and fails the order.
Each transaction behaves as if executed one at a time, even though theyâ€™re parallel


D - Durability
Once committed, changes are permanent, even if the system crashes.



âœ… MongoDB does support ACID properties, but with some context


ðŸ§© MongoDB and ACID â€” in a nutshell:
âœ… Single Document Operations
Always ACID-compliant.

Even if the document is huge or deeply nested (subdocuments, arrays, etc).

Because MongoDB treats each document as independent and atomic.

âœ… Multi-document Transactions (MongoDB 4.0+)
From MongoDB 4.0 (for replica sets) and 4.2 (for sharded clusters), multi-document ACID transactions are supported.

So you can now do:

Atomic operations across multiple collections.

Transactions similar to relational databases (like MySQL, PostgreSQL).







-> It is possible after we executed 1st operation something may goes wrong. may be our server crashes or connection to mongoDB drop.
-> then 2nd operation will not complete.
-> thats where we need transaction.
-> so with transcation we insure that the both operations wil update the state of our data in the database or none of the will update/applied. 
so they are atomic. they both completes they both rollback.

ðŸ“„Note: 

Transactions are used for write operations (insert, update, delete) that need to be atomic. 
For read-only operations like getRental, transactions are unnecessary and add unnecessary overhead.




-> In MongoDB, a transaction is a sequence of one or more operationsâ€”such as insertions, updates, deletions, and readsâ€”that are executed as a single, atomic unit. 
-> This means that either all operations within the transaction are successfully applied, or none are, ensuring data integrity and consistency. 
-> Transactions in MongoDB adhere/stick to the ACID properties: Atomicity, Consistency, Isolation, and Durability.
-> MongoDB transactions are particularly useful in scenarios where multiple related operations need to be executed atomically

Use Cases for MongoDB Transactions:

1ï¸âƒ£. Financial Transactions
Use Case: Transferring funds between two accounts.
Details:
In a banking system, transferring money from one account to another involves two operations:
Deducting the amount from the source account.
Adding the amount to the destination account.
Both operations must succeed or fail together to ensure the total balance remains consistent.
Without transactions, a failure in one operation could lead to inconsistencies (e.g., money deducted but not credited).
Example:

 const createAccount = async (accountId, balance) => {
    try{
        const createdAccount = new Account({accountId, balance})
        await createdAccount.save();
        console.log(createdAccount);
    }catch(err){
        console.log(err.message);
    }
 }

//  createAccount("1", 12345);
//  createAccount("2", 678910);

const transferMoney = async (senderId, receiverId, amount) => {
    const session = await mongoose.startSession();

    try {
        session.startTransaction();

        // Deduct money from sender
        const sender = await Account.findOneAndUpdate(
            { accountId: senderId },
            { $inc: { balance: -amount } },
            { session, returnDocument: "after" } // Fix: Correct option
        );

        if (!sender) {
            throw new Error("Sender not found");
        } else if (sender.balance < 0) {
            throw new Error("Insufficient funds in sender's account");
        }

        console.log(`Updated Sender Balance: ${sender.balance}`);

        // Add money to receiver
        const receiver = await Account.findOneAndUpdate(
            { accountId: receiverId },
            { $inc: { balance: amount } },
            { session, returnDocument: "after" }
        );

        if (!receiver) {
            throw new Error("Receiver not found");
        }

        console.log(`Updated Receiver Balance: ${receiver.balance}`);

        // Commit transaction
        await session.commitTransaction();
        console.log("Transaction Committed Successfully");

        return { success: true, senderBalance: sender.balance, receiverBalance: receiver.balance };

    } catch (err) {
        await session.abortTransaction();
        session.endSession();   // don't require await 
        console.log("Transaction Aborted:", err.message);
        return { success: false, error: err.message };
    }
};








2ï¸âƒ£. If we deleted a Author then we have to delate all books related to that author which he wrote.
so this operation must be atomic.

example: 
const mongoose = require('mongoose');

const connectDB = async () =>  {
    try{
        const connect = await mongoose.connect("mongodb+srv://obiuch1234:a7zvaIFFmKz5KFkE@cluster0.q92we.mongodb.net/vidly?retryWrites=true&w=majority&appName=Cluster0");
        console.log(`host name: ${connect.connection.host}`)
        console.log(`DB Name: ${connect.connection.name}`)
    }catch(err){
        console.log(err.message);
    }
}

connectDB();


const Author = mongoose.model("Author", new mongoose.Schema({
    name: String
}));

const Book = mongoose.model("Book", new mongoose.Schema({
    title: String,
    authorId: { 
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Author'
    }
}));


async function createAuthor(name){
    try{
        const author = new Author({
            name
        })
        await author.save();
        console.log(author)
    }catch(err){
        console.log(err.message)
    }
}

// createAuthor("Max Maviilian");


async function createBook(title, authorId) {
    try {
        const book = new Book({ title, authorId })
        await book.save();

        console.log(book)
    } catch (error) {
        console.log(error.message)
    }
}


// createBook("React Js", "67b059aa344b6b5756d4f080")
// createBook("Node Js", "67b059aa344b6b5756d4f080")
// createBook("MongoDB", "67b059aa344b6b5756d4f080")



// when we delete authoe then all the books related to him must be deleted.

// method 1

In Mongoose, the { session } option is not valid for findByIdAndDelete or deleteMany. Instead, you should use the .session() method to attach the session to the query

const deleteAuthor = async (authorId) => {
    const session = await mongoose.startSession();
    
    try {
        session.startTransaction();

        // Delete the author
        const deletedAuthor = await Author.findByIdAndDelete(authorId).session(session); // Correct session usage
        if (!deletedAuthor) {
            throw new Error("Author not found");
        }

        // Delete all books associated with the author
        const deleteBooksResult = await Book.deleteMany({ authorId }).session(session); // Correct session usage
        console.log(`Deleted ${deleteBooksResult.deletedCount} books`);

        // Commit the transaction
        await session.commitTransaction();
        console.log("Transaction committed.");
    } catch (error) {
        // Abort the transaction on error
        await session.abortTransaction();
        console.error("Transaction aborted:", error.message);
        throw error; // Rethrow the error for further handling
    } finally {
        // End the session (cleanup)
        session.endSession();
    }
};

deleteAuthor("67b059aa344b6b5756d4f080");






real life ex: 

const deleteCustomer = async (req, res) => {
    const session = await mongoose.startSession();
    try {
        session.startTransaction();
        const { id: customerId } = req.params;

        // Validate customerId
        if(!validateObjectId(customerId)){
            await session.abortTransaction();
            session.endSession();
            return res.status(400).json({ message: `Invalid customer Object ID: ${customerId}` });
        }

        // Delete the customer
        const deletedCustomer = await Customer.findByIdAndDelete(customerId).session(session);
        if (!deletedCustomer) {
            await session.abortTransaction();
            session.endSession();
            return res.status(404).json({ message: `Customer with id ${customerId} not found` });
        }

        // Delete all rentals related to this customer
        const deleteRentalsResult = await Rental.deleteMany({ "customer._id": deletedCustomer._id }).session(session);
        controllerDebug(`Deleted ${deleteRentalsResult.deletedCount} rentals`);

        // Commit the transaction
        await session.commitTransaction();
        session.endSession();

        return res.status(200).json({ customer: deletedCustomer, message: `Customer with id ${customerId} deleted successfully` });
    } catch (err) {
        // Abort the transaction on error
        await session.abortTransaction();
        session.endSession();
        controllerDebug("Error in deleteCustomer:", err);
        return res.status(500).json({ message: err.message || "Internal Server Error" });
    }
};