Using `$regex` in MongoDB can be costly, especially for large datasets. Here‚Äôs why and how to optimize it:

Regex queries can perform well on small to medium-sized collections (e.g., up to 10,000 documents).
For larger collections (e.g., millions of documents), regex queries can become slow and resource-intensive.

When you use "prefix search" with a regular expression ($regex: "^searchTerm"), MongoDB can use a normal index (B-tree index),not a text index.
Suffix searches (searchTerm$) or general substring searches (searchTerm) "cannot" use an index effectively because MongoDB has to scan all documents to check if the 
string matches at the end or in the middle.




üö® Why is `$regex` Costly?
1. No Index Usage (for Prefix Searches)
   - If the search pattern is not anchored (`/^pattern/`), MongoDB cannot use indexes efficiently.
   - Example: db.users.find({ name: { $regex: "adesh", $options: "i" } })
     - Problem: This **scans the entire collection**, making it slow for large datasets.
     - Reason: The regex can match anywhere in the string, preventing index optimization.

2. Full Collection Scan
   - If no index is used, MongoDB checks every document, leading to high CPU and memory usage.

3. Performance Degrades with Large Data
   - If you have millions of users, regex queries will become very slow.

---

 üöÄ How to Optimize Regex Searches?

1Ô∏è‚É£ Use Indexed Prefix Search
üîπ If you search for names that start with a value, MongoDB can use indexes.  
‚úî Efficient Query:  { name: { $regex: /^Adesh/i } }
- Why? The `^` anchor forces MongoDB to search from the **beginning** of the string.
- Index Usage: ‚úÖ Uses indexes efficiently


‚ùå Avoid this (No index usage):
{ name: { $regex: "Adesh", $options: "i" } }
- Why? This searches anywhere in the name, causing a full scan.



2Ô∏è‚É£ Use MongoDB's Full-Text Search (`$text`)
If you need **case-insensitive, partial matching**, use **text indexes** instead of regex.

‚úÖ Step 1: Create a Text Index
```
db.users.createIndex({ name: "text" });
db.users.createIndex({ name: "text", bio: "text" });
```
‚úÖ Step 2: Query Using `$text`
```js
User.find({ $text: { $search: "Adesh" } });
```
- Advantages of `$text` Search:
  - Much faster than regex.
  - Uses indexes instead of scanning the whole collection.
  - Supports multiple fields (e.g., name, description).
  - Finds words even in the middle of a string.



üîπ Checking Index Usage
db.users.find({ name: { $regex: "^A" } }).explain("executionStats");
If it shows IXSCAN, the index is being used.
If it shows COLLSCAN, MongoDB is scanning the entire collection (not using the index).



---

3Ô∏è‚É£ Use Autocomplete with MongoDB Atlas Search
If you need Google-like search, use MongoDB Atlas Full-Text Search with the Autocomplete feature.







// Insert sample data into the "users" collection
db.users.insertMany([
  { "name": "John Doe", "email": "john@example.com", "title": "Software Developer", "status": "active", "version": "2.0", "code": "ABC123" },
  { "name": "john Jadhav", "email": "john@example.com", "title": "Software Developer", "status": "active", "version": "2.0", "code": "ABC123" },
  { "name": "Jane Smith", "email": "jane@example.com", "title": "Frontend Developer", "status": "inactive", "version": "3.0", "code": "XYZ456" },
  { "name": "Jane Smith", "email": "example@example.com", "title": "Frontend Developer", "status": "inactive", "version": "3.0", "code": "XYZ456" },
  { "name": "Alice Johnson", "email": "alice@gmail.example", "title": "Database Administrator", "status": "active", "version": "1.5", "code": "ABC789" },
  { "name": "Ram Johnson", "email": "alice@gmail.example", "title": "Database Administrator", "status": "active", "version": "1", "code": "ABC789" },
  { "name": "Bob Williams", "email": "bob@example.com", "title": "DevOps Engineer", "status": "inactive", "version": "2.5", "code": "DEF123" }
]);


"$regex" is the operator specifying a regular expression.

// Find documents where the "name" field starts with "john" (case-insensitive)
db.users.find({name: {$regex: '^john', $options: 'i'}}); // J === j

// Find documents where the "code" field starts with "ABC"
db.users.find({name: {$regex: '^john'}}); J!==j

// Find documents where the "name" field ends with "jadhav" (case-insensitive)       
db.users.find({name: {$regex: 'jadhav$', $options: 'i'}})  // j===J               

// Find documents where the "name" field ends with "jadhav" (case-insensitive)
db.users.find({name: {$regex: 'jadhav$'}})  // j!==J

// Find documents where the "email" field contains "example"
db.users.find({ "email": { "$regex": "example" } })  // j!==J

// Find documents where the "email" field contains "example"
db.users.find({ name: { $regex: "de", $options: 'i' } })  // Since "de" appears in "Dev", "Deepak", "Sandeep", and "ADELAIDE" (case insensitive match).


// Find documents where the "version" field starts with a digit from '1' to '3'
// Note that version field contain numeric string
// this query have no effect : db.users.find({$and: [{version: {$gte: 1}}, {version: {$lte: 2}}]})
db.users.find({ version: { "$regex": "^[1-3]" } })

db.users.find({
   $expr: {
     $and: [
       { $gte: [ { $toDouble: "$version" }, 1.0 ] },
      { $lte: [ { $toDouble: "$version" }, 2.0 ] }
     ]
   }
})