1Ô∏è‚É£ What is GraphQL, and how does it differ from REST?

üëâ GraphQL is a "query language for APIs" that allows clients to request exactly the data they need, reducing "over-fetching" and "under-fetching" of data.
GraphQL is used on both the client and backend

Differences from REST:
Flexible Data Fetching ‚Äì Clients specify the exact fields they need, unlike REST, where fixed endpoints return predefined data.

Single Endpoint ‚Äì GraphQL typically uses a single "/graphql" endpoint, whereas REST has multiple endpoints for different resources.

Efficient Data Fetching ‚Äì Fetch multiple related resources in a single request, avoiding multiple API calls in REST.

Strongly Typed Schema ‚Äì GraphQL uses a "schema" to define the structure of API responses, while REST relies on standard JSON responses.

Backend Agnostic ‚Äì Works with any database or programming language, making it highly adaptable.

No Over-fetching/Under-fetching ‚Äì REST responses may include unnecessary data (Over-fetching) or require multiple requests(Under-fetching), while GraphQL delivers only 
what's requested.

Under-fetching happens when a REST API doesn't return enough data in a single request, forcing the client to make multiple API calls to gather all the required information.
‚úÖ Example of Under-Fetching
GET /movies/123  
üîª Response:
{
  "id": 123,
  "title": "Inception",
  "directorId": 5
}
üö® Problem: The API only returns directorId, so the client must make another request:
GET /directors/5
üîª Response:
{
  "id": 5,
  "name": "Christopher Nolan"
}
üìå ‚ùå Multiple requests = slower performance

GraphQL Solution: The client specifies exactly what fields it needs, reducing data transfer and improving performance.

‚úÖ Solution: Use GraphQL or Expand Data in REST
GraphQL: Fetch exactly what you need in one request.
```
{
  movie(id: 123) {
    title
    director {
      name
    }
  }
}
```

============================================================================================================================================================


‚ùì where we use GraphQL?

‚úÖ GraphQL is used on both the client and backend! üöÄ

üîπ GraphQL on the Backend

üëâ The backend defines the GraphQL schema and resolves queries.
// Define GraphQL Schema
const typeDefs = `#graphql
  type Movie {
    id: ID!
    title: String!
    director: String!
    releaseYear: Int!
  }

  type Query {
    movies: [Movie]
    movie(id: ID!): Movie
  }

  type Mutation {
    addMovie(title: String!, director: String!, releaseYear: Int!): Movie
    updateMovie(id: ID!, title: String, director: String, releaseYear: Int): Movie
    deleteMovie(id: ID!): String
  }
`;


üëâ It uses GraphQL servers like Apollo Server, Express-GraphQL, or Mercurius.
Apollo Server, Express-GraphQL, and Mercurius are different "GraphQL server" implementations that provide ways to set up and run a GraphQL API
Each of these libraries helps handle GraphQL queries, mutations, and subscriptions, but they have different architectures and features.



üëâ The GraphQL resolver functions fetch data from databases or APIs.
ex: 
const resolvers = {
  Query: {
    getMovies: async () => await Movie.find(),   // database
  },
  Mutation: {
    addMovie: async (_, { title, director, releaseYear }) => {
      const movie = new Movie({ title, director, releaseYear });
      return await movie.save();
    }
  },
};

from api: 
    resolvers: {
      Query: {
        user: async (todo) =>
          (await axios.get(`https://jsonplaceholder.typicode.com/users/${todo.userId}`))
            .data,
      }
    }




============================================================================================================================================================




‚ùì Explain the difference between "queries", "mutations", and "subscriptions" in GraphQL.


1Ô∏è‚É£ Queries ‚Äì Fetch Data

Similar to GET requests in REST.
Used to retrieve data without modifying it.
Clients can request specific fields.

Example:
query {
  movie(id: "123") {
    title
    genre
  }
}



2Ô∏è‚É£ Mutations ‚Äì Modify Data

Similar to POST, PUT, DELETE in REST.
Used to create, update, or delete data.
Can return updated data after execution.

Example:
mutation {
  addMovie(title: "Inception", genre: "Sci-Fi") {
    id
    title
  }
}


3Ô∏è‚É£ Subscriptions ‚Äì Real-time Updates

Uses "WebSockets" to push real-time updates to clients.
Clients stay connected and get notified when data changes.
we can integrate GraphQL Subscriptions using WebSockets (graphql-ws).


Example:
subscription {
  movieAdded {
    id
    title
  }
}