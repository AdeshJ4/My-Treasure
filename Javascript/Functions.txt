-> arrow function don't have their own "this". they used "this" value from their enclosing execution context.

-> In js, there are two ways of defining a function.
	1. Function Declaration
	2. Function Expression

1. Function Declaration

-> Normal way of defining a function
 
function intro(){
	console.log('Function declaration');
}


2. Function Expression

-> storing a function inside a variable like a expression.

const fun1 = function (){
    console.log('Anonymous Function expression');
};

const fun2 = function intro(){
    console.log('Named Function expression');
};


Note: 

const fun = function(){
	console.log("Hello");
}

let another = fun;

// both another and fun1 are referencing to same function in memory which is a object in memory because functions are special kind 
of object.





-> we can call a function which is define using function declaration syntax before it is defined.
-> but we can't do that with function expression syntax.
-> when our js engine executes this code it moves the all function declaration to the top.

ex. 

walk();
function walk(){
	log('walk');
}


================================================================================================================================================


JavaScript Hoisting: 
--------------------

-> Hoisting is JavaScript's default behavior of moving all declarations(function declaration, variable declaration) to the top of 
the current  which can be current script or the current function and this done by automatically by js engine.

-> In JavaScript,variables can be used before declaration.
-> but it is applicable to "var" keyword only, and not for "let" & "const".
-> if you talked about "let" keyword you have to first declare the let variable then and only then you can use it.
-> const keyword must be initialized at the time of declaration.
-> JavaScript in strict mode does not allow variables to be used if they are not declared.

x = 5;  // initialization
var x;  // declaration

-> same with function. 
-> we can call a function which is define using function declaration syntax before it is defined.

walk();
function walk(){
	log('walk');
}


================================================================================================================================================

Arguments : 
-----------

-> we have object called "arguments" which contain all arguments passed to function.
function fun (){
    let sum=0;
    for (let args of arguments){
        sum += args
    }
    console.log(typeof(arguments));  // object 
    console.log('First Element : ', arguments[0]);  // accessing element
    console.log(arguments);  
    console.log(arguments.length);  
    console.log(sum); 
}

fun(10, 20, 30, 50);


================================================================================================================================================

Rest parameters : 
-----------------

-> The rest parameter allows a function to accept an indefinite number of arguments as an array.
-> ex:
function add (...theArgs){ // theArgs is array and in js arrays are objet thats why typeof array is 'object'
    let sum = 0;
    for (let num of theArgs)
        sum +=num

    console.log(typeof theArgs);
    console.log('First Element: ', theArgs[0]); 
    console.log('Sum : ', sum);
}
add(10, 20, 30)


================================================================================================================================================

Getter and Setter Methods : 
--------------------------

-> ECMAScript 5 (ES5 2009) introduced Getter and Setters.
-> Getters and setters allow you to define Object Accessors (Computed Properties).
-> with the help of getter and setter our original properties are not exposed to outside environment. so it provide abstraction.
-> if you want to access any property of an object then you can access it through getter method.
-> if you want to change value of any property then you can change through setter method.

1. Getter: 

-> we used getter to access properties of an object.
-> we can access function as a property

2. Setter: 

-> we used setter to change or mutate properties of an object.


const person = {
  firstName: "Adesh",
  lastName: "Jadhav",
  age: 22,
  get fname() {
    return this.firstName;
  },
  set fname(value) {
    if(typeof value !== 'string') throw new Error('Value is not string');
    this.firstName = value;
  },
  get fullName() {
    return this.firstName + " " + this.lastName;
  },
  set fullName({ fname, lname }) {
    this.firstName = fname;
    this.lastName = lname;
  },
};

person.fullName = { fname: "Akshay", lname: "pawade" };
console.log("Full Name: " + person.fullName);
console.log("First name: " + person.fname);
person.fname = "Adesh";
console.log("Full Name: " + person.fullName);



================================================================================================================================================

Default Parameter : 
-------------------

-> Default parameter are the parameters which are initialized with default values if no value or undefined is passed.

function multiply(a, b = 1) {
  return a * b;
}
console.log(multiply(5, 2));
// Expected output: 10
console.log(multiply(5));
// Expected output: 5


================================================================================================================================================







JavaScript let Vs var : 
=======================


	      let							                                      var
-> let is block-scoped.					                          -> var is function scoped.
-> let does not allow to redeclare variables.		          -> var allows to redeclare variables.
-> Hoisting does not occur in let.				                -> Hoisting occurs in var.
-> let doesn't attach with window object                  -> attach with window object & can overwrite global properties







this: 
-----

-> "this" references the object that is executing the current function.
-> so if that function is part of that object "this" reference that obj itself.
-> otherwise if that function is regular function which means it is not part of the object then "this" references to global object 
which is "window" object in the browser and "global" in node.
-> in case of constructor function, we all know that we create object using new operator. so new operator create a new empty object 
like this {} and set "this" to point newly created object.


ex

1. function inside obj

const obj = {
    fname: "Adesh",
    age: 22,
    fun(){
        console.log(this);
    }
}
obj.fun();  // here "this" refer to object itself

o/p-> { fname: 'Adesh', age: 22, fun: [Function: fun] }


2. separate function

function fun(){
	console.log(this);		
}
fun();

o/p-> [object Window]


3. Constructor function: 

function Person(fname){
  this.fname = fname;  // we added new property inside empty object created by new operator.
  console.log(this);
}

const p1 = new Person('Adesh');

o/p-> Person { fname: 'Adesh' }




4. callback function: 

const obj = {
  title: 'A',
  tags : ['a', 'b', 'c'],
  showTags(){
    this.tags.forEach(function(tag){
      console.log(this, tag);
    })
  }
}
obj.showTags();

o/p-> 
Window {window: Window, self: Window, document: document, name: '', location: Location, …} 'a'
Window {window: Window, self: Window, document: document, name: '', location: Location, …} 'b'
Window {window: Window, self: Window, document: document, name: '', location: Location, …} 'c'


/* 
"this" from callback function of forEach refer to window/global object.
why this is happing .
because that callback function is inside a forEach method and not a inside a obj. so it acts as a regular function
and in case of regular function "this" refer to global object.
*/ 

solution : 

const person = {
  title: 'A',
  tags : ['a', 'b', 'c'],
  showTags(){
    this.tags.forEach(function(tag){
      console.log(this.title, tag);
    }, this)  					// ->  }, {title: 'A',tags : ['a', 'b', 'c'], ...});
  }
}
person.showTags();

o/p=> 
A a
A b
A c

/* 
our forEach method have 2nd parameter which is "thisArg" means we can pass object as a 2nd parameter and "this" will 
points to that object. but we have our obj which is Person so we don't have to pass extra object. just write "this" as 
a 2nd parameter . note that showTag() comes under obj so new "this" will not refer to global.

Note : but not all methods will give you ability to pass "this"  as 2nd argument.
*/ 

solution : 

ex. 1 : using self = this;

const obj = {
  title: "a",
  tags: ["A", "B", "C"],
  showTags() {
    const self = this;
    this.tags.forEach(function(tag){
      console.log(self.title, tag);
    });
  },
};

obj.showTags();


ex.2 : using bind() method

const obj = {
  title: 'a',
  tags: ['A', 'B', 'C'],
  showTags(){
    this.tags.forEach(function(tag){
      console.log(this.title, tag);
    }.bind(this));
  }
};

obj.showTags();



ex. 3 : using arrow function

-> The good thing about arrow function is that they inherit "this" value from containing function in below ex that function is 
showTags().
-> Arrow functions do not have their own this. They are not well suited for defining object methods.
-> Arrow functions are not hoisted. They must be defined before they are used.


const obj = {
  title: 'a',
  tags: ['A', 'B', 'C'],
  showTags(){
    this.tags.forEach((tag)=>{
      console.log(this.title, tag);
    });
  }
};

obj.showTags()












































