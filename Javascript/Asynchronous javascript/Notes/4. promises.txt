JavaScript Promises:
--------------------

-> promise is javascript object which holds the eventual(result of period of time) result of an asynchronous operation.
-> Promises are used to handle the eventual result (success or failure) of an asynchronous operation
-> when asynchronous operation completes it can either return result in value or an error.
-> A promise basically promise you that it will give the result of an asynchronous operation.
-> this object can be in one of the three state: 
	1. Pending
	2. Fulfilled
	3. Rejected

While a Promise object is "pending" (working), the result is undefined.

When a Promise object is "fulfilled", the result is a value.

When a Promise object is "rejected", the result is an error object.



🔴 then catch finally :
-----------------------
.then()
Used to handle the "resolved value" of a promise.
.catch()
Used to handle promise rejection.
.finally()
Executes code regardless of whether the promise resolved or rejected.

ex: 
Promise.resolve("Done")
  .then(res => console.log(res))
  .catch(err => err.message)
  .finally(() => console.log("Always runs"));






-> Initially when we create promise object it is initially in "pending" state.
-> at this point it will kick/start some asynchronous operations.
-> when the result is ready the promise can either be fulfilled or resolved which basically means asynchronous operation completes 
successfully so here we have a value.
-> otherwise if something went wrong during the execution of that asynchronous operation our promise is in the rejected state.
in this we have an error object.


✅ Example of Handling Asynchronous Operation Result


example 1: 
function fetchUsers() {
  return fetch("https://jsonplaceholder.typicode.com/users");  // fetch() return promise which we have to handle by try-catch-finallyl
}

fetchUsers()
  .then((res) => res.json())
  .then((users) => console.log(users[0]))
  .catch((err) => err.message)

✅ This is a valid example of a Promise because the fetch() function returns a Promise that resolves when the HTTP request is completed.
In your example, you are not creating a Promise; instead, you are handling a Promise returned by fetch().
✅ Why is this a Promise Example?
fetch() is asynchronous and returns a Promise.
.then((res) => res.json()) handles the resolved Promise and returns another Promise.
.then((users) => console.log(users[0])) processes the JSON response.
.catch((err) => console.error(err.message)) catches any errors, such as network failures.



🔍 Understanding the Difference
👉Creating a Promise:
When you manually define a Promise using new Promise((resolve, reject) => {...}).
👉Handling a Promise:
When you work with an already existing Promise (like fetch()), using .then(), .catch(), or async/await.





Ex.
-

code 1:

console.log('start');  // task 1

// task 2
let p = new Promise((resolve, reject) => {
  setTimeout(() => {
      resolve({id: 101, name: 'Adesh'});
        // reject(new Error("Message: Error...."));
  }, 2000);
});

p
.then((res) => console.log(res))
.catch((err) => console.log(err.message));



console.log('End');  // task 3




Ex 2:

console.log("Before");
getUser(101)
    .then((user)=>getRepositories(user.gitHubUsername))
    .then((repos) => getCommits(repos[0]))
    .then((commits)=> console.log(commits))
    .catch((err)=>console.log(err.message))
console.log("After");

function getUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log("Fetching User from Database...");
      resolve({ id: id, gitHubUsername: "AdeshJ4" });
    }, 2000);
  });
}

function getRepositories(userName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching repos from Database for user ${userName}...`);
      resolve(["repo1", "repo2", "repo3"]);
    }, 2000);
  });
}

function getCommits(repoName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching commits from Database for repo ${repoName}...`);
      resolve(["commit1", "commit2", "commit3"]);
    }, 2000);
  });
}




✅ 1. Promise.resolve()
Creates a promise that is resolved with a given value.
```
Promise.resolve("Hello").then(console.log); // Output: Hello
```


✅ 2. Promise.reject():
Creates a promise that is rejected with a given reason.
```
Promise.reject("Error").catch(console.log); // Output: Error
```




Promise.all([])
---------------

-> Promise.all() is a method is used to run multiple promises parallelly, simultaneously with each other.
-> Promise.all() takes an array of Promises and returns a single Promise that:
"Resolves" when all input Promises resolve, returning an array of results.
"Rejects" immediately if any Promise rejects, returning the first error.
-> If any Promise rejects, the entire Promise.all() fails.
-> In Promise.all, all promises are initiated almost simultaneously, not sequentially. 



code: 
-----
const p1 = new Promise((resolve) => setTimeout(() => resolve("First Promise"), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve("Second Promise"), 2000));
const p3 = new Promise((resolve) => setTimeout(() => resolve("Third Promise"), 1500));

Promise.all([p1, p2, p3])
  .then((results) => console.log(results)) // ["First Promise", "Second Promise", "Third Promise"]
  .catch((err) => console.error("Error:", err));


real example: 

const urls = [
  "https://jsonplaceholder.typicode.com/users",
  "https://jsonplaceholder.typicode.com/posts",
  "https://jsonplaceholder.typicode.com/comments",
];

Promise.all(urls.map((url) => fetch(url).then((res) => res.json())))
  .then((results) => {
    console.log("Users:", results[0]);
    console.log("Posts:", results[1]);
    console.log("Comments:", results[2]);
  })
  .catch((err) => console.error("API Fetch Error:", err.message));






Promise.race([p1, p2]):
-----------------------
-> when you have to do something as soon as first promise completes then instead of using Promise.all() we have to use 
Promise.race([p1, p2])
-> race() method only returned you first promise who completes its execution fast, this method will not see first promise is 
going to send you resolve or rejected message.
-> in this case our first promise completes first so result is : 
Async Operation 1...
{ id: 101, name: 'Adesh' }

-> also result is not in array format.

code: 
------
const p1 = new Promise((resolve) => setTimeout(() => resolve("First Promise"), 2000));
const p2 = new Promise((resolve, reject) => setTimeout(() => reject(new Promise("Something went wrong)), 100));

Promise
    .race([p1, p2])
    .then((res)=>console.log(res))
    .catch((err)=> console.log(err.message));










✅ Promise.any() : 
-----------------
-> Its similar to Promise.race() but it return only first resolve promise who completes its execution firstly than others.
-> any() method only returned you fulfilled promise who completes its execution fast.
-> if first promise is giving rejected value then this method will search other promise who is givin resolve value.

ex:
let p1 = new Promise((resolve, reject) => setTimeout(() => resolve("resolve 1"), 700));
let p2 = new Promise((resolve, reject) => setTimeout(() => resolve("resolve 2"), 600));
let p3 = new Promise((resolve, reject) => setTimeout(() => reject(new Error('rejected 3')), 500));

Promise.any([p1, p2, p3])
    .then(data => console.log(data))
    .catch(err => console.log(err.message));








✅ Promise.allSettled():
------------------------
Waits for all promises to settle (resolve or reject) and gives the result for each.
Promise.allSettled() gives you a promise that resolves with an array of results, where each result is an object with either:
{ status: "fulfilled", value: result } – if the promise was successful
{ status: "rejected", reason: error } – if the promise was rejected



```
let p1 = new Promise((resolve, reject) => setTimeout(() => resolve("resolve 1"), 700));
let p2 = new Promise((resolve, reject) => setTimeout(() => resolve("resolve 2"), 600));
let p3 = new Promise((resolve, reject) => setTimeout(() => reject(new Error('rejected 3')), 500));

Promise.allSettled([p1, p2, p3])
    .then(data => console.log(data))
    .catch(err => console.log(err.message));
```







Creating Settled Promises:
--------------------------

-> Sometimes we have to create a promise that is already resolved. this is particularly used while writing unit tests.
-> in your unit test you have to write promise that is already resolved.

code : 
======

const p = Promise.resolve({id: 101, name: "Adesh"});

p.then((res)=> {
    console.log(res);
})

output: 
========
{id: 101, name: 'Adesh'}
