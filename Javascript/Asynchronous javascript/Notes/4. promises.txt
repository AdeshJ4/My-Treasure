JavaScript Promises:
--------------------

-> In JavaScript, a promise is a good way to handle result of asynchronous operations/task.
asynchronous operations/task is a operations/task thats goint to take time ans running in background.
-> It is used to find out if the asynchronous operation is successfully completed or not.
-> promise is javascript object which holds the eventual(result of period of time) result of an asynchronous operation.
-> when asynchronous operation completes it can either return result in value or an error.
-> A promise basically promise you that it will give the result of an asynchronous operation.
-> this object can be in one of the three state: 
	1. Pending
	2. Fulfilled
	3. Rejected

While a Promise object is "pending" (working), the result is undefined.

When a Promise object is "fulfilled", the result is a value.

When a Promise object is "rejected", the result is an error object.



-> Initially when we create promise object it is initially in "pending" state.
-> at this point it will kick/start some asynchronous operations.
-> when the result is ready the promise can either be fulfilled or resolved which basically means asynchronous operation completes 
successfully so here we have a value.
-> otherwise if something went wrong during the execution of that asynchronous operation our promise is in the rejected state.
in this we have an error object.


example 1: 
function fetchUsers() {
  return fetch("https://jsonplaceholder.typicode.com/users");  // fetch() return promise which we have to handle by try-catch-finallyl
}

fetchUsers()
  .then((res) => res.json())
  .then((users) => console.log(users[0]))
  .catch((err) => err.message)




Ex.
-

code 1:

console.log('start');  // task 1

// task 2
let p = new Promise((resolve, reject) => {
  setTimeout(() => {
      resolve({id: 101, name: 'Adesh'});
        // reject(new Error("Message: Error...."));
  }, 2000);
});

p
.then((res) => console.log(res))
.catch((err) => console.log(err.message));



console.log('End');  // task 3




Ex 2:

console.log("Before");
getUser(101)
    .then((user)=>getRepositories(user.gitHubUsername))
    .then((repos) => getCommits(repos[0]))
    .then((commits)=> console.log(commits))
    .catch((err)=>console.log(err.message))
console.log("After");

function getUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log("Fetching User from Database...");
      resolve({ id: id, gitHubUsername: "AdeshJ4" });
    }, 2000);
  });
}

function getRepositories(userName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching repos from Database for user ${userName}...`);
      resolve(["repo1", "repo2", "repo3"]);
    }, 2000);
  });
}

function getCommits(repoName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching commits from Database for repo ${repoName}...`);
      resolve(["commit1", "commit2", "commit3"]);
    }, 2000);
  });
}










Promise.all([])
---------------

-> Promise.all() is a method that takes an array of Promises and returns a single Promise that:
"Resolves" when all input Promises resolve, returning an array of results.
"Rejects" immediately if any Promise rejects, returning the first error.
-> Promise.all() waits for all to resolve, then returns [p1 result, p2 result, p3 result].
-> If any Promise rejects, the entire Promise.all() fails.
-> In Promise.all, all promises are initiated almost simultaneously, not sequentially. 
The event loop schedules their execution in quick succession
-> Promise.all initiates all promises in the array without waiting for any of them to complete


code: 
-----
const p1 = new Promise((resolve) => setTimeout(() => resolve("First Promise"), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve("Second Promise"), 2000));
const p3 = new Promise((resolve) => setTimeout(() => resolve("Third Promise"), 1500));

Promise.all([p1, p2, p3])
  .then((results) => console.log(results)) // ["First Promise", "Second Promise", "Third Promise"]
  .catch((err) => console.error("Error:", err));


real example: 

const urls = [
  "https://jsonplaceholder.typicode.com/users",
  "https://jsonplaceholder.typicode.com/posts",
  "https://jsonplaceholder.typicode.com/comments",
];

Promise.all(urls.map((url) => fetch(url).then((res) => res.json())))
  .then((results) => {
    console.log("Users:", results[0]);
    console.log("Posts:", results[1]);
    console.log("Comments:", results[2]);
  })
  .catch((err) => console.error("API Fetch Error:", err.message));






Promise.race([p1, p2]):
-----------------------
-> when you have to do something as soon as first promise completes then instead of using Promise.all() we have to use 
Promise.race([p1, p2])
-> race() method only returned you first promise who completes its execution fast, this method will not see first promise is 
going to send you resolve or rejected message.
-> in this case our first promise completes first so result is : 
Async Operation 1...
{ id: 101, name: 'Adesh' }

-> also result is not in array format.

code: 
------
const p1 = new Promise((resolve, reject)=>{
    setTimeout(()=>{
        console.log('Async Operation 1...');
        resolve({id: 101, name: 'Adesh'});
    }, 2000)
});

let p2 = new Promise((resolve, reject)=>{
    setTimeout(() => {
        console.log('Async Operation 2...');
        // resolve({id: 102, name: "Akshay"});
        reject(new Error('Something failed'))
    }, 2000);
})


Promise
    .race([p1, p2])
    .then((res)=>console.log(res))
    .catch((err)=> console.log(err.message));


output: 
-------

Async Operation 1...
{ id: 101, name: 'Adesh' }



Creating Settled Promises:
--------------------------

-> Sometimes we have to create a promise that is already resolved. this is particularly used while writing unit tests.
-> in your unit test you have to write promise that is already resolved.

code : 
======

const p = Promise.resolve({id: 101, name: "Adesh"});

p.then((res)=> {
    console.log(res);
})

output: 
========
{id: 101, name: 'Adesh'}














Promise.any(): 

-> Promise.any() method is used to run multiple promises parallelly, simultaneously with each other and return only first resolve 
promise who completes its execution firstly than others.
-> any() method takes array of promises.
-> any() method return, first single fulfilled promise from list of promises.
-> if first promise is giving rejected value then this method will search other promise who is givin resolve value.
-> if all of the given promises are rejected, then it returned array which contain rejected errors.
-> any() method only returned you fulfilled promise who completes its execution fast.

const p1 = new Promise((resolve, reject) =>
  setTimeout(()=> {    
    // resolve('Promise 1')
    reject(new Error('Error detected in Promise p1'))
  }, 1000)
);
const p2 = new Promise((resolve, reject) =>
  setTimeout(()=> {
    reject(new Error('Error detected in Promise p2'))
    // reject('Promise 2')
  }, 500)
);
const p3 = new Promise((resolve, reject) =>
  setTimeout(()=> {
    reject(new Error('Error detected in Promise p3'))
    // resolve('Promise 3')
  }, 1500)
);

Promise.any([p1, p2, p3])
  .then(value=> console.log('Fulfilled with:', value))
  .catch(err => console.log('All promises were rejected:', err))






Promise.prototype.finally()

-> The finally() method will help if you're going to do any processing or cleanup work once a promise is made, regardless of the 
outcome.

function add(n1, n2){
    return new Promise((resolve, reject)=> {
        if(typeof n1 === 'number' && typeof n2 === 'number'){
            resolve(n1 + n2)
        }else{
            reject(new Error('Not a number'))
        }
    })
}

add
    .then(res => console.log('result: ' + res))
    .catch(err => console.log(err.message))
    .finally(()=>console.log('Number are closed'));

expected output: 15 Numbers are added.
                     
