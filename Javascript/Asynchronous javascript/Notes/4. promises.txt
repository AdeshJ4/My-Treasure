JavaScript Promises:
--------------------

-> promise is javascript object which holds the eventual(result of period of time) result of an asynchronous operation.
-> when asynchronous operation completes it can either return result in value or an error.
-> A promise basically promise you that it will give the result of an asynchronous operation.
-> this object can be in one of the three state: 
	1. Pending
	2. Fulfilled
	3. Rejected

While a Promise object is "pending" (working), the result is undefined.

When a Promise object is "fulfilled", the result is a value.

When a Promise object is "rejected", the result is an error object.



-> Initially when we create promise object it is initially in "pending" state.
-> at this point it will kick/start some asynchronous operations.
-> when the result is ready the promise can either be fulfilled or resolved which basically means asynchronous operation completes 
successfully so here we have a value.
-> otherwise if something went wrong during the execution of that asynchronous operation our promise is in the rejected state.
in this we have an error object.



Ex.
--

let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        // resolve({id: 101, name: 'Adesh'});
          reject(new Error("Message: Error...."));
    }, 2000);
});

p
    .then((res) => console.log(res))
    .catch((err) => console.log(err.message));



Ex 2:

console.log("Before");
getUser(101)
    .then((user)=>getRepositories(user.gitHubUsername))
    .then((repos) => getCommits(repos[0]))
    .then((commits)=> console.log(commits))
    .catch((err)=>console.log(err.message))
console.log("After");

function getUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log("Fetching User from Database...");
      resolve({ id: id, gitHubUsername: "AdeshJ4" });
    }, 2000);
  });
}

function getRepositories(userName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching repos from Database for user ${userName}...`);
      resolve(["repo1", "repo2", "repo3"]);
    }, 2000);
  });
}

function getCommits(repoName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching commits from Database for repo ${repoName}...`);
      resolve(["commit1", "commit2", "commit3"]);
    }, 2000);
  });
}










Promise.all([])
---------------

-> Promise.all is a method that takes an array of promises and returns a new promise.
-> This new promise contain array of the results when all promises are successfully fulfilled.
-> Sometimes we have to run few asynchronous operations in parallel,and when they all complete you wanna do something after.
-> for example you may call different api like facebook api and twitter api and when the result of both asynchronous operations are ready then you are gonna return something to user.

code: 
-----

const p1 = new Promise((resolve, reject)=>{
    setTimeout(()=>{
        console.log('Async Operation 1...');
        resolve({id: 101, name: 'Adesh'});
    }, 2000)
});

let p2 = new Promise((resolve, reject)=>{
    setTimeout(() => {
        console.log('Async Operation 2...');
        resolve({id: 102, name: "Akshay"});
    }, 2000);
})


Promise
    .all([p1, p2])
    .then((res)=>console.log(res))
    .catch((err)=> console.log(err.message));


Output: 
-------

Async Operation 1...
Async Operation 2...
[ { id: 101, name: 'Adesh' }, { id: 102, name: 'Akshay' } ]


Explanation: 
------------

Promise.all([p1, p2]):
----------------------

-> in this ex we don't have real concurrency .
-> we don't have multi-thread. we are still dealing with single thread.
-> but that single thread is kicking off multiple asynchronous operations almost at the same time not exactly at the same time.
-> first it execute first async operation after that thread is release. so immediately after it start second async operation.
-> we are not waiting for result of first async operation to be ready
-> Both async operation starts almost at the same time.
-> when we get the res, the result is in array. 
-> if one of the promise failed then final promise is considered as a failed.


Promise.race([p1, p2]):
-----------------------
-> when you have to do something as soon as first promise completes then instead of using Promise.all() we have to use 
Promise.race([p1, p2])
-> race() method only returned you first promise who completes its execution fast, this method will not see first promise is 
going to send you resolve or rejected message.
-> in this case our first promise completes first so result is : 
Async Operation 1...
{ id: 101, name: 'Adesh' }

-> also result is not in array format.

code: 
------
const p1 = new Promise((resolve, reject)=>{
    setTimeout(()=>{
        console.log('Async Operation 1...');
        resolve({id: 101, name: 'Adesh'});
    }, 2000)
});

let p2 = new Promise((resolve, reject)=>{
    setTimeout(() => {
        console.log('Async Operation 2...');
        // resolve({id: 102, name: "Akshay"});
        reject(new Error('Something failed'))
    }, 2000);
})


Promise
    .race([p1, p2])
    .then((res)=>console.log(res))
    .catch((err)=> console.log(err.message));


output: 
-------

Async Operation 1...
{ id: 101, name: 'Adesh' }



Creating Settled Promises:
--------------------------

-> Sometimes we have to create a promise that is already resolved. this is particularly used while writing unit tests.
-> in your unit test you have to write promise that is already resolved.

code : 
======

const p = Promise.resolve({id: 101, name: "Adesh"});

p.then((res)=> {
    console.log(res);
})

output: 
========
{id: 101, name: 'Adesh'}














Promise.any(): 

-> Promise.any() method is used to run multiple promises parallelly, simultaneously with each other and return only first resolve 
promise who completes its execution firstly than others.
-> any() method takes array of promises.
-> any() method return, first single fulfilled promise from list of promises.
-> if first promise is giving rejected value then this method will search other promise who is givin resolve value.
-> if all of the given promises are rejected, then it returned array which contain rejected errors.
-> any() method only returned you fulfilled promise who completes its execution fast.

const p1 = new Promise((resolve, reject) =>
  setTimeout(()=> {    
    // resolve('Promise 1')
    reject(new Error('Error detected in Promise p1'))
  }, 1000)
);
const p2 = new Promise((resolve, reject) =>
  setTimeout(()=> {
    reject(new Error('Error detected in Promise p2'))
    // reject('Promise 2')
  }, 500)
);
const p3 = new Promise((resolve, reject) =>
  setTimeout(()=> {
    reject(new Error('Error detected in Promise p3'))
    // resolve('Promise 3')
  }, 1500)
);

Promise.any([p1, p2, p3])
  .then(value=> console.log('Fulfilled with:', value))
  .catch(err => console.log('All promises were rejected:', err))






Promise.prototype.finally()

-> The finally() method will help if you're going to do any processing or cleanup work once a promise is made, regardless of the 
outcome.

function add(n1, n2){
    return new Promise((resolve, reject)=> {
        if(typeof n1 === 'number' && typeof n2 === 'number'){
            resolve(n1 + n2)
        }else{
            reject(new Error('Not a number'))
        }
    })
}

add
    .then(res => console.log('result: ' + res))
    .catch(err => console.log(err.message))
    .finally(()=>console.log('Number are closed'));

expected output: 15 Numbers are added.
                     
