JavaScript Promises:
--------------------

-> promise is javascript object which holds the eventual(result of period of time) result of an asynchronous operation.
-> Promises are used to handle the eventual result (success or failure) of an asynchronous operation
-> when asynchronous operation completes it can either return result in value or an error.
-> A promise basically promise you that it will give the result of an asynchronous operation.
-> this object can be in one of the three state: 
	1. Pending
	2. Fulfilled
	3. Rejected

While a Promise object is "pending" (working), the result is undefined.

When a Promise object is "fulfilled", the result is a value.

When a Promise object is "rejected", the result is an error object.



ðŸ”´ then catch finally :
-----------------------
.then()
Used to handle the "resolved value" of a promise.
.catch()
Used to handle promise rejection.
.finally()
Executes code regardless of whether the promise resolved or rejected.

ex: 
Promise.resolve("Done")
  .then(res => console.log(res))
  .catch(err => err.message)
  .finally(() => console.log("Always runs"));






-> Initially when we create promise object it is initially in "pending" state.
-> at this point it will kick/start some asynchronous operations.
-> when the result is ready the promise can either be fulfilled or resolved which basically means asynchronous operation completes 
successfully so here we have a value.
-> otherwise if something went wrong during the execution of that asynchronous operation our promise is in the rejected state.
in this we have an error object.


âœ… Example of Handling Asynchronous Operation Result


example 1: 
function fetchUsers() {
  return fetch("https://jsonplaceholder.typicode.com/users");  // fetch() return promise which we have to handle by try-catch-finallyl
}

fetchUsers()
  .then((res) => res.json())
  .then((users) => console.log(users[0]))
  .catch((err) => err.message)

âœ… This is a valid example of a Promise because the fetch() function returns a Promise that resolves when the HTTP request is completed.
In your example, you are not creating a Promise; instead, you are handling a Promise returned by fetch().
âœ… Why is this a Promise Example?
fetch() is asynchronous and returns a Promise.
.then((res) => res.json()) handles the resolved Promise and returns another Promise.
.then((users) => console.log(users[0])) processes the JSON response.
.catch((err) => console.error(err.message)) catches any errors, such as network failures.



ðŸ” Understanding the Difference
ðŸ‘‰Creating a Promise:
When you manually define a Promise using new Promise((resolve, reject) => {...}).
ðŸ‘‰Handling a Promise:
When you work with an already existing Promise (like fetch()), using .then(), .catch(), or async/await.





Ex.
-

code 1:

console.log('start');  // task 1

// task 2
let p = new Promise((resolve, reject) => {
  setTimeout(() => {
      resolve({id: 101, name: 'Adesh'});
        // reject(new Error("Message: Error...."));
  }, 2000);
});

p
.then((res) => console.log(res))
.catch((err) => console.log(err.message));



console.log('End');  // task 3




Ex 2:

console.log("Before");
getUser(101)
    .then((user)=>getRepositories(user.gitHubUsername))
    .then((repos) => getCommits(repos[0]))
    .then((commits)=> console.log(commits))
    .catch((err)=>console.log(err.message))
console.log("After");

function getUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log("Fetching User from Database...");
      resolve({ id: id, gitHubUsername: "AdeshJ4" });
    }, 2000);
  });
}

function getRepositories(userName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching repos from Database for user ${userName}...`);
      resolve(["repo1", "repo2", "repo3"]);
    }, 2000);
  });
}

function getCommits(repoName) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log(`Fetching commits from Database for repo ${repoName}...`);
      resolve(["commit1", "commit2", "commit3"]);
    }, 2000);
  });
}




âœ… 1. Promise.resolve()
Creates a promise that is resolved with a given value.
```
Promise.resolve("Hello").then(console.log); // Output: Hello
```


âœ… 2. Promise.reject():
Creates a promise that is rejected with a given reason.
```
Promise.reject("Error").catch(console.log); // Output: Error
```




Promise.all([])
---------------

-> Promise.all() is a method is used to run multiple promises parallelly, simultaneously with each other.
-> Promise.all() takes an array of Promises and returns a single Promise that:
"Resolves" when all input Promises resolve, returning an array of results.
"Rejects" immediately if any Promise rejects, returning the first error.
-> If any Promise rejects, the entire Promise.all() fails.
-> In Promise.all, all promises are initiated almost simultaneously, not sequentially. 



code: 
-----
const p1 = new Promise((resolve) => setTimeout(() => resolve("First Promise"), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve("Second Promise"), 2000));
const p3 = new Promise((resolve) => setTimeout(() => resolve("Third Promise"), 1500));

Promise.all([p1, p2, p3])
  .then((results) => console.log(results)) // ["First Promise", "Second Promise", "Third Promise"]
  .catch((err) => console.error("Error:", err));


real example: 

const urls = [
  "https://jsonplaceholder.typicode.com/users",
  "https://jsonplaceholder.typicode.com/posts",
  "https://jsonplaceholder.typicode.com/comments",
];

Promise.all(urls.map((url) => fetch(url).then((res) => res.json())))
  .then((results) => {
    console.log("Users:", results[0]);
    console.log("Posts:", results[1]);
    console.log("Comments:", results[2]);
  })
  .catch((err) => console.error("API Fetch Error:", err.message));






Promise.race([p1, p2]):
-----------------------
-> when you have to do something as soon as first promise completes then instead of using Promise.all() we have to use 
Promise.race([p1, p2])
-> race() method only returned you first promise who completes its execution fast, this method will not see first promise is 
going to send you resolve or rejected message.
-> in this case our first promise completes first so result is : 
Async Operation 1...
{ id: 101, name: 'Adesh' }

-> also result is not in array format.

code: 
------
const p1 = new Promise((resolve) => setTimeout(() => resolve("First Promise"), 2000));
const p2 = new Promise((resolve, reject) => setTimeout(() => reject(new Promise("Something went wrong)), 100));

Promise
    .race([p1, p2])
    .then((res)=>console.log(res))
    .catch((err)=> console.log(err.message));










âœ… Promise.any() : 
-----------------
-> Its similar to Promise.race() but it return only first resolve promise who completes its execution firstly than others.
-> any() method only returned you fulfilled promise who completes its execution fast.
-> if first promise is giving rejected value then this method will search other promise who is givin resolve value.

ex:
let p1 = new Promise((resolve, reject) => setTimeout(() => resolve("resolve 1"), 700));
let p2 = new Promise((resolve, reject) => setTimeout(() => resolve("resolve 2"), 600));
let p3 = new Promise((resolve, reject) => setTimeout(() => reject(new Error('rejected 3')), 500));

Promise.any([p1, p2, p3])
    .then(data => console.log(data))
    .catch(err => console.log(err.message));








âœ… Promise.allSettled():
------------------------
Waits for all promises to settle (resolve or reject) and gives the result for each.
Promise.allSettled() gives you a promise that resolves with an array of results, where each result is an object with either:
{ status: "fulfilled", value: result } â€“ if the promise was successful
{ status: "rejected", reason: error } â€“ if the promise was rejected



```
let p1 = new Promise((resolve, reject) => setTimeout(() => resolve("resolve 1"), 700));
let p2 = new Promise((resolve, reject) => setTimeout(() => resolve("resolve 2"), 600));
let p3 = new Promise((resolve, reject) => setTimeout(() => reject(new Error('rejected 3')), 500));

Promise.allSettled([p1, p2, p3])
    .then(data => console.log(data))
    .catch(err => console.log(err.message));
```







Creating Settled Promises:
--------------------------

-> Sometimes we have to create a promise that is already resolved. this is particularly used while writing unit tests.
-> in your unit test you have to write promise that is already resolved.

code : 
======

const p = Promise.resolve({id: 101, name: "Adesh"});

p.then((res)=> {
    console.log(res);
})

output: 
========
{id: 101, name: 'Adesh'}
