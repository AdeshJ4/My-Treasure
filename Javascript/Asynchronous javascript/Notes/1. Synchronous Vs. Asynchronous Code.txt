In JavaScript, synchronous and asynchronous refer to how code is executed, particularly when dealing with tasks that take time to complete, such as network requests, 
file I/O, or timers.




Synchronous Code : 
------------------

-> Synchronous code is executed line by line (sequential) and blocking manner.
-> Each operation must complete before the next one starts. it means first task/operation completes its execution then and only then 2nd task/operation will start 
its execution.
-> It blocks the next task execution until the current task completes
-> other thing to notice is that the order of execution in sequential that means It follows a natural flow of execution which is 
from top to bottom, and each line of code is executed one after the other.


code:

console.log("task 1");
function longCalculation() {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) { // 1 billion iterations
    sum += i;
  }
  console.log("Calculation Done:", sum);
}
longCalculation();// task 2
console.log("task 3");

📌 The UI freezes until the function completes because JavaScript executes synchronously by default.







Asynchronous Code:
------------------

-> Asynchronous code does not block execution. 
-> Instead of waiting for a task to finish, JavaScript moves on to the next task and handles the asynchronous operation in the background.
-> Asynchronous here refers to all those "functions" in JavaScript that are processed in the background without blocking any other request.
✅ Asynchronous functions in JavaScript include:
1. setTimeout() / setInterval() (Delays execution)
2. fetch() (API calls)
3. async/await (Better syntax for Promises)
4. Promises (Handles future values)

-> Asynchronous code is executed in a simultaneously, parallelly and non-blocking manner.
-> Asynchronous programming is a technique that enables your program to start a long-running task and still be able to be responsive 
to other tasks while that long running task runs, rather than having to wait until that long running task has finished. 
Once that long running task has finished, your program is presented with the result.
-> you can handle multiple tasks simultaneously, parallelly rather than executing them one after the other. 
This is especially important in scenarios where tasks, such as fetching data from a server or reading a file, may take some time. 
this doesn't block the execution of the program. 
-> callbacks, promises, async-await handle the result of these asynchronous operations.
-> In an asynchronous architecture, when a request arrives at the server, Node assigns a single thread to handle it. Suppose the request involves querying a 
database—since database queries take time, the thread does not wait for the database to return the result. Instead, while the database processes the query, 
the thread is freed up to serve another request.



There are three patterns to deal with asynchronous code : 

1. callBack
2. Promises
3. Async/Await  (basically syntactical sugar over promises)


ex: 

console.log("task 1");
setTimeout(() => {
    longCalculation();
}); // task 2
console.log("task 3");

function longCalculation() {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) { // 1 billion iterations
    sum += i;
  }
  console.log("Calculation Done:", sum);
}







-> Node.js applications are asynchronous by default
-> JavaScript is single-threaded by nature. This means it can only execute one operation at a time per execution context. 
However, JavaScript achieves asynchronous, non-blocking behavior through: Event Loop, callbacks, promises, async-await
-> Node.js uses a "single-threaded event loop" to handle requests asynchronously. It operates on a non-blocking, event-driven architecture, which allows it to 
handle multiple requests concurrently without creating multiple threads for each request.
-> While the "main event loop" runs on a single thread, Node.js can delegate heavy tasks (like file system operations, cryptography, and database queries) to the 
libuv thread pool, which uses multiple worker threads in the background. If you use the Worker Threads API, you can explicitly create multiple threads in Node.js
-> In an asynchronous architecture, when a request arrives at a Node.js server, the event loop handles it using a single-threaded, non-blocking model. 
If the request involves fetching data from a database, or reading a file, or making an API call, Node.js delegates the task to a background worker. 
The event loop does not wait for the database to return the result; instead, it continues handling other requests.  
-> Once the asynchronous operations (like fetching data from a database, reading a file, or making an API call) are completed, the corresponding callback function 
or task is added to the Event Queue so that the Node.js event loop can process it when it's free.
-> Event Loop Continuously checks the Event Queue. Processes callbacks in FIFO (First In, First Out) order when the main thread is free.
-> This kind of architecture make a node ideal for building applications which includes lots of disk or network access like 
I/O-intensive apps.

Why is Node.js Ideal for I/O-Intensive Apps?
💡 Reason: asynchronous, non-blocking, event-driven architecture.
In traditional, multi-threaded servers (e.g., PHP, Java Spring), each request gets a dedicated thread. 
If the thread is waiting for a file read or database query, it blocks until the operation is complete, reducing efficiency.
Node.js, however, does not block the execution while waiting for I/O operations. It delegates I/O tasks to background workers, freeing the main thread to handle other 
requests.
This allows Node.js to efficiently handle thousands of concurrent connections with minimal hardware resources.



Examples of I/O-Intensive Applications:
✅ Chat Applications → WebSockets handle thousands of real-time messages without blocking.
✅ Streaming Services → Netflix, YouTube, Spotify use non-blocking I/O to stream videos/music efficiently.
✅ APIs & Microservices → Node.js APIs efficiently handle high network traffic.
✅ File Upload/Download Services → Cloud storage apps (e.g., Dropbox, Google Drive) process files asynchronously.
✅ Database-Driven Apps → E-commerce sites, social media platforms query databases frequently.

Not Ideal for CPU-Intensive Tasks
❌ Node.js is NOT suitable for applications that require heavy computations (e.g., video encoding, AI processing, large-scale data analysis).
❌ CPU-intensive tasks block the main thread, preventing other requests from being processed.
👉 Solution? Use Worker Threads in Node.js or choose a multi-threaded language (e.g., Python, Java, C++).


-> This is why many companies (Netflix, PayPal, LinkedIn, Uber, etc.) use Node.js for real-time, data-driven applications. 🚀








-> Javascript is synchronous, blocking, single threaded language.
-> To make async programming possible we need the help of libuv library.

Code execution in node js : 

On the left we have V8 engine which consists of two parts: 
1. memory heap
2. Call Stack

and on the right side we have : libuv library

-> whenever we declare a variable or function memory is allocated on the heap.
-> When you executed code function is pushed to the call stack and when the function returned it popped out call stack.


-> On the right we have 'libuv' library 
-> whenever you execute async method it is off loaded to the libuv.
-> libuv then run the task using "native async mechanism" of operating system.
-> and if that is not possible it will utilized its thread pool to run that task ensuring the main thread is not block
(main thread resides in call stack).




How V8 engine and libuv are used by node .

1. Synchronous code Execution in Node js : 

ex> 

1. console.log('First')
1. console.log('Second')
1. console.log('Third')


Step 1 : The main thread of execution always starts in the global() scope. global() function is pushed to the stack.
Step 2 : Then on line 1 we have log('First') statement. The log statement is pushed to the stack. First is log to the console. The log statement is popped out of stack.
Step 3 : Execution comes to line two. Second log statement is pushed on the stack. Second is log tot he console and log popped out of stack after Execution
Step 4 : Finally execution comes on line three. Third log statement is pushed on the stack. Third is log to the console and log popped out of stack after Execution
Step 5 : No code is left to execute so global() will be popped from stack.

This is how synchronous code execute in node runtime.

 

Asynchronous Code Execution in Node js: 

1. console.log('First);
2. fs.readFile('demo.txt',()=>{
3.     console.log('Second);
4. });
5. console.log('Third);


Step 1 : The main thread of execution always starts in the global() scope. global() function is pushed to the stack.
Step 2 : Then on line 1 we have log('First') statement. The log statement is pushed to the stack. 'First' is log to the console. The log statement is popped out of stack.
Step 3 : Execution comes to line two. The readFile() method gets pushed to the stack. readFile() is async operation thats why it 
will be off loaded to 'libuv' section only callback function present inside readFile() will be handed over to libuv. 
readFile() without callback will remain inside call stack section. like : fs.readFile();
Step 4 : Javascript then simply pops out fs.readFile() method from the call stack because its job is done as far as executing of 
line 2 is concerned. remember we still have callback function of readFile() inside libuv section. In the background libuv starts 
read file content on a 'separate thread'.
Step 5 : Now flow of execution moves to line 5. last log statement is pushed on the stack. 'Third' is log to the console and log 
popped out of stack after Execution.
Step 6 : Now there is no user written code in the call stack. so call stack is empty. At some point the file read task completed in 
the thread pool. The associate call back function is now pushedto the call sta ck. Inside the callback function we have log statement
which is pushed to call stack. Second is log to the statement and the log is pop out. as there are no more code left in callback, 
the callback also pop out from stack. 
Step 7 : Now no more code to run so global() also pop out.
Step 8 : The output will be 'First', 'Second', 'Third'. 
