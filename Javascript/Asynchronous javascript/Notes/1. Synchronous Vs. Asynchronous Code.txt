In JavaScript, synchronous and asynchronous refer to how code is executed, particularly when dealing with tasks that take time to complete, such as network requests, 
file I/O, or timers.




Synchronous Code : 
------------------

-> Synchronous code is executed line by line (sequential) and blocking manner.
-> Each operation must complete before the next one starts. it means first task/operation completes its execution then and only then 2nd task/operation will start 
its execution.
-> It blocks the next task execution until the current task completes
-> other thing to notice is that the order of execution in sequential that means It follows a natural flow of execution which is 
from top to bottom, and each line of code is executed one after the other.


code:

console.log("task 1");
function longCalculation() {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) { // 1 billion iterations
    sum += i;
  }
  console.log("Calculation Done:", sum);
}
longCalculation();// task 2
console.log("task 3");

ðŸ“Œ The UI freezes until the function completes because JavaScript executes synchronously by default.


real life example: 

ðŸš¦ Real-Life Analogy: A Toll Booth on a One-Lane Road
Imagine a toll booth on a single-lane road where cars must stop one by one, pay the toll, and then continue.
â›” Each car must wait for the car in front to finish paying before it can proceed.


Practical Knowledge: 

-> In a synchronous architecture, when we receive a request on a server, node allocate a thread to handle that request. 
suppose that request is queering a database. as you know queering a database may takes some time for returning a result.
-> so When database is executing a query that thread is sitting ideal. 
-> Now suppose another request comes at that point then we have to allocate another thread for a new request.
-> Now imagine, what will happen, if we have a server with lots of no of concurrent requests/clients.
-> At some time we will out of threads because there are lots of concurrent request.
-> so new client or request have to wait until threads are available or if we don't want to wait them we need to add more hardware. 
so with this kind of architecture we are not utilizing recourses efficiently this is a problem with  blocking or synchronous 
architecture. this is how applications are build with frameworks like ASP.NET. works by default. of course in ASP.net it is possible 
to use asynchronous architecture but you have to do extra work for that


JavaScript is single-threaded by nature. This means it can only execute one operation at a time per execution context. 
However, JavaScript achieves asynchronous, non-blocking behavior through:
Event Loop â€“ Handles the execution of asynchronous tasks (like timers, I/O, and promises).
Callbacks â€“ Functions passed to handle certain events when they occur.
Web APIs â€“ Browsers provide APIs (like setTimeout, fetch) that offload tasks to separate threads outside the main JavaScript thread.
Promises & async/await â€“ Facilitate asynchronous operations in a more readable manner.
Web Workers â€“ Enable multi-threading by running JavaScript in the background without blocking the main thread.
In essence, while the core JavaScript engine is single-threaded, the surrounding environment (browser or Node.js) enables concurrency using asynchronous mechanisms.












Asynchronous Code:
------------------

-> Asynchronous code does not block execution. 
-> Instead of waiting for a task to finish, JavaScript moves on to the next task and handles the asynchronous operation in the background.
-> Asynchronous here refers to all those "functions" in JavaScript that are processed in the background without blocking any other request.
âœ… Asynchronous functions in JavaScript include:
1. setTimeout() / setInterval() (Delays execution)
2. fetch() (API calls)
3. async/await (Better syntax for Promises)
4. Promises (Handles future values)

-> Asynchronous code is executed in a simultaneously, parallelly and non-blocking manner.
-> Asynchronous programming is a technique that enables your program to start a long-running task and still be able to be responsive 
to other tasks while that long running task runs, rather than having to wait until that long running task has finished. 
Once that long running task has finished, your program is presented with the result.
-> you can handle multiple tasks simultaneously, parallelly rather than executing them one after the other. 
This is especially important in scenarios where tasks, such as fetching data from a server or reading a file, may take some time. 
this doesn't block the execution of the program. 
-> callbacks, promises, async-await handle the result of these asynchronous operations.



There are three patterns to deal with asynchronous code : 

1. callBack
2. Promises
3. Async/Await  (basically syntactical sugar over promises)


ex: 

console.log("task 1");
setTimeout(() => {
    longCalculation();
}); // task 2
console.log("task 3");

function longCalculation() {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) { // 1 billion iterations
    sum += i;
  }
  console.log("Calculation Done:", sum);
}



real life example: 

-> imagine you go to restaurant, waiter comes to a table. takes your order and give it to a chef in the kitchen. then he moves immediaely to serve another table while the chef preparing you meal.
-> The main point here is that waiter does not stop at the chef for waiting 1st customer order because that order was going to take time instead he moves immediately to take order of 2nd cusomer/table.
-> So he waiter does no seat ideal.
-> because of this same waiter can serves many different tables.
-> The waiter is like a single thread allocated to handle a request.so a single thread is used to handle multiple requests.
-> This is what we called non-blocking Asynchronous programming/Architecture.
-> And this is how  Node Applications work.


Practical Knowledge: 

-> JavaScript is single-threaded by nature
-> Node applications are Asynchronous by default.
-> In node we have a single thread to handle all requests.
-> In Asynchronous architecture, When a request arrives on a server, Node assign single thread to handle that request. suppose that 
request is queering a database. as you know queering a database may takes some time for returning a result but important point is 
that our thread doesn't have to wait for database to return a data. while the database is executing query that thread is used to 
serve another client/request.
-> When our asynchronous task completes in our case asynchronous task is fetching data from database, database puts the message in 
what we called "Event Queue/Message Queue".
-> The browser or Node.js APIs (e.g., fetching data from a database) put the completed task or callback message into the Event Queue.
-> Node is continuously monitoring queue in background. when Node found event in this event queue node will take out that event 
or data and process it.
-> The Event Queue (or Message Queue) in JavaScript follows the FIFO (First In, First Out) 
-> This kind of architecture make a node ideal for building applications which includes lots of disk or network access like 
I/O-intensive apps.
-> we can serve more clients without the need of using more hardware. and that why node application highly scalable.
-> In contrast Node should not be used for CPU intensive apps like a video encoding or image manipulations services. In this kind 
of applications we have a lots of calculation that should be done by CPU  and few operations touch the file system or the network. 
-> Since Node applications are single threaded when performing calculations to serve one client other clients have to wait and thats 
why node should not be used for CPU intensive applications. it should only be used for data intensive and real time applications. 




============================================================================================================

Javascript is synchronous, blocking, single threaded language.

Yes, that's correct. JavaScript is often described as a synchronous, single-threaded, and blocking language. Let's break down each 
aspect:

1. **Synchronous:** JavaScript executes code line by line, means in sequential manner. 
Each operation is completed before moving on to the next one. 

2. **Single-Threaded:** JavaScript operates on a single thread, meaning it has only one execution context or "thread of execution." 
In a single-threaded environment, only one set of instructions is executed at a time.

3. **Blocking:** JavaScript is considered blocking because certain operations, especially I/O (Input/Output) operations, 
can block the execution of the entire program. For example, if you perform a time-consuming task or fetch data from an external API, 
the execution of your code can be blocked until that task is completed.

However, it's important to note that JavaScript also has 'non-blocking features', particularly in the context of handling asynchronous 
operations. Asynchronous behavior is commonly achieved through features like callbacks, Promises, and async/await syntax. 
These mechanisms allow JavaScript to perform tasks concurrently without waiting for each operation to complete before moving on to 
the next one.

In summary, while JavaScript is fundamentally synchronous and single-threaded, its non-blocking features enable efficient handling 
of asynchronous tasks, making it suitable for building responsive and scalable web applications.





-> Javascript is synchronous, blocking, single threaded language.
-> To make async programming possible we need the help of libuv library.

Code execution in node js : 

On the left we have V8 engine which consists of two parts: 
1. memory heap
2. Call Stack

and on the right side we have : libuv library

-> whenever we declare a variable or function memory is allocated on the heap.
-> When you executed code function is pushed to the call stack and when the function returned it popped out call stack.


-> On the right we have 'libuv' library 
-> whenever you execute async method it is off loaded to the libuv.
-> libuv then run the task using "native async mechanism" of operating system.
-> and if that is not possible it will utilized its thread pool to run that task ensuring the main thread is not block
(main thread resides in call stack).




How V8 engine and libuv are used by node .

1. Synchronous code Execution in Node js : 

ex> 

1. console.log('First')
1. console.log('Second')
1. console.log('Third')


Step 1 : The main thread of execution always starts in the global() scope. global() function is pushed to the stack.
Step 2 : Then on line 1 we have log('First') statement. The log statement is pushed to the stack. First is log to the console. The log statement is popped out of stack.
Step 3 : Execution comes to line two. Second log statement is pushed on the stack. Second is log tot he console and log popped out of stack after Execution
Step 4 : Finally execution comes on line three. Third log statement is pushed on the stack. Third is log to the console and log popped out of stack after Execution
Step 5 : No code is left to execute so global() will be popped from stack.

This is how synchronous code execute in node runtime.

 

Asynchronous Code Execution in Node js: 

1. console.log('First);
2. fs.readFile('demo.txt',()=>{
3.     console.log('Second);
4. });
5. console.log('Third);


Step 1 : The main thread of execution always starts in the global() scope. global() function is pushed to the stack.
Step 2 : Then on line 1 we have log('First') statement. The log statement is pushed to the stack. 'First' is log to the console. The log statement is popped out of stack.
Step 3 : Execution comes to line two. The readFile() method gets pushed to the stack. readFile() is async operation thats why it 
will be off loaded to 'libuv' section only callback function present inside readFile() will be handed over to libuv. 
readFile() without callback will remain inside call stack section. like : fs.readFile();
Step 4 : Javascript then simply pops out fs.readFile() method from the call stack because its job is done as far as executing of 
line 2 is concerned. remember we still have callback function of readFile() inside libuv section. In the background libuv starts 
read file content on a 'separate thread'.
Step 5 : Now flow of execution moves to line 5. last log statement is pushed on the stack. 'Third' is log to the console and log 
popped out of stack after Execution.
Step 6 : Now there is no user written code in the call stack. so call stack is empty. At some point the file read task completed in 
the thread pool. The associate call back function is now pushed to the call stack. Inside the callback function we have log statement
which is pushed to call stack. Second is log to the statement and the log is pop out. as there are no more code left in callback, 
the callback also pop out from stack. 
Step 7 : Now no more code to run so global() also pop out.
Step 8 : The output will be 'First', 'Second', 'Third'. 
