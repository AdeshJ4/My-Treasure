-> async/await is a modern way to handle Promises that makes asynchronous code look and behave more like synchronous code
-> async-await are nothing but syntactically sugar over the promise.
-> "async and await make promises easier to write"
-> async makes a function return a Promise
-> await pauses execution until the Promise resolves.

-> we write 'async' keyword before a function which is going to return promise.
-> The await keyword can only be used inside an async function.
-> The await keyword makes the function pause the execution and wait for a resolved promise before it continues:



âœ… Why Use async/await?
Simplifies promise handling (.then() and .catch() become unnecessary).
Avoids callback hell and improves readability.
Error handling with try...catch is more intuitive


âœ”ï¸ async/await makes async code look like sync code, but itâ€™s still non-blocking.
âœ”ï¸ The main thread never stops; await only pauses execution inside the async function.
âœ”ï¸ async/await improves readability while maintaining the benefits of asynchronous execution.



ğŸ”¥ How async/await Works

1ï¸âƒ£ Declaring an async Function

When a function is marked with async, it always returns a Promise.

async function fetchData() {
  return "Hello, World!";
}

fetchData().then(console.log); // Output: "Hello, World!"

Even if we return a simple value, JavaScript automatically wraps it in a Promise.



2ï¸âƒ£ Using await to Wait for a Promise
await pauses execution until the Promise resolves.
It can only be used inside an async function.

âœ… Example: Fetching API Data with async/await
Hereâ€™s how async/await makes fetching data from an API more readable:

```
async function fetchUsers() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/users");
    let users = await response.json(); // Wait for JSON conversion
    console.log(users[0]); // Print first user
  } catch (error) {
    console.error("Error fetching users:", error.message);
  }
}
```

ğŸ” What's Happening?
fetch() returns a Promise, and await waits for it to resolve.
response.json() also returns a Promise, which await resolves.
If an error occurs (e.g., network failure), the catch block handles it.




ğŸ”¥ Comparison: async/await vs then/catch

ğŸ”µ Using .then() and .catch() (Promises)
function fetchUsers() {
  fetch("https://jsonplaceholder.typicode.com/users")
    .then((response) => response.json())
    .then((users) => console.log(users[0]))
    .catch((error) => console.error("Error:", error.message));
}


ğŸŸ¢ Using async/await
async function fetchUsers() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/users");
    let users = await response.json();
    console.log(users[0]);
  } catch (error) {
    console.error("Error:", error.message);
  }
}


ğŸ¯ Key Takeaways
Feature	async/await	.then().catch()
Readability	âœ… More readable (looks synchronous)	âŒ Can get messy with multiple .then()
Error Handling	âœ… Uses try...catch	âŒ Uses .catch() separately
Code Complexity	âœ… Cleaner and easier to debug	âŒ Harder to read with nested Promises


